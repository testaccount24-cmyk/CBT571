./ ADD NAME=$$$#DATE 0100-02182-02182-0746-00012-00012-00000-SHIPDAT
REGULAR CBT TAPE - VERSION 448    FILE:  571

    ORIGINAL DSNAME:  SBGOLOB.CBT448.FILE571
    ---------------
                    --RECFM-LRECL-BLKSIZE-DSORG
                      FB    80    3200    PO

   PDS117I 89 MEMBERS COUNTED; CUMULATIVE SIZE IS 9,223 RECORDS


TIME THIS PDS WAS SHIPPED:   07/01/02    07:46:54    GMT-5:00

./ ADD NAME=$$$NOTE1 0100-02182-02182-0745-00033-00033-00000-SBGOLOB
Hi Sam,

Thanks for the kind thoughts.  I'm trying to take it easy,
but I'm afraid I'm not very good at it <g>.

Find attached v0004 of XMIT370/RECV370.  It's a zipped AWS of an
IEBCOPY unload of SYS2.XMIT370.ASM (the sole dataset) on a 3380.
Please let me know if you have any problems with restoring it.

Now, as to what's in it ... see the $* members in the PDS.  At
this stage of the game, I've not got MVS/ESA RECEIVE working with
a modified COPYR1.  However, I supply RECV370 which will take the
exact same XMIT that MVS/ESA RECEIVE complains about, unwrap the
IEBCOPY unloaded data, and reload the unloaded PDS by calling
IEBCOPY.  Too strange.  Confused am I.

The symptom is exactly the same as before the COPYR1 mod.  I've
verified that the COPYR1 record looks good, but it's wildly different
than what IEBCOPY displays as the COPYR1 record.  Something else is
afoot than just the COPYR1 record, I fear.  There are some notes
about this in $NOTES.  I have no particularly strong opinions as to
what's wrong at this point, so I'm sending you what I have ASIS.
 From what I can tell, the COPYR1 record looks good.  Fortunately,
with RECV370 it's now possible to unwrap an XMIT and display detailed
key/value pairs pretty easily, so that's my next step.

RECV370 functions fairly well, but has only received light testing.
In the doc, I say RECV370 isn't "officially" in this version, but
it's there for those who want to take a crack at it.

Best wishes,
Jim

./ ADD NAME=$CHANGES 0101-02182-02182-0707-00105-00105-00000-XMIT370
Copyright 2001, 2002 James M. Morrison

Change log



0004 - 2002/06/13
-----------------

First version to be contributed to the CBT tape.  Sam G gently prodded
me, and I finally did it.  See also

    http://ensose.com/mvs38j.html

for possibly more recent versions (in case I forget to send them to
Sam), and some other stuff for MVS38j - including

    MVS38j 3375/3380/3390 support,
    RECV390,
    and some Hercules user tools like rdrprep, dasdseq.

Really curious persons are free to check the mvs38j directory on that
machine for who-knows-what bits du-jour).  Most likely, I've said
something about those bits in the H390-MVS or hercules-390 groups
(currently hosted at Yahoogroups.com).

Addition of COPYR1 feature, which allows minor customization of the
IEBCOPY COPYR1 record for unloaded PDSs.  IEBCOPY is rumored to have
had variously sized COPYR1 records throughout it's history, this is
intended to create XMITs targeted for environments which have IEBCOPY
versions that don't understand differently sized COPYR1s.

Annoying XMITDBUG open fail message no longer appears; UTILTIOT used
to scan TIOT before open attempted

Renamed many macros, asm source code, jcl to permit distribution of
one library for CBT distribution ease.

Observant readers may note references to RECV370; it's not officially
in this version, but the code's there for the brave.  You'll likely
need it if you plan on receiving the XMITs created by XMIT370 with
something besides dasdload or RECV390.  That wasn't the plan, but
testing has revealed some interesting TSO/E RECEIVE/IEBCOPY behaviors
I wasn't counting on.  See $NOTES for further details.

UTILABND needs more work; the STSI technique for identifying Hercules
was recently (2002/06/19) decided, and this version of XMIT370 does
nothing in particular with it.  STSI is now a valid instruction
in S/370 mode under Hercules.  Getting the SYSIB seems beyond the
reach of S/370 mode however, as the STSI parm regs R0 & R1 need
to be 'grande' sized (64 bit); S/370 regs are obviously only 32 bit.
The HERC macro generates a DIAGNOSE instruction of various flavors.

This version should assemble OK with ASMF.  There are some "extra"
macros which I hope to get working later.  In particular, the
IM#INSTR macro I mentioned on H390-MVS isn't ready.  The sublist
macros IM#SUBL, IM#SPLIT aren't tested and are probably only needed
for ASMF; such nonsense isn't necessary for higher level assemblers.
IM#IGEN & IM#IGENF are internal to IM#INSTR (as I recall), and aren't
needed for this version.  Sam's been patient enough, so I'm leaving
them ASIS for now.



0003 - 2001/09/05
-----------------

Changed from custom License to Q Public License version                 1.0.

Includes new Debug facility.

Repackaged to build from source or XMIT.



0002 - 2001/06/13
-----------------

Clem Clarke was the only one who got this version.

The source code was converted from HLASM to ASM-F using the Rexx execs
(supplied only in previous versions, there's probably a copy of them
still lying around at ftp://ensose.com/mvs38j), which did about 75% of
the work converting the assembler source code & macros.  Deemed
necessary so that Hercules MVS38j users can play along.

Repair bug in XMITPUT which would ABENDS0C4 for some of Clem's JOL
files.



0001 - 2001/04/07
-----------------

Redistributed version 00.00 with source

Added directories for asm, jcl, list, mac and obj



0000 - 2001/02/26
-----------------

Initial distribution

./ ADD NAME=$COPY    0100-02182-02182-0701-00013-00013-00000-XMIT370

 Copyright 2001, 2002 James M. Morrison

 The contents of this PDS/archive are
 Copyright 2001, 2002 James M. Morrison
 with the exception of the IHADECB and IHADVCT macros,
 which are public domain.

 XMIT370/RECV370 is released under the provisions of the
 Q Public License version 1.0.

 Refer to the LICENSE member for the license details.

./ ADD NAME=$INTRO   0100-02182-02182-0701-00174-00174-00000-XMIT370

Copyright 2001, 2002 James M. Morrison

                XMIT370

                Version 00.04           June 13, 2002

The XMIT370/RECV370 source code and executables are
Copyright 2001, 2002  James M. Morrison.

XMIT370/RECV370 is released under the provisions of the
Q Public License version 1.0.
Refer to the LICENSE member for the license details.

Sorry, I had to crunch the HTML up to get it to fit in LRECL=80.
Check http://www.trolltech.com/developer/licensing/qpl.html which
is probably the same thing.



                Introduction
                ------------

Welcome to XMIT370.  This is the $INTRO file, which describes the       zip,
installation and execution of the XMIT370 program.

XMIT370 requires APF authorization.

Note for experienced systems programmers: please excuse my long
explanations, some portions of my target audience are just getting
started, and are possibly running MVS versions as old as MVS38j.
Quick install instructions: run JINSTALL, jump to DEMO section.

                Overview
                --------

XMIT370 is a program for execution under MVS 3.8J, which provides
facilities similar to the TSO/E TRANSMIT command processor.
As opportunities present themselves, I'm testing it under other
versions of MVS.

XMIT370 will, given a DSORG=PO or DSORG=PS dataset as input, produce
an XMIT file as output.

The resulting XMIT dataset can be processed using the TSO/E RECEIVE
command processor, Hercules dasdload (for DSORG=PO datasets), my
RECV390 program (for DSORG=PO datasets), or any of the other UnXmit
programs as detailed at http://planetmvs.com on the UnXmit Information
Exchange page.


                Installation
                ------------

If you're reading this, you've already figured out how to extract
the source code, JCL, and documentation from the archive, and
used TSO/E RECEIVE, or some work-alike facility to re-create the
PDS.  Not much else to do.

JINSTALL
--------

Modify the JINSTALL job as required for your shop.  In particular,
don't forget to change the LINK step SYSLMOD dataset.  XMIT370 must
eventually end up in an APF authorized dataset before it will run.
The SYS2.LOCAL.LINKLIB is what I use on my home MVS38j system.

If you're new to the systems programming game, you may need to review
and/or modify your SYS1.PARMLIB(IEAAPFxx) or SYS1.PARMLIB(PROGxx)
members, depending on your release of MVS.  More recent versions of
MVS allow PARMLIB datasets which aren't named SYS1.PARMLIB.  If you
aren't sure what you're doing, ask someone for help.

The following libraries are created:

        SYS2.XMIT370.LIST
        SYS2.XMIT370.OBJ

The job steps are:

        DELETE          Delete SYS2.XMIT370.*
        ALLOC           Allocate SYS2.XMIT370.*
        UTILxxxx        Assemble UTILxxxx source
        XMITxxxx        Assemble XMITxxxx source
        LINK            Linkage edit XMIT370

There's nothing special about using the ASMF assembler (IFOX00),
it's just what comes with MVS38j.  Replace with your preference of
assembler at will.

Once you have modified JINSTALL, submit it.  All steps should get
RC=0, with the possible exception of the DELETE step which might get
RC=8.

The target load library may be in the linklist, and must be an
APF authorized dataset.

That concludes the installation of XMIT370.


                Demonstration JCL
                -----------------

JDEMOPDS        Create XMIT from partitioned dataset (PDS; DSORG=PO)
JDEMOSEQ        Create XMIT from sequential dataset (DSORG=PS)


                XMIT370 JCL
                -----------

XMIT370 is a batch program, and requires APF authorization.

XMIT370 DDNAMEs:
----------------

        SYSPRINT        IEBCOPY output messages (required for DSORG=PO
                        input datasets on SYSUT1)

        XMITPRT         XMIT370 output messages (required)

        SYSUT1          input dataset to be XMIT370'd (required)

        SYSUT2          work dataset for IEBCOPY for DSORG=PO datasets;
                        should be large enough to contain SYSUT1
                        plus a little more (required for SYSUT1
                        DSORG=PO).
                        Temporary dataset deleted at end of step is OK.

        XMITOUT         XMIT370 output XMIT dataset (required)
                        Any DCB attributes you specify are currently
                        ignored.
                        Should be large enough to contain SYSUT1
                        plus some more for the XMIT370 "wrapper" and
                        any IEBCOPY overhead data (10 - 20% more
                        should be sufficient).

        SYSIN           IEBCOPY input dataset (required for SYSUT1
                        DSORG=PO datasets).
                        A DUMMY dataset.

        XMITDBUG        Optional, specifies debugging options.

Hercules users:

   For input datasets of DSORG=PO, you can use the Hercules dasdload
   program to restore the PDS to a dasd volume.

   You can also use the dasdpdsu program to extract the members from a
   PDS on Hercules dasd.

XMIT370 only supports input datasets of DSORG=PO and DSORG=PS.
I have concentrated most of my testing on RECFM=FB input datasets.

XMIT370 PARM=
-------------

XMIT370 accepts a one character PARM=x specification, which specifies
increasing levels of diagnostic verbosity.  The current definitions of
"x" are:

        0       normal messages (default if no PARM specified)
        1       status messages, primarily CSECT entry and exit messages
        2       internal CSECT status messages
        3+      dump debug areas, can be lots of data for large input datasets

For more exotic debugging, review the UTILDBUG source code and see the
JDEBUG job, which points XMITDBUG at SYS2.XMIT370.ASM(KDEBUG).


That's it.  Good luck and enjoy!

Jim Morrison     jmorrison@ameritech.net
                 jmm@ensose.com

./ ADD NAME=$NOTES   0100-02182-02182-0701-00057-00057-00000-XMIT370

During testing, I tried to receive the created XMIT files on as
many different environments as possible.  Special thanks to those
kind souls who helped test various MVS environents.


Hercules 2.16.2 dasdload
------------------------

works fine, with and without modification to COPYR1 record


RECV390 v1r1m5 (not released, I'm still working on it)
--------------

works fine, with and without modification to COPYR1 record


MVS38j RECV370
--------------

JINSTALL - install XMIT370 & RECV370
JXMIT    - create XMIT without modifying COPYR1 record
JXMITC   - create XMIT with COPYR1 modification
JRECV    - receive XMIT files created above

works fine, with or without modifications to COPYR1 record


MVS/ESA TSO/E RECEIVE
---------------------

Interesting behavior demonstrated by IEBCOPY, which complains that
the COPYR1 length is invalid.  The COPYR1 that IEBCOPY displays
looks nothing like the COPYR1 in the XMIT, which I verified by
running RECV370 which spins out a SYSUT1 file that I Full-Screen
Zapped.  An intended side-effect of running RECV370 is that it
simply unwraps the XMIT and places it on the SYSUT1 ddname.  That
it actually calls IEBCOPY is merely a happy coincidence.  ;-) What is
causing this behavior, I can't exactly say at this point and time.
I have a mild suspicion that there's a problem with the segments:
either a key that RECEIVE doesn't understand, or possibly a
construction error.  Unfortunately, I had very limited time on this
system, so it is as yet undetermined.  However, as time becomes
available, I'll keep pluggin away at it.  If someone has spare cycles
on an Internet-connected MVS/ESA system I can use to further test,
I'd be very happy to hear from you (jmorrison@ameritech.net).

I'd like all of XMIT370's XMITs to RECEIVE properly under MVS/ESA,
but as of right now that's not the case.  If your version of IEBCOPY
can cope with MVS38j IEBCOPY's COPYR1 record, you're golden.

To the extent that RECV370 works, it acts as a decent substitute
for TSO/E RECEIVE on MVS/ESA so all is not lost.  The very same XMIT
that TSO/E RECEIVE/IEBCOPY complained about received fine with RECV370.
I'm sure that's a clue of some kind.

./ ADD NAME=$README  0100-02182-02182-0701-00027-00027-00000-XMIT370

Copyright 2001, 2002 James M. Morrison

Welcome to XMIT370 v0004

For an introduction to XMIT370, see the $INTRO   member.
For the copyright claims,       see the $COPY    member.
For the change log,             see the $CHANGES member.
For miscellaneous notes,        see the $NOTES   member.

Member Naming Conventions
-----------------------------------------------------------------------

MEMBER   Contents

$....... Commentary
D....... DSECT macros
IM#..... inner macros
J....... JCL
K....... Control cards
LICENSE  Q Public License version 1.0, modified to fit LRECL=80
RECV.... RECV370 CSECTs (incomplete, may not be present)
UTIL.... Utility CSECTs
U....... Utility macros
WA...... Work Areas DSECT macros
XMIT.... XMIT370 CSECTs

./ ADD NAME=@FILE571 0101-01025-02182-0715-00018-00002-00000-SBGOLOB
//***FILE 571 is from Jim Morrison, and contains XMIT370 and        *   FILE 571
//*           RECV370.  These are tools to create and handle        *   FILE 571
//*           XMIT-format pds files (which are FB-80 sequential     *   FILE 571
//*           files) on MVS systems (such as MVS 3.8) which do      *   FILE 571
//*           not contain the TSO XMIT and RECEIVE commands.        *   FILE 571
//*                                                                 *   FILE 571
//*           XMIT and RECEIVE were first shipped with TSO/E,       *   FILE 571
//*           so any pre-TSO/E TSO releases, probably do not have   *   FILE 571
//*           the XMIT and RECEIVE capabilities.                    *   FILE 571
//*                                                                 *   FILE 571
//*           These tools are batch programs, and are not TSO       *   FILE 571
//*           commands, as are the TSO/E XMIT and RECEIVE programs. *   FILE 571
//*                                                                 *   FILE 571
//*           These programs were created so that Hercules MVS 3.8  *   FILE 571
//*           users, can handle XMIT-format sequentialized pds'es.  *   FILE 571
//*                                                                 *   FILE 571
//*         email:  Jim Morrison <jmorrison@ameritech.net>          *   FILE 571
//*                                                                 *   FILE 571
./ ADD NAME=DCOPYR1  0100-02182-02182-0701-00063-00063-00000-XMIT370
         MACRO
         DCOPYR1 &BDW=NO,&RDW=NO
.*
.* Copyright 2001, 2002 James M. Morrison
.*
.* See MVS38j IEBLDUL source for COPYR1 definition (PL/S).
.*
*----------------------------------------------------------------------
*  IEBCOPY unloaded dataset; COPYR1 record
*----------------------------------------------------------------------
COPYR1   DSECT ,                       WORD aligned
         AIF   ('&BDW' EQ 'NO').NOBDW
XC1BDW   DS    XL4                 block descriptor word
.NOBDW   AIF   ('&RDW' EQ 'NO').NORDW
XC1RDW   DS    XL4                 record descriptor word
.NORDW   ANOP
*
XC1INDC  DS    XL1                 flags
XC1IFMT  EQU   X'C0'               unload info mask
XC1IUERR EQU   X'80'               unload error
XC1IFOLD EQU   X'00'               unload format=old
XC1IFPDE EQU   X'40'               unload format=PDS/E
XC1IFXFR EQU   X'C0'               unload format=transfer
XC1IFPGM EQU   X'10'               contains program
XC1IFCPE EQU   X'01'               contains PDS/E
*
XC1ID    DS    XL3                 header id x'CA6D0F'
XC1DSORG DS    XL2                 DSORG
XC1BLKSZ DS    XL2                 BLKSIZE
XC1LRECL DS    XL2                 LRECL
XC1RECFM DS    XL1                 RECFM
XC1KEYLN DS    XL1                 KEY length
XC1OPTCD DS    XL1                 OPTCD
XC1SMSFG DS    XL1                 reserved in MVS38j
XC1TBLKS DS    XL2                 unloaded blksize
*
*  Devicetype info
*
XC1DEVT  DS    0XL20
XC1UCBT  DS    XL4                 UCB.UCBTYP
XC1UMBLK DS    XL4                 unit max blksize
XC1UCYLS DS    XL2                 unit # cyls
XC1UHEAD DS    XL2                 unit # trks/cyl
XC1UTRKL DS    XL2                 unit track length
XC1UBOVH DS    XL2                 unit block overhead
XC1UKOVH DS    XL1                 unit keyed blk ovhd
XC1UFLGS DS    XL1                 flags
XC1UTOLF DS    XL2                 unit tolerance factor
*
*  Following fields reserved in MVS38j
*
XC138RSV DS    0XL16
L$XC138  EQU   (*+16)-COPYR1
XC1HDRCT DS    XL2                 header count; when 0, =2.
XC1RESV1 DS    XL1                 reserved
XC1LREFD DS    XL3                 last referenced date
XC1SCEXT DS    XL3                 secondary extent
XC1SCALO DS    XL4                 secondary allocation
XC1LSTAR DS    XL3                 last used trk/rec
XC1TRBAL DS    XL2                 track balance
XC1RESV2 DS    XL2                 reserved
L$XC1CUR EQU   *-COPYR1            currently known length
         MEND
./ ADD NAME=DRCS2    0100-02182-02182-0701-00036-00036-00000-XMIT370
         MACRO
         DRCS2 ,
.*
.* Copyright 2001, 2002 James M. Morrison
.*
*----------------------------------------------------------------------
*  Control Segment INMR02 saved data
*----------------------------------------------------------------------
CS2      DSECT ,
CS2#FILE DS    F             # files in XMIT file
*
*  This area is based on the assumption that all CLVH values are
*  four bytes or less.  They don't really have to be, I've just not
*  seen them larger than that.  Like most assumptions, this will
*  likely cause problems down the road. <sigh>
*
*  The field names correspond to keys named INM rather than CS2.
*
CS2BLKSZ DS    F
CS2CREAT DS    F
CS2DIR   DS    F
CS2DSORG DS    F
CS2EXPDT DS    F
CS2FFM   DS    F
CS2LCHG  DS    F
CS2LRECL DS    F
CS2LREF  DS    F
CS2MEMBR DS    CL8
CS2RECFM DS    F
CS2SIZE  DS    F
CS2TERM  DS    C
         DS    CL7
CS2UTILN DS    CL8
         DS    0D
L$CS2    EQU   *-CS2
         MEND
./ ADD NAME=DVTAB    0100-02182-02182-0701-00021-00021-00000-XMIT370
         MACRO
         DVTAB ,
.*
.* Copyright 2001, 2002 James M. Morrison
.*
VTABLE   DSECT ,
*----------------------------------------------------------------------
*  CSECT table header - BXLE index, increment, limit
*----------------------------------------------------------------------
VTHDR    DS    0F,XL12
         ORG   VTABLE
*----------------------------------------------------------------------
*  CSECT table
*----------------------------------------------------------------------
VTABNAME DS    CL8           CSECT name
VTABVCON DS    A             address of CSECT
VTABOFF  DS    H             offset to debug byte from XMTDLEV
VTABRSV1 DS    H             unused/alignment
L$VTAB   EQU   *-VTABLE      length of table entry
         ORG   ,
         MEND
./ ADD NAME=DXMITSEG 0100-02182-02182-0701-00095-00095-00000-XMIT370
         MACRO
         DXMITSEG &SECT=DSECT
.*
.* Copyright 2001, 2002 James M. Morrison
.*
*----------------------------------------------------------------------
*  XMIT segment
*----------------------------------------------------------------------
XMITSEG  IM#SECT &SECT                 XMIT SEGment
SEG      DS    0XL255                  maximum segment length
SEGL     DS    X                       length of segment (2 -255),
*                                      including L'XPSEGL & L'XPSEGFLG
SEGFLG   DS    X                       flag byte
SEG$1    EQU   128                     first segment of original rec
SEG$L    EQU   64                      last segment of original rec
SEG$C    EQU   32                      (part of) control segment
SEG$R    EQU   16                      rec # of next record
SEG$XX   EQU   15                      reserved bits = 0
*
SEGBUF   DS    XL253                   maximum segment user data
*
*  Offsets for control segments
*
SEGCTLNM EQU   SEGBUF,6                c'INMR0x'
SEGCKEYS EQU   SEGBUF+6                INMR0x beginning of keys
SEGC2NUM EQU   SEGBUF+6,4              INMR02 # files
SEGC2KEY EQU   SEGBUF+10               INMR02 keys begin here
*
SEGBND   EQU   *                       past end of segment data
*
*  Keys for network user identification (INMR01)
*
INMTNODE EQU   X'1001'       target node name
INMTUID  EQU   X'1002'       target userid
INMFNODE EQU   X'1011'       origin node name
INMFUID  EQU   X'1012'       origin userid
INMFVERS EQU   X'1023'       origin version number
INMFTIME EQU   X'1024'       origin time stamp
INMTTIME EQU   X'1025'       destination time stamp
INMNUMF  EQU   X'102F'       number of files
*
* Keys for general use
*
INMFACK  EQU   X'1026'       acknowledgement request
INMERRCD EQU   X'1027'       receive error code
INMUTILN EQU   X'1028'       utility name
INMUSERP EQU   X'1029'       user parm string
INMRECCT EQU   X'102A'       transmitted record count
*
*  Keys for dataset specification
*
INMDDNAM EQU   X'0001'       DDNAME
INMDSNAM EQU   X'0002'       DSN
INMMEMBR EQU   X'0003'       member name
INMSECND EQU   X'000B'       secondary space qty
INMDIR   EQU   X'000C'       directory space qty
INMEXPDT EQU   X'0022'       expiration date
INMTERM  EQU   X'0028'       terminal alloc (msg)
INMBLKSZ EQU   X'0030'       blocksize
INMDSORG EQU   X'003C'       dsorg
INMLRECL EQU   X'0042'       lrecl of physical segment records
INMRECFM EQU   X'0049'       recfm
INMLREF  EQU   X'1020'       last ref date
INMLCHG  EQU   X'1021'       last chg date
INMCREAT EQU   X'1022'       create date
INMSIZE  EQU   X'102C'       primary space qty
INMTYPE  EQU   X'8012'       data set type
*
*  I'm not sure about the spelling of the next field, so I specify both
*
INMFFM   EQU   X'102D'       Filemode number (CMS)
INMFM    EQU   X'102D'       Filemode number (CMS)
*
L$SEG    EQU   *-XMITSEG     L'XMITSEG
*
L$CKEY   EQU   2                       length of control seg key
L$CCOUNT EQU   2                       length of control seg count
L$CLEN   EQU   2                       length of control seg length
.*
.*  Format of key data:
.*
.*  KEY     XL2   as above
.*  LENGTH  XL2   length of following data
.*  BINDATA XLn
.*
.*  KEY     XL2   as above
.*  LENGTH  XL2   length of following data (flag, as in terminal alloc)
.*
.*  KEY     XL2      Dataset type field, dsname
.*  COUNT   XL2
.*  LENGTH  XL2
.*  DATA    XLn
.*  LENGTH  XL2
.*  DATA    XL2, etc.
         MEND
./ ADD NAME=HERC     0100-02182-02182-0701-00054-00054-00000-XMIT370
         MACRO
&LABEL   HERC   &DIAG,&OPT
.*
.* Copyright 2001, 2002 James M. Morrison
.*
.*---------------------------------------------------------------------
.* Function: Issue Diagnose code to Hercules emulator
.*           See Hercules diagnose.c source code
.* &DIAG   - Hercules diagnose code
.* &OPT    - Options, for diagnose instructions that support it
.*---------------------------------------------------------------------
         GBLB  &G#HERC
         AIF   (&G#HERC).GEN
         MNOTE 2,'HERC macro detected lack of Hercules support'
         MNOTE *,'HERC macro expansion suppressed'
         MEXIT
.*
.GEN     AIF   (N'&OPT EQ 4).FOUR
         AIF   (N'&OPT EQ 3).THREE
         AIF   (N'&OPT EQ 2).TWO
         AIF   (N'&OPT EQ 1).ONE
         AIF   (N'&OPT EQ 0).NONE
         MNOTE 2,'HERC macro OPT parse error'
         MEXIT
.*
.*       X'83-ab-cc-dd'
.*
.FOUR    ANOP
&LABEL   DC    AL1(131),A.4(&OPT(1),&OPT(2)),AL1(&OPT(3),&DIAG)    HERC
         MEXIT
.*
.*       X'83-ab-cc-dd'
.*
.THREE   ANOP
&LABEL   DC    AL1(131),A.4(&OPT(1),&OPT(2)),AL1(&OPT(3),&DIAG)    HERC
         MEXIT
.*
.*       X'83-aa-dddd'
.*
.ONE     ANOP
&LABEL   DC    AL1(131,&OPT),AL2(&DIAG)               HERCules diagnose
         MEXIT
.*
.*       X'83-ab-dddd'
.*
.TWO     ANOP
&LABEL   DC    AL1(131),AL1.4(&OPT(1),&OPT(2)),AL2(&DIAG) HERC diagnose
         MEXIT
.*
.*       X'83-00-dddd'
.*
.NONE    ANOP
&LABEL   DC    AL1(131,0),AL2(&DIAG)                  Hercules DIAGNOSE
         MEND
./ ADD NAME=IHADECB  0100-02182-02182-0701-00389-00389-00000-XMIT370
         MACRO
         IHADECB &DSECT=YES
         AIF   ('&DSECT' EQ 'NO').NODSCT
DECB     DSECT , -            DECBPTR
         AGO   .CONT
.NODSCT  ANOP
         DS    0D
DECB     EQU   * -            DECBPTR
.CONT    ANOP  ,  */
*%DECBL1 : ;
*
*/* **************************************************************** */
*/*            DATA EVENT CONTROL BLOCKS FOR -                       */
*/*            BSAM, BISAM, BDAM, QTAM, BTAM                         */
*/*                                                                  */
*/*  OS/VS2 RELEASE 3, OS/VS1 RELEASE 4, 08/30/74, LEVEL=1           */
*/*                                                                  */
*/*  METHOD OF ACCESS                                                */
*/*      BAL  - DSECT IS PRODUCED UNLESS DSECT=NO IS SPECIFIED.      */
*/*             USING ON DECB GIVES ADDRESSABILITY FOR ALL SYMBOLS.  */
*/*      PL/S - DCL DECBPT PTR                                       */
*/* **************************************************************** */
*%GOTO DECBL2;  /*
         SPACE 1
         IEZBITS , -          SYMBOLIC BIT DEFINITIONS
         SPACE 1
***********************************************************************
*              DATA EVENT CONTROL BLOCK FOR BSAM                      *
***********************************************************************
         SPACE 1
DECSDECB DS    CL4 -          EVENT CONTROL BLOCK
DECBPTR  DS    0A -           FOR IBM 1419 MAGNETIC CHARACTER READER
*                             AND IBM 1275 OPTICAL READER SORTER, A
*                             POINTER TO NEXT DECB TO BE TESTED FOR
*                             COMPLETION BY THE CHECK MACRO
*                             INSTRUCTION.  (DECB CHAINING APPLIES TO
*                             THE USE OF MORE THAN ONE DEVICE.)  THIS
*                             FIELD IN THE LAST DECB MUST BE ZERO.
DECTYPE  DS    0BL2 -         TYPE OF I/O REQUEST
DECTYPE1 DS    B -            TYPE OF LENGTH OPERAND
DECLNS   EQU   BIT0 -         S CODED FOR LENGTH
DECRSV01 EQU   BIT1,,C'X' -   RESERVED
DECRSV02 EQU   BIT2,,C'X' -   RESERVED
DECRSV03 EQU   BIT3,,C'X' -   RESERVED
DECRSV04 EQU   BIT4,,C'X' -   RESERVED
DECRSV05 EQU   BIT5,,C'X' -   RESERVED
DECRSV06 EQU   BIT6,,C'X' -   RESERVED
DECRSV07 EQU   BIT7,,C'X' -   RESERVED
DECTYPE2 DS    B -            TYPE OF OPERATION
DECRDSF  EQU   BIT0 -         READ SF
DECRDSB  EQU   BIT1 -         READ SB
DECWRSF  EQU   BIT2 -         WRITE SF
DECWRSD  EQU   BIT3 -         WRITE SD
DECRSV08 EQU   BIT4,,C'X' -   RESERVED
DECWRSZ  EQU   BIT5 -         WRITE SZ
DECRSV09 EQU   BIT6,,C'X' -   RESERVED
DECWRSFR EQU   BIT7 -         WRITE SFR (BIT 2 IS ALSO ON) OR
*                             READ RBL (BIT 0 IS ALSO ON)        MDC004
DECLNGTH DS    H -            LENGTH OF KEY AND DATA
DECDCBAD DS    A -            ADDRESS OF THE DCB TO WHICH THIS I/O
*                             REQUEST IS RELATED
DECAREA  DS    A -            ADDRESS OF KEY AND DATA, OR FOR 1287 OR
*                             1288 OPTICAL READERS, THE ADDRESS OF A
*                             USER-SPECIFIED CHANNEL PROGRAM
DECIOBPT DS    A -            ADDRESS OF THE IOB
DECNEXT  DS    0A -           SAME AS DECNEXTA BELOW
DECRSV10 DS    X -            RESERVED
DECNEXTA DS    AL3 -          ADDRESS OF THE NEXT ADDRESS FEEDBACK
*                             FIELD.  PRESENT ONLY IF R IS CODED IN
*                             THE WRITE MACRO.
         SPACE 2
         ORG   DECNEXT -      FOR 3886 ONLY, DEVICE DEPENDENT FIELDS
DECBHDRA DS    A -            FOR READ RBL, ADDRESS OF 3886 DATA
*                             HEADER RECORD AFTER READ           MDC001
DECBLNNM DS    A -            FOR READ RBL, ADDRESS OF LINE NUMBER OR
*                             NEGATIVE OF LINE NUMBER            MDC002
DECBLFMT DS    A -            FOR READ RBL, ADDRESS OF LINE FORMAT
*                             NUMBER OR NEGATIVE OF LINE FORMAT
*                             NUMBER                             MDC003
         SPACE 2
***********************************************************************
*              DATA EVENT CONTROL BLOCK FOR BISAM                     *
***********************************************************************
         SPACE 1
         ORG   DECB
DECBECB  DS    0CL4 -         EVENT CONTROL BLOCK
DECBRB   DS    0A -           SAME AS DECBRBA BELOW
DECBECBF DS    B -            FLAG FIELD
DECBWAIT EQU   BIT0 -         AWAITING COMPLETION OF EVENT
DECBPOST EQU   BIT1 -         EVENT HAS COMPLETED NORMALLY OR
*                             ABNORMALLY.  IF THE EVENT COMPLETED
*                             ABNORMALLY, FIELDS DECBEXC1 AND DECBEXC2
*                             WILL SHOW THE REASON.
DECRSV11 EQU   BIT2,,C'X' -   RESERVED
DECRSV12 EQU   BIT3,,C'X' -   RESERVED
DECRSV13 EQU   BIT4,,C'X' -   RESERVED
DECRSV14 EQU   BIT5,,C'X' -   RESERVED
DECRSV15 EQU   BIT6,,C'X' -   RESERVED
DECRSV16 EQU   BIT7,,C'X' -   RESERVED
DECBRBA  DS    AL3 -          ADDRESS OF THE RB FOR THE PROGRAM
*                             AWAITING EVENT (BEFORE EVENT COMPLETION)
*                             OR RESERVED (AFTER EVENT COMPLETION)
DECBTYP1 DS    B -            OPTION BYTE
DECRSV17 EQU   BIT0,,C'X' -   RESERVED
DECRSV18 EQU   BIT1,,C'X' -   RESERVED
DECRSV19 EQU   BIT2,,C'X' -   RESERVED
DECRSV20 EQU   BIT3,,C'X' -   RESERVED
DECRSV21 EQU   BIT4,,C'X' -   RESERVED
DECRSV22 EQU   BIT5,,C'X' -   RESERVED
DECBLNS  EQU   BIT6 -         LENGTH CODED AS 'S'
DECBARS  EQU   BIT7 -         AREA CODED AS 'S'
DECBTYP2 DS    B -            TYPE OF I/O REQUEST
DECBRDK  EQU   BIT0 -         READ K
DECRSV23 EQU   BIT1,,C'X' -   RESERVED
DECBRDKU EQU   BIT2 -         READ KU
DECRSV24 EQU   BIT3,,C'X' -   RESERVED
DECBWRK  EQU   BIT4 -         WRITE K
DECBWRKN EQU   BIT5 -         WRITE KN
DECRSV25 EQU   BIT6,,C'X' -   RESERVED
DECRSV26 EQU   BIT7,,C'X' -   RESERVED
DECBLGTH DS    H -            NUMBER OF BYTES READ OR WRITTEN
DECBDCBA DS    A -            ADDRESS OF THE DATA CONTROL BLOCK
DECBAREA DS    A -            ADDRESS OF THE AREA IN STORAGE FOR THE
*                             RECORD
DECBLOGR DS    A -            ADDRESS OF THE LOGICAL RECORD
DECBKEY  DS    A -            ADDRESS OF THE KEY PORTION OF THE RECORD
DECBEXC1 DS    B -            EXCEPTIONAL CONDITION CODE BYTE 1
DECEXRNF EQU   BIT0 -         RECORD NOT FOUND
DECEXRLC EQU   BIT1 -         RECORD LENGTH CHECK
DECEXNSP EQU   BIT2 -         SPACE NOT FOUND IN WHICH TO ADD A RECORD
DECEXINV EQU   BIT3 -         INVALID REQUEST
DECEXERR EQU   BIT4 -         UNCORRECTABLE I/O ERROR
DECEXUBK EQU   BIT5 -         UNREACHABLE BLOCK
DECEXOFL EQU   BIT6 -         OVERFLOW RECORD
DECEXDUP EQU   BIT7 -         DUPLICATE RECORD PRESENTED FOR INCLUSION
*                             IN THE DATA SET
DECBEXC2 DS    B -            EXCEPTIONAL CONDITION CODE BYTE 2
DECRSV27 EQU   BIT0,,C'X' -   RESERVED
DECRSV28 EQU   BIT1,,C'X' -   RESERVED
DECRSV29 EQU   BIT2,,C'X' -   RESERVED
DECRSV30 EQU   BIT3,,C'X' -   RESERVED
DECRSV31 EQU   BIT4,,C'X' -   RESERVED
DECRSV32 EQU   BIT5,,C'X' -   RESERVED
DECEXASR EQU   BIT6 -         EXECUTION OF THE LAST CHANNEL PROGRAM WAS
*                             INSTITUTED BY AN ASYNCHRONOUS ROUTINE
DECEXRKU EQU   BIT7 -         PREVIOUS MACRO INSTRUCTION WAS READ KU
         SPACE 2
***********************************************************************
*              DATA EVENT CONTROL BLOCK FOR BDAM                      *
***********************************************************************
         SPACE 1
         ORG   DECB
         DS    0CL4 -         DECSDECB - EVENT CONTROL BLOCK
         DS    B -            COMPLETION CODE BYTE 1
DECCC2   DS    B -            COMPLETION CODE BYTE 2
DECCCRNF EQU   BIT0 -         RECORD NOT FOUND
DECCCRLC EQU   BIT1 -         RECORD LENGTH CHECK
DECCCNSP EQU   BIT2 -         SPACE NOT FOUND
DECCCINV EQU   BIT3 -         INVALID REQUEST.  (THIS CONDITION ALSO
*                             SETS A BIT IN THE NEXT BYTE.)
DECCCERR EQU   BIT4 -         UNCORRECTABLE I/O ERROR
DECCCEOD EQU   BIT5 -         END OF DATA
DECCCUER EQU   BIT6 -         UNCORRECTABLE ERROR OTHER THAN AN I/O
*                             ERROR
DECCCREX EQU   BIT7 -         A WRITE WITH EXCLUSIVE CONTROL WAS NOT
*                             PRECEDED BY A READ WITH EXCLUSIVE CONTROL
*                             (MDC300)                         @Z30AQ9A
DECCC3   DS    B -            COMPLETION CODE BYTE 3
DECRSV33 EQU   BIT0,,C'X' -   RESERVED
DECCCWRI EQU   BIT1 -         A WRITE MACRO INSTRUCTION WAS ADDRESSED
*                             TO AN INPUT DATA SET
DECCCEXS EQU   BIT2 -         AN EXTENDED SEARCH WAS SPECIFIED WITH THE
*                             DCBLIMCT FIELD SET TO ZERO
DECCCNBK EQU   BIT3 -         THE BLOCK REQUESTED IS NOT WITHIN THE
*                             DATA SET
DECCCWDI EQU   BIT4 -         A WRITE-BY-IDENTIFICATION (DI) ADDRESSED
*                             RECORD ZERO
DECCCSDK EQU   BIT5 -         A SEARCH-ON-KEY (DK) WAS SPECIFIED WITH
*                             THE DCBKEYLE FIELD SET TO ZERO OR WITHOUT
*                             AN ADDRESS FOR THE KEY
DECCCOPT EQU   BIT6 -         A MACRO INSTRUCTION USED AN OPTION NOT
*                             SET IN THE DCB
DECCCKFF EQU   BIT7 -         THE KEY FOR THE FIXED-LENGTH RECORD TO BE
*                             ADDED BEGINS WITH X'FF'
DECRSV34 DS    X -            RESERVED
         DS    0BL2 -         DECTYPE - TYPE OF I/O REQUEST
         DS    B -            DECTYPE1 - FIRST BYTE OF DECTYPE
DECVERFY EQU   BIT0 -         VERIFY
DECOFLOW EQU   BIT1 -         OVERFLOW
DECEXSRC EQU   BIT2 -         EXTENDED SEARCH
DECFDBCK EQU   BIT3 -         FEEDBACK
DECACTAD EQU   BIT4 -         ACTUAL ADDRESSING
DECDYNBF EQU   BIT5 -         DYNAMIC BUFFERING
DECRDEX  EQU   BIT6 -         READ EXCLUSIVE
DECRELBA EQU   BIT7 -         RELATIVE BLOCK ADDRESSING
         DS    B -            DECTYPE2 - SECOND BYTE OF DECTYPE
DECKEYS  EQU   BIT0 -         S CODED FOR KEY ADDRESS
DECBKLNS EQU   BIT1 -         S CODED FOR BLOCK LENGTH
DECTYPRU EQU   BIT2+BIT3 -    RU IS SUFFIXED TO THE TYPE, INDICATING
*                             THAT THE FEEDBACK ADDRESS POINTED TO BY
*                             DECNXADR CAN BE THE ADDRESS OF EITHER THE
*                             NEXT DATA RECORD OR THE NEXT CAPACITY
*                             RECORD, WHICHEVER OCCURS FIRST
DECTYPR  EQU   BIT3 -         R IS SUFFIXED TO THE TYPE, INDICATING
*                             THAT THE FEEDBACK ADDRESS POINTED TO BY
*                             DECNXADR IS THE ADDRESS OF THE NEXT DATA
*                             RECORD.  (BIT 2 IS ZERO)
DECOPRD  EQU   BIT4 -         TYPE OF OPERATION - 0 IS WRITE, 1 IS READ
DECSRKEY EQU   BIT5 -         TYPE OF SEARCH ARGUMENT - 0 IS ID,
*                             1 IS KEY
DECWRADD EQU   BIT6 -         ADD OPTION OF WRITE OPERATION
DECRSV35 EQU   BIT7,,C'X' -   RESERVED
         DS    H -            DECLNGTH - LENGTH OF DATA
         DS    A -            DECDCBAD - ADDRESS OF DCB TO WHICH THIS
*                             I/O REQUEST IS RELATED
         DS    A -            DECAREA - ADDRESS OF THE DATA
         DS    A -            DECIOBPT - ADDRESS OF THE IOB
DECKYADR DS    A -            ADDRESS OF THE KEY
DECRECPT DS    A -            ADDRESS OF THE BLOCK REFERENCE FIELD
DECNA    DS    0A -           SAME AS DECNAA BELOW
DECRSV36 DS    X -            RESERVED
DECNAA   DS    AL3 -          ADDRESS OF THE NEXT ADDRESS FEEDBACK
*                             FIELD.  PRESENT ONLY IF R OR RU IS CODED
*                             IN THE READ MACRO.
         SPACE 2
***********************************************************************
*              DATA EVENT CONTROL BLOCK FOR QTAM                      *
***********************************************************************
         SPACE 1
         ORG   DECB
LINEDECB DS    CL4 -          ALWAYS ZERO
DECRSV37 DS    X -            RESERVED
DECOPCOD DS    C -            OPERATION CODE FOR CURRENT SEGMENT
         DS    H -            DECLNGTH - LENGTH OF INPUT AREA FOR
*                             INITIAL READ
         DS    A -            DECDCBAD - ADDRESS OF DCB
         DS    A -            DECAREA - STARTING ADDRESS FOR DATA IN A
*                             BUFFER
DECRSV38 DS    XL4 -          RESERVED
DECCPOL  DS    0A -           SAME AS DECCPOLA BELOW
DECNMMSG DS    FL1 -          NUMBER OF MESSAGES RECEIVED
DECCPOLA DS    AL3 -          ADDRESS OF CURRENTLY ACTIVE ENTRY IN
*                             POLLING LIST
DECRSV39 DS    X -            RESERVED
DECUCBDX DS    FL1 -          INDEX TO UCB ADDRESS IN DEB
DECRSV40 DS    XL2 -          RESERVED
DECRSV41 DS    XL4 -          RESERVED
DECADRCH DS    A -            ADDRESS OF ADDRESSING CHARACTERS IN
*                             TERMINAL ENTRY
         DS    0A -           DECPOLPT - ADDRESS OF POLLING LIST
DECRSV42 DS    X -            RESERVED
         DS    AL3 -          DECPOLPA - ADDRESS OF POLLING LIST
         SPACE 2
***********************************************************************
*              DATA EVENT CONTROL BLOCK FOR BTAM                      *
***********************************************************************
         SPACE 1
         ORG   DECB
         DS    CL4 -          DECSDECB - EVENT CONTROL BLOCK
         DS    0BL2 -         DECTYPE - PROGRAMMING INDICATORS
         DS    B -            DECTYPE1 - FIRST BYTE OF DECTYPE
DECRDAPL EQU   BIT0 -         READ, USING AUTOPOLL
DECRSV43 EQU   BIT1,,C'X' -   RESERVED
DECRSV44 EQU   BIT2,,C'X' -   RESERVED
DECRSV45 EQU   BIT3,,C'X' -   RESERVED
DECRSV46 EQU   BIT4,,C'X' -   RESERVED
DECSTRME EQU   BIT5 -         'S' CODED FOR TERMINAL ENTRY
DECSAREA EQU   BIT6 -         'S' CODED FOR AREA
DECSLNTH EQU   BIT7 -         'S' CODED FOR LENGTH
         DS    C -            DECTYPE2 - COMMAND CODE
         DS    H -            DECLNGTH - LENGTH OF BUFFER OR MESSAGE
*                             AREA
         DS    0A -           DECDCBAD - ADDRESS OF ASSOCIATED DCB
DECBUFCT DS    0FL1 -         CONTAINS A RUNNING COUNT OF BUFFERS
*                             OBTAINED BY BTAM FOR THE CURRENT READ
*                             OPERATION.  (DYNAMIC BUFFERING ONLY.)
*                             USE DIFFERS DURING BSC AND 2760 ONLINE
*                             TEST.
DECONLTT DS    B -            FLAG BYTE FOR BSC AND 2760 ONLINE TEST
DECONLTS EQU   BIT0 -         IF ZERO, ONLINE TEST REQUESTED BY RFT
*                             MESSAGE (BSC).  IF ONE, ONLINE TEST
*                             INITIATED BY ONLTST MACRO INSTRUCTION
*                             (BSC).
DECRCVMS EQU   BIT1 -         IF ZERO, SENDING TEST MESSAGES (BSC).
*                             IF ONE, RECEIVING TEST MESSAGES (BSC) OR
*                             TYPE 11 ONLINE TEST FOR 2760 OPTICAL
*                             IMAGE UNIT.
DECRSV47 EQU   BIT2,,C'X' -   RESERVED
DECRSV48 EQU   BIT3,,C'X' -   RESERVED
DECRSV49 EQU   BIT4,,C'X' -   RESERVED
DECRSV50 EQU   BIT5,,C'X' -   RESERVED
DECRSV51 EQU   BIT6,,C'X' -   RESERVED
DECRSV52 EQU   BIT7,,C'X' -   RESERVED
DECDCBAA DS    AL3 -          ADDRESS OF ASSOCIATED DCB
         DS    A -            DECAREA - ADDRESS OF BUFFER OR MESSAGE
*                             AREA
DECSENS0 DS    B -            SENSE INFORMATION
DECSENS1 DS    B -            RESERVED
DECCOUNT DS    H -            RESIDUAL COUNT FROM CSW FOR LAST CCW
*                             EXECUTED
DECENTRY DS    0A -           ADDRESS OF THE TERMINAL LIST
DECCMCOD DS    C -            COMMAND FOR WHICH THE ERROR OCCURRED
DECENTRA DS    AL3 -          ADDRESS OF THE TERMINAL LIST
DECFLAGS DS    B -            OPERATION STATUS
DECWACK  EQU   BIT0+BIT1 -    WACK WAS RECEIVED (BSC)
DECERRMS EQU   BIT0 -         ERROR STATUS MESSAGE WAS RECEIVED (BSC).
*                             BIT 1 IS OFF.
DECDIFAC EQU   BIT1 -         ACKNOWLEDGMENT OTHER THAN ACK-0 OR ACK-1
*                             RECEIVED (BSC)
DECALTAC EQU   BIT2 -         ACKNOWLEDGMENT ALTERNATION INCORRECT
DECBADID EQU   BIT3 -         FOR TWX 33/35 STATION AND BSC STATION,
*                             INCORRECT ID RECEIVED.  FOR AUTOPOLL,
*                             INDEX BYTE RECEIVED DOES NOT MATCH AN
*                             ACTIVE ONE.  FOR BSC NONSWITCHED
*                             POINT-TO-POINT LINE, CONTENTION OCCURRED.
*                             FOR WTTA, CONTENTION OCCURRED OR
*                             INCORRECT ID RECEIVED.
DECNOBUF EQU   BIT4 -         FOR READ, DYNAMIC BUFFERING, NO BUFFER
*                             WAS AVAILABLE.  (MESSAGE LOST)
DECNEGRP EQU   BIT5 -         FOR OPENLST, POLLING, NEGATIVE RESPONSE
*                             TO POLLING RECEIVED.  FOR WRAPLST, ALL
*                             ENTRIES ARE INACTIVE.  FOR ADDRESSING,
*                             NEGATIVE RESPONSE TO ADDRESSING
*                             RECEIVED.  FOR WTTA, LAST MESSAGE
*                             RECEIVED ENDED WITH EOT OR TIME-OUT.
*                             FOR 2741, POWER IS OFF OR OTHER
*                             INTERVENTION REQUIRED CONDITION EXISTS.
DECREVRS EQU   BIT6 -         FOR WTTA, MESSAGE ENDED WITH WRU SIGNAL.
*                             FOR BSC STATIONS, REVERSE INTERRUPT (RVI)
*                             SEQUENCE WAS RECEIVED (SEE ALSO BIT 1).
*                             FOR 2741, WRITE OPERATION WAS ENDED BY
*                             TERMINAL INTERRUPT.
DECSSMSG EQU   BIT6 -         A 3270 REMOTE SENSE/STATUS MESSAGE WAS
*                             RECEIVED IF THIS BIT IS ONE AND BIT 1
*                             IS ZERO                            ICB479
DECSTXNQ EQU   BIT7 -         FOR WTTA, CONTENTION CONDITION WAS
*                             ENCOUNTERED.  FOR BSC STATIONS, STX ENQ
*                             SEQUENCE WAS RECEIVED.
DECRLN   DS    FL1 -          RELATIVE LINE NUMBER
DECRESPN DS    CL2 -          FOR BSC OPERATIONS, RESPONSE FROM A
*                             TERMINAL TO ADDRESSING.  FOR STOP-START
*                             OPERATIONS, BYTE 1 IS RESPONSE FROM A
*                             TERMINAL TO ADDRESSING AND BYTE 2 IS
*                             VERTICAL REDUNDANCY CHARACTER AND
*                             LONGITUDINAL REDUNDANCY CHARACTER
*                             (VRC/LRC) RESPONSE.
DECTPCOD DS    C -            TP OPERATION CODE
DECERRST DS    B -            I/O ERROR STATUS FLAGS
DECSIO3  EQU   BIT0 -         SIO RESULTED IN A CONDITION CODE OF 3
DECUNDEF EQU   BIT1 -         UNDEFINED ERROR CONDITION
DECERPER EQU   BIT2 -         AN ERROR CONDITION OCCURRED DURING AN I/O
*                             OPERATION INITIATED BY ERROR RECOVERY
*                             ROUTINES
DECDIAGN EQU   BIT3 -         DIAGNOSTIC WRITE/READ OPERATION ENDED
*                             BECAUSE OF ERROR (2701 ONLY)
DECDSABL EQU   BIT4 -         DISABLE COMMAND ISSUED TO SWITCHED LINE
*                             BY ERROR RECOVERY ROUTINE BECAUSE OF
*                             PERMANENT ERROR ON THAT LINE
DECRSV53 EQU   BIT5,,C'X' -   RESERVED
DECRSV54 EQU   BIT6,,C'X' -   RESERVED
DECRSV55 EQU   BIT7,,C'X' -   RESERVED
DECCSWST DS    BL2 -          STATUS BITS FROM CSW FOR LAST CCW
*                             EXECUTED
DECADRPT DS    A -            ADDRESS OF ADDRESSING LIST ENTRY USED IN
*                             PREVIOUS OPERATION
DECPOLPT DS    0A -           SAME AS DECPOLPA BELOW
DECNDXPL DS    FL1 -          FOR AUTOPOLL, INDEX TO CURRENT ENTRY IN
*                             POLLING LIST
DECPOLPA DS    AL3 -          FOR PROGRAMMED POLLING, ADDRESS OF THE
*                             CURRENT ENTRY IN THE POLLING LIST.  FOR
*                             AUTOPOLL, ADDRESS OF POLLING LIST.  FOR
*                             BSC ON-LINE TEST, ADDRESS OF TEXT DATA.
         SPACE 1
*              BSC EXTENSION
*        FIELDS ARE PRESENT ONLY IF A SUBLIST IS CODED FOR THE
*        AREA AND LENGTH OPERANDS OF THE READ OR WRITE MACRO
*        INSTRUCTION THAT DEFINES THE DECB.
         SPACE 1
DECRSV56 DS    XL2 -          RESERVED
DECWLNG  DS    H -            LENGTH, IN BYTES, OF THE DATA AREA IN
*                             LEADING-GRAPHICS AND CONVERSATIONAL TYPE
*                             OPERATIONS OR OF THE AREA CONTAINING THE
*                             TONE CHARACTERS IN READ CONNECT WITH TONE
*                             (TCW) OPERATIONS
DECWAREA DS    A -            ADDRESS OF THE DATA AREA IN
*                             LEADING-GRAPHICS AND CONVERSATIONAL
*                             OPERATIONS, OR OF THE AREA CONTAINING THE
*                             TONE CHARACTERS IN READ TCW OPERATIONS
         MEND  , */
./ ADD NAME=IHADVCT  0100-02182-02182-0701-00138-00138-00000-XMIT370
         MACRO
         IHADVCT   &DSECT=YES
.* /* START OF SPECIFICATIONS ****
.*
.*01  MODULE-NAME = IHADVCT
.*
.*01  COPYRIGHT = NONE
.*
.*01  STATUS = OS/VS2 RELEASE 2, LEVEL 0
.*
.*01  CHANGE-ACTIVITY = NONE
.*
.*01  DESCRIPTIVE-NAME = DEVICE CHARACTERISTICS TABLE MAPPING
.*
.*01  FUNCTION = THIS TABLE DESCRIBES PHYSICAL ATTRIBUTES OF EACH DASD
.*    DEVICE WHICH HAS BEEN SYSGENED
.*
.*01  NOTES = THE TABLE IS POINTED TO BY CVTZDTAB.
.*
.*01  MODULE-TYPE = MACRO
.*02    PROCESSOR = ASSEMBLER-370R
.*
.*02    MACRO-SIZE = 200 STATEMENTS
.*
.**** END OF SPECIFICATIONS ***/
* /* MACCOMP Y-2 SC1D0/SJD48                                         */
* /* MACSTAT Y-2 73226/021160                                        */
*/********************************************************************/
*/*                 DEVICE CHARACTERISTICS TABLE                     */
*/********************************************************************/
*/*                                                                  */
*/*         THIS TABLE MAY BE USED TO FIND THE CHARACTERISTICS       */
*/*         OF DIRECT ACCESS DEVICES.  THE APPLICABLE DEVICES ARE    */
*/*         THOSE CONTAINING UCBDACC IN UCBTBYT3 (SEE IEFUCBOB).     */
*/*                                                                  */
*/*         NOTE: DEVTYPE MAY BE USED TO EXTRACT INFORMATION         */
*/*         FROM THIS TABLE.  ITS OUTPUT AREA IS IN A SLIGHTLY       */
*/*         DIFFERENT FORMAT, AND IS MAPPED BY IHADVA.               */
*/*                                                                  */
*/*         THE TABLE IS COMPOSED OF AN INDEX FOLLOWED BY ONE        */
*/*         ENTRY FOR EACH DASD DEVICE WHICH HAS BEEN SYSGENED       */
*/*                                                                  */
*/*         FOR ASSEMBLER USE, TWO SEPARATE DSECTS ARE PROVIDED.     */
*/*         A USING ON DVCTI GIVES ADDRESSIBILITY TO THE INDEX,      */
*/*         AND A USING ON DVCT GIVES ADDRESSIBILITY TO AN ENTRY.    */
*/*         SPECIFYING DSECT=NO SUPPRESSES THE INDEX AND PROVIDES    */
*/*         AN ENTRY DESCRIPTION WITHOUT A DSECT STATEMENT           */
*/*                                                                  */
*/*         FOR PLS USE, TWO STRUCTURES ARE PROVIDED. THEIR STORAGE  */
*/*         ATTRIBUTES ARE CONTROLLED BY SETTING STRING MACRO        */
*/*         VARIABLES AS FOLLOWS:                                    */
*/*         STRUCTURE  MACRO-VAR       DEFAULT SETTING               */
*/*         DVCTI      %DVCIBASE  'BASED(CVTZDTAB)'                  */
*/*         DVCT       %DVCTBASE  'BASED(CVTZDTAB                    */
*/*                                +DVCTIOFF(UCBTYP&DVCTYPMK))'      */
*/*                                                                  */
*/*         THE DEFAULT SETTINGS WILL PROVIDE ADDRESSIBILITY TO      */
*/*         ALL FIELDS, BUT DEPEND ON CVT AND UCB ADDRESSIBILITY.    */
*/*                                                                  */
*/*               FORMAT OF EACH ENTRY                               */
*/*         _____________________________________________            */
*/*   0(00) |                     |                     |            */
*/*         |       DVCCYL        |       DVCTRK        |            */
*/*         |_____________________|_____________________|            */
*/*   4(04) |                     |       DVCOVHD       |            */
*/*         |       DVCTRKLN      | DVCOVNLB | DVCOVLB  |            */
*/*         |_____________________|__________|__________|            */
*/*   8(08) |          |          |                     |            */
*/*         | DVCOVNK  | DVCFLAGS |       DVCTOL        |            */
*/*         |__________|__________|_____________________|            */
*/*  12(0C) |                     |______________________            */
*/*         |       DVCALT        |                     |            */
*/*         |_____________________|       DVCOVR0       |  RPS       */
*/*         ______________________|_____________________|  ONLY      */
*/*  16(10) |          |          |                        SECTION   */
*/*         | DVCSECT  | DVCSECTD |                                  */
*/*         |__________|__________|                                  */
*/********************************************************************/
*%/*
         AIF   ('&DSECT' EQ 'NO').NODSECT
DVCTI    DSECT ,              INDEX TO DVCT
*              THIS INDEX IS LOCATED FROM CVTZDTAB.
*              THE PROPER ENTRY IS FOUND BY ADDING THE LOW ORDER
*              4 BITS OF UCBTYP TO THE ADDRESS IN CVTZDTAB.
DVCTYPMK EQU   X'0000000F'              TYPICAL USAGE:
*              LA    RWRK,DVCTYPMK      MASK FOR UNIT TYPE NUMBER
*              N     RWRK,UCBTYP        PICK UP UNIT TYPE NUMBER
*              IC    RWRK,DVCTIOFF(RWRK)  PICK UP OFFSET
DVCTIOFF DS    AL1                      OFFSET TO DVCT ENTRY
***********************************************************************
         SPACE 3
DVCT     DSECT ,                        FORMAT OF DVCT ENTRY
*              THE ENTRY IS LOCATED BY ADDING DVCTIOFF TO CVTZDTAB
         AGO   .ENTRY
.NODSECT ANOP
DVCT     DS    0H                       FORMAT OF DVCT ENTRY
.ENTRY   ANOP
*
DVCCYL   DS    H                        PHYS NO. CYL PER VOLUME
DVCTRK   DS    H                        NO. TRACKS PER CYLINDER
DVCTRKLN DS    H                        NO. OF BYTES PER TRACK
*
DVCOVHD  DS    0H                       BLOCK OVERHEAD IF DVC2BOV=1
*              USE FOLLOWING TWO CONSTANTS IF DVC2BOV=0
DVCOVNLB DS    XL1                      OVERHEAD NOT LAST BLOCK
DVCOVLB  DS    XL1                      OVERHEAD LAST BLOCK
*
DVCOVNK  DS    XL1                      OVERHEAD DECREMENT NOT KEYED
*
DVCFLAGS DS    BL1
DVC2BOV  EQU   X'08'                    IF 1, USE DVCOVHD
*                                       IF 0, USE DVCOVNLB,DVCOVLB
DVCFTOL  EQU   X'01'                    IF 1, APPLY TOLERANCE FACTOR
*
DVCTOL   DS    H                        TOLERANCE FACTOR
*              APPLY TOLERANCE FACTOR AS FOLLOWS:
*              1. ADD BLOCKSIZE AND KEYLENGTH
*              2. MULTIPLY BY DVCTOL
*              3. SHIFT RIGHT DVCTSHFT BITS
*              4. ADD APPROPRIATE OVERHEADS
DVCTSHFT EQU   9                        SHIFT AMT TO DIVIDE BY 512
*
DVCALT   DS    H                        NUMBER ALTERNATE TRKS/VOLUME
*
DVCENTLG EQU   *-DVCT                   BASIC SIZE OF DEVICE TABLE
*                                       ENTRY, NOT INCLUDING ADD'L
*                                       CHARACTERISTICS FOR RPS
**********************************************************************
*              THE FOLLOWING SECTION OF THE TABLE IS PRESENT         *
*              ONLY FOR RPS DEVICES--TEST UCBTBYT2 FOR UCB2OPT3      *
**********************************************************************
DVCRPS   DS    0CL4                     RPS SECTION
DVCOVR0  DS    H                        OVERHEAD BYTES FOR RECORD 0
DVCSECT  DS    XL1                      NUMBER SECTORS IN FULL TRACK
DVCSECTD DS    XL1                      NUMBER DATA SECTORS
*
*              END OF DVCT
         MEND
./ ADD NAME=IM#IGEN  0100-02182-02182-0701-00072-00072-00000-XMIT370
         MACRO
&LABEL   IM#IGEN &OP,&A,&B,&REG=R0
.*
.* Copyright 2001, 2002 James M. Morrison
.*
.*---------------------------------------------------------------------
.* Function: generate one instruction
.* &OP  - instruction opcode
.* &A   - first operand
.* &B   - second operand
.* &REG - work register
.* See IM#INSTR for further details, and notes below.
.*---------------------------------------------------------------------
         AIF   (T'&REG EQ 'O').XREG
         AIF   (T'&OP EQ 'O').XOP
         AIF   ('&OP' EQ '-CLEAR-').CLEAR
         AIF   ('&OP' EQ '(-CLEAR-)').CLEAR
         AIF   ('&OP' EQ '((-CLEAR-))').CLEAR
         AIF   ('&OP' EQ '-ZERO-').ZERO
         AIF   ('&OP' EQ '(-ZERO-)').ZERO
         AIF   ('&OP' EQ '((-ZERO-))').ZERO
         AIF   ('&OP' EQ '-0-').ZERO
         AIF   ('&OP' EQ '(-0-)').ZERO
         AIF   ('&OP' EQ '((-0-))').ZERO
         AIF   ('&OP' EQ 'MVI').SI
         AIF   ('&OP' EQ 'OI').SI
         AIF   ('&OP' EQ 'NI').SI
         AIF   ('&OP' EQ 'XI').SI
         AIF   ('&OP' EQ 'MVC').SS
         AIF   ('&B' NE '').B
         AIF   ('&A' NE '').A
         AIF   ('&REG' NE '').R
&LABEL   &OP   ,
         MEXIT
.*
.R       ANOP
&LABEL   &OP   &REG
         MEXIT
.*
.A       ANOP
&LABEL   &OP   &REG,&A
         MEXIT
.*
.B       ANOP
&LABEL   &OP   &REG,&A,&B
         MEXIT
.*
.CLEAR   ANOP
&LABEL   SLR   &REG,&REG               clear register
         MEXIT
.*
.ZERO    ANOP
&LABEL   SR    &REG,&REG               zero register
         MEXIT
.*
.SI      ANOP
.SS      ANOP
&LABEL   &OP   &A,&B
         MEXIT
.*
.XOP     MNOTE 8,'IM#IGEN missing OP value'
         MEXIT
.XREG    MNOTE 8,'IM#IGEN missing REG value'
.*---------------------------------------------------------------------
.* Notes:
.*
.*  1) RR, RX, and RS instructions don't need to be checked, the
.*     code handles them ASIS.  The other opcodes will need to be
.*     specifically checked, so the right operands can be generated
.*     for the target instruction.
.*---------------------------------------------------------------------
         MEND
./ ADD NAME=IM#IGENF 0100-02182-02182-0701-00082-00082-00000-XMIT370
         MACRO
&LABEL   IM#IGENF &SPEC,&REG=R0
.*
.* Copyright 2001, 2002 James M. Morrison
.*
.*---------------------------------------------------------------------
.* Function: generate one instruction - ASMF version
.* &OP  - instruction opcode
.* &A   - first operand
.* &B   - second operand
.* &REG - work register
.* See IM#INSTR for further details, and notes below.
.*---------------------------------------------------------------------
         LCLC  &OP,&A,&B,&C
&OP      SETC  '&SPEC(1)'
&A       SETC  '&SPEC(2)'
&B       SETC  '&SPEC(3)'
&C       SETC  '&SPEC(4)'
         MNOTE *,'IM#IGENF op &OP a &A b &B c &C'
         MNOTE *,'IM#IGENF SYSLIST(1) &SYSLIST(1)'
         MNOTE *,'IM#IGENF SYSLIST(2) &SYSLIST(2)'
         MNOTE *,'IM#IGENF SYSLIST(3) &SYSLIST(3)'
         MNOTE *,'IM#IGENF SYSLIST(4) &SYSLIST(4)'
         AIF   (T'&REG EQ 'O').XREG
         AIF   (T'&OP EQ 'O').XOP
         AIF   ('&OP' EQ '-CLEAR-').CLEAR
         AIF   ('&OP' EQ '(-CLEAR-)').CLEAR
         AIF   ('&OP' EQ '((-CLEAR-))').CLEAR
         AIF   ('&OP' EQ '-ZERO-').ZERO
         AIF   ('&OP' EQ '(-ZERO-)').ZERO
         AIF   ('&OP' EQ '((-ZERO-))').ZERO
         AIF   ('&OP' EQ '-0-').ZERO
         AIF   ('&OP' EQ '(-0-)').ZERO
         AIF   ('&OP' EQ '((-0-))').ZERO
         AIF   ('&OP' EQ 'MVI').SI
         AIF   ('&OP' EQ 'OI').SI
         AIF   ('&OP' EQ 'NI').SI
         AIF   ('&OP' EQ 'XI').SI
         AIF   ('&OP' EQ 'MVC').SS
         AIF   ('&B' NE '').B
         AIF   ('&A' NE '').A
         AIF   ('&REG' NE '').R
&LABEL   &OP   ,
         MEXIT
.*
.R       ANOP
&LABEL   &OP   &REG
         MEXIT
.*
.A       ANOP
&LABEL   &OP   &REG,&A
         MEXIT
.*
.B       ANOP
&LABEL   &OP   &REG,&A,&B
         MEXIT
.*
.CLEAR   ANOP
&LABEL   SLR   &REG,&REG               clear register
         MEXIT
.*
.ZERO    ANOP
&LABEL   SR    &REG,&REG               zero register
         MEXIT
.*
.SI      ANOP
.SS      ANOP
&LABEL   &OP   &A,&B
         MEXIT
.*
.XOP     MNOTE 8,'IM#IGEN missing OP value'
         MEXIT
.XREG    MNOTE 8,'IM#IGEN missing REG value'
.*---------------------------------------------------------------------
.* Notes:
.*
.*  1) RR, RX, and RS instructions don't need to be checked, the
.*     code handles them ASIS.  The other opcodes will need to be
.*     specifically checked, so the right operands can be generated
.*     for the target instruction.
.*---------------------------------------------------------------------
         MEND
./ ADD NAME=IM#INST  0100-02182-02182-0701-00081-00081-00000-XMIT370
         MACRO
&LABEL   IM#INST &REG,&SPEC
.*
.* Copyright 2001, 2002 James M. Morrison
.*
.*---------------------------------------------------------------------
.* See notes below for details and syntax examples - ASMH+ version
.*---------------------------------------------------------------------
         LCLA  &N,&NN
         LCLA  &I
&LABEL   IM#SECT LABEL
&N       SETA  N'&SPEC
&NN      SETA  N'&SPEC(1)
         AIF   ((&N EQ 1) AND (&NN EQ 1)).LALR
         AIF   (&N GT 0).LOOP
         MNOTE 8,'IM#INSTR missing SPEC'
         MEXIT
.*
.LOOP    ANOP
&I       SETA  &I+1
         IM#IGEN &SPEC(&I,1),&SPEC(&I,2),&SPEC(&I,3),REG=&REG
         AIF   (&I LT &N).LOOP
         MEXIT
.*
.LALR    IM#LALR &REG,&SPEC
         MEXIT
.*---------------------------------------------------------------------
.* Function: Generate one or more instructions from specified (SPEC)
.* operands.
.*
.* &REG  - work register (may not always be used); generally the
.*         register into which the calling macro wishes to place
.*         a value.
.* &SPEC - instruction specification
.*
.* SPEC Syntax samples (REG=Rx):
.*
.* SPEC                      calls     generates
.* ------------------------- -------   --------------------------------
.* (R3)                      IM#LALR   LR    Rx,R3
.* FIELD                     IM#LALR   LA    Rx,FIELD
.* *FIELD                    IM#LALR   L     Rx,FIELD
.* .FIELD                    IM#LALR   LH    Rx,FIELD
.*
.* -CLEAR-                   IM#LALR   SLR   Rx,Rx
.* -ZERO-                    IM#LALR   SR    Rx,Rx
.* -0-                       IM#LALR   SR    Rx,Rx
.*
.* ((LH,FIELD))              IM#IGEN   LH    Rx,FIELD
.* ((ICM,8,FIELD))           IM#IGEN   ICM   Rx,8,FIELD
.* ((-ZERO-),(IC,F1))        IM#IGEN   SR    Rx,Rx
.*                                     IC    Rx,F1
.* ((MVI,F,8))               IM#IGEN   MVI   F,8
.* ((MVC,F1,F2))             IM#IGEN   MVC   F1,F2
.*
.* ((-0-),(IC,F),(OI,X,32))  IM#IGEN   SR    Rx,Rx
.*                           IM#IGEN   IC    Rx,F
.*                           IM#IGEN   OI    X,32
.*
.* The basic function of this macro is to allow our callers to offer
.* the coder the opportunity to "reach into" the macro expansion
.* to add a few instructions.  Some of the syntax is as old as the
.* hills: (Rx) and *FIELD have been in common usage since I started
.* coding, and I have carried those syntax forms forward.
.*
.* If you wish to generate more than one instruction, the syntax must
.* conform to the IM#IGEN format; the IM#LALR format is mostly for
.* backwards compatability which only requires one instruction.
.* For IM#IGEN, each sublist specified will generate one instruction.
.*
.* Not all instructions are capable of being generated by IM#INSTR.
.* IM#LALR only supports the LR, LA, L, and LH instructions.
.* IM#IGEN should support all of the RR, RX, and RS instruction types,
.* and a handful of others; see IM#IGEN for these details.
.* Both IM#IGEN and IM#LALR support the -x- forms.
.*
.* The coder is strongly encouraged to read the macro expansion to
.* assure that what gets generated is what was intended, at least
.* until some general familiarity with IM#INSTR is obtained.
.*---------------------------------------------------------------------
         MEND
./ ADD NAME=IM#INSTF 0100-02182-02182-0702-00128-00128-00000-XMIT370
         MACRO
&LABEL   IM#INSTF &SPEC,&REG=R0,&LST=
.*
.* Copyright 2001, 2002 James M. Morrison
.*
.*---------------------------------------------------------------------
.* See notes below for details and syntax examples - ASMF version
.*---------------------------------------------------------------------
         GBLA  &#SUBLN
         GBLA  &#SUBLNI(8)
         GBLC  &#SUBLC(8)
         LCLA  &NSL           # &SYSLIST(1) operands
         LCLA  &NI            # &LST(n) operands specified
         LCLA  &I
         LCLC  &JUNK
.*
&LABEL   XMI#SECT LABEL
.*
&NSL     SETA  N'&SYSLIST(1)
         MNOTE *,'IM#INSTR LST &LST'
         MNOTE *,'IM#INSTR NSL &NSL'
.*
         IM#SUBL &LST(1),&LST(2),&LST(3),&LST(4),&LST(5),&LST(6)
&NI      SETA  &#SUBLN
         MNOTE *,'IM#INSTR NI &NI'
         AIF   (&#SUBLN GT 1).NOLALR
.*
         IM#SUBL &SPEC(1)
         AIF   (&#SUBLN EQ 1).LALR
.*
.NOLALR  MNOTE *,'IM#INSTF - not LALR'
         AIF   (&NSL EQ 0).NOSPEC
         MNOTE *,'IM#INSTR LST(1) &LST(1)'
         MNOTE *,'IM#INSTR LST(2) &LST(2)'
         MNOTE *,'IM#INSTR LST(3) &LST(3)'
         MNOTE *,'IM#INSTR LST(4) &LST(4)'
         MNOTE *,'IM#INSTR SPEC(1) &SPEC(1)'
         MNOTE *,'IM#INSTR SPEC(2) &SPEC(2)'
         MNOTE *,'IM#INSTR SPEC(3) &SPEC(3)'
         MNOTE *,'IM#INSTR SPEC(4) &SPEC(4)'
         MNOTE *,'IM#INSTR SYSLIST(1) &SYSLIST(1)'
         MNOTE *,'IM#INSTR SYSLIST(2) &SYSLIST(2)'
         MNOTE *,'IM#INSTR SYSLIST(3) &SYSLIST(3)'
         MNOTE *,'IM#INSTR SYSLIST(4) &SYSLIST(4)'
.*
.LOOP    ANOP
         MNOTE *,'IM#INSTF *************  LOOP  ********************'
&I       SETA  &I+1
&JUNK    SETC  '&SYSLIST(&I,1)'
         MNOTE *,'IM#INSTF I=&I SYSLIST(I,1) &JUNK'
&JUNK    SETC  '&SYSLIST(&I,2)'
         MNOTE *,'IM#INSTF I=&I SYSLIST(I,2) &JUNK'
&JUNK    SETC  '&SYSLIST(&I,3)'
         MNOTE *,'IM#INSTF I=&I SYSLIST(I,3) &JUNK'
&JUNK    SETC  '&SYSLIST(&I,4)'
         MNOTE *,'IM#INSTF I=&I SYSLIST(I,4) &JUNK'
.*
         MNOTE *,'INSTR->SUBL I=&I SYSLIST(I) &SYSLIST(&I)'
         IM#SUBL &SYSLIST(&I)
.*
         MNOTE *,'INSTR->SUBL I=&I LST(I) &LST(&I)'
         IM#SUBL &LST(&I)
.*
         IM#IGENF &SYSLIST(&I)
         AIF   (&I LT &NI).LOOP
         MEXIT
.*
.LALR    MNOTE *,'INSTR->LALR &REG,&LST'
         IM#LALR &REG,&LST
         MEXIT
.*
.NOSPEC  MNOTE 8,'IM#INSTR missing specification'
         MEXIT
.*---------------------------------------------------------------------
.* Function: Generate one or more instructions from specified (SPEC)
.* operands.
.*
.* &REG     - work register (may not always be used); generally the
.*            register into which the calling macro wishes to place
.*            a value.
.* &SPEC    - instruction specification
.*
.* SPEC Syntax samples (REG=Rx):
.*
.* SPEC                      calls     generates
.* ------------------------- -------   --------------------------------
.* (R3)                      IM#LALR   LR    Rx,R3
.* FIELD                     IM#LALR   LA    Rx,FIELD
.* *FIELD                    IM#LALR   L     Rx,FIELD
.* .FIELD                    IM#LALR   LH    Rx,FIELD
.*
.* -CLEAR-                   IM#LALR   SLR   Rx,Rx
.* -ZERO-                    IM#LALR   SR    Rx,Rx
.* -0-                       IM#LALR   SR    Rx,Rx
.*
.* ((LH,FIELD))              IM#IGEN   LH    Rx,FIELD
.* ((ICM,8,FIELD))           IM#IGEN   ICM   Rx,8,FIELD
.* ((-ZERO-),(IC,F1))        IM#IGEN   SR    Rx,Rx
.*                                     IC    Rx,F1
.* ((MVI,F,8))               IM#IGEN   MVI   F,8
.* ((MVC,F1,F2))             IM#IGEN   MVC   F1,F2
.*
.* ((-0-),(IC,F),(OI,X,32))  IM#IGEN   SR    Rx,Rx
.*                           IM#IGEN   IC    Rx,F
.*                           IM#IGEN   OI    X,32
.*
.* The basic function of this macro is to allow our callers to offer
.* the coder the opportunity to "reach into" the macro expansion
.* to add a few instructions.  Some of the syntax is as old as the
.* hills: (Rx) and *FIELD have been in common usage since I started
.* coding, and I have carried those syntax forms forward.
.*
.* If you wish to generate more than one instruction, the syntax must
.* conform to the IM#IGEN format; the IM#LALR format is mostly for
.* backwards compatability which only requires one instruction.
.* For IM#IGEN, each sublist specified will generate one instruction.
.*
.* Not all instructions are capable of being generated by IM#INSTR.
.* IM#LALR only supports the LR, LA, L, and LH instructions.
.* IM#IGEN should support all of the RR, RX, and RS instruction types,
.* and a handful of others; see IM#IGEN for these details.
.* Both IM#IGEN and IM#LALR support the -x- forms.
.*
.* The coder is strongly encouraged to read the macro expansion to
.* assure that what gets generated is what was intended, at least
.* until some general familiarity with IM#INSTR is obtained.
.*---------------------------------------------------------------------
         MEND
./ ADD NAME=IM#LALR  0100-02182-02182-0702-00065-00065-00000-XMIT370
         MACRO
&LABEL   IM#LALR &REG,&WHAT
.*
.* Copyright 2001, 2002 James M. Morrison
.*
.*---------------------------------------------------------------------
.* Function: Generate one instruction
.* &REG  - work register
.* &WHAT - (register), RX, or self-defining term to put in &REG
.* See IM#INSTR for further details
.*---------------------------------------------------------------------
         LCLA  &LWHAT
         LCLC  &TREG
         LCLC  &TWHAT
         AIF   ('&WHAT' NE '0').MORE
&LABEL   SLR   &REG,&REG                     zero register
         MEXIT
.MORE    ANOP
&TREG    SETC  '(&REG)'                      (LOWER '(&reg)')
&TWHAT   SETC  '&WHAT'                       (LOWER '&what')
.*       MNOTE 0,'IM#LALR REG &TREG'
.*       MNOTE 0,'IM#LALR WHAT &TWHAT'
         AIF   ('&TWHAT' EQ '&TREG').SKIP    already have value in reg
         AIF   ('&WHAT'      EQ '-CLEAR-').CLEAR
         AIF   ('&WHAT'      EQ '(-CLEAR-)').CLEAR
         AIF   ('&WHAT'      EQ '((-CLEAR-))').CLEAR
         AIF   ('&WHAT'      EQ '-ZERO-').ZERO
         AIF   ('&WHAT'      EQ '(-ZERO-)').ZERO
         AIF   ('&WHAT'      EQ '((-ZERO-))').ZERO
         AIF   ('&WHAT'      EQ '-0-').ZERO
         AIF   ('&WHAT'      EQ '(-0-)').ZERO
         AIF   ('&WHAT'      EQ '((-0-))').ZERO
         AIF   ('&WHAT'(1,1) EQ '(').LR
         AIF   ('&WHAT'(1,1) EQ '*').LOAD    *field means load field
         AIF   ('&WHAT'(1,1) EQ '.').LH      .field means load halfword
&LABEL   LA    &REG,&WHAT
         MEXIT
.*
.LR      ANOP
&LABEL   LR    &REG,&WHAT(1)
         MEXIT
.*
.LH      ANOP
&LWHAT   SETA  K'&WHAT-1
&TWHAT   SETC  '&WHAT'(2,&LWHAT)
&LABEL   LH    &REG,&TWHAT
         MEXIT
.*
.LOAD    ANOP
&LWHAT   SETA  K'&WHAT-1
&TWHAT   SETC  '&WHAT'(2,&LWHAT)
&LABEL   L     &REG,&TWHAT
         MEXIT
.*
.CLEAR   ANOP
&LABEL   SLR   &REG,&REG
         MEXIT
.*
.ZERO    ANOP
&LABEL   SR    &REG,&REG
         MEXIT
.*
.SKIP    ANOP
*              instruction suppressed; register already contains value
         MEND
./ ADD NAME=IM#SECT  0100-02182-02182-0702-00022-00022-00000-XMIT370
         MACRO
&LABEL   IM#SECT &SECT
.*
.* Copyright 2001, 2002 James M. Morrison
.*
         AIF   ('&SECT' EQ 'LABEL').DS0H
         AIF   ('&SECT' NE 'DSECT').NDSECT
&LABEL   DSECT ,
         MEXIT
.*
.NDSECT  AIF   ('&SECT' NE 'CSECT').NCSECT
&LABEL   CSECT ,
         MEXIT
.*
.NCSECT  AIF   ('&SECT' EQ '').DS0H
&LABEL   DS    0&SECT
         MEXIT
.*
.DS0H    ANOP
         AIF   ('&LABEL' EQ '').DONE
&LABEL   DS    0H
.DONE    MEND
./ ADD NAME=IM#SPLIT 0100-02182-02182-0702-00047-00047-00000-XMIT370
         MACRO
         IM#SPLIT
.*
.* Copyright 2001, 2002 James M. Morrison
.*
         GBLC  &G#SUBL(8)
         LCLC  &C
         LCLA  &DEPTH,&I,&IFIRST,&ILAST,&LX
.*
&G#SUBL(1) SETC ''
&G#SUBL(2) SETC ''
&G#SUBL(3) SETC ''
&G#SUBL(4) SETC ''
&G#SUBL(5) SETC ''
&G#SUBL(6) SETC ''
&G#SUBL(7) SETC ''
&G#SUBL(8) SETC ''
&I       SETA  2
&IFIRST  SETA  2
&ILAST   SETA  K'&SYSLIST(1)
.LOOP    ANOP
&C       SETC  '&SYSLIST(1)'(&I,1)
         AIF   ('&C' NE '(').CKRP
&DEPTH   SETA  &DEPTH+1
         AGO   .BUMP
.CKRP    AIF   ('&C' NE ')').CKCOMMA
&DEPTH   SETA  &DEPTH-1
         AGO   .BUMP
.CKCOMMA AIF   ('&C' NE ',').BUMP
         AIF   (&DEPTH GT 0).BUMP
.*
.*  G#SUBL(LX) = sublist string
.*
.NEW     ANOP
&LX      SETA  &LX+1
         AIF   (&LX GT 8).ERR
&G#SUBL(&LX) SETC '&SYSLIST(1)'(&IFIRST,&I-&IFIRST)
&IFIRST  SETA  &I+1
.*
.BUMP    ANOP
&I       SETA  &I+1
         AIF   (&I LT &ILAST).LOOP
         AIF   (&IFIRST LT &ILAST).NEW
         MEXIT
.*
.ERR     MNOTE *,'IM#SPLIT LX > 8'
         MEND
./ ADD NAME=IM#STA   0100-02182-02182-0702-00018-00018-00000-XMIT370
         MACRO
&LABEL   IM#STA &WHAT,&WHERE,&REG=R0
.*
.* Copyright 2001, 2002 James M. Morrison
.*
.*---------------------------------------------------------------------
.* &WHAT  - what value to store
.* &WHERE - field into which to store &WHAT
.* &REG   - register to use to L, LR, etc. &WHAT field
.*---------------------------------------------------------------------
         AIF   ('&WHAT'(1,1) EQ '(').LR
&LABEL   IM#LALR  &REG(1),&WHAT
         ST    &REG(1),&WHERE
         MEXIT
.*
.LR      ANOP
&LABEL   ST    &WHAT(1),&WHERE
         MEND
./ ADD NAME=IM#SUBL  0100-02182-02182-0702-00031-00031-00000-XMIT370
         MACRO
&LABEL   IM#SUBL &SPEC
.*
.* Copyright 2001, 2002 James M. Morrison
.*
         GBLA  &#SUBLN
         GBLA  &#SUBLNI(8)
         GBLC  &#SUBLC(8)
         LCLC  &JUNK(8)
         LCLA  &I,&MAXL
&MAXL    SETA  8                           max # operands examined
&#SUBLN  SETA  0
.*
.LOOP        ANOP
&I           SETA  &I+1
&#SUBLC(&I)  SETC  '&SYSLIST(&I)'
&JUNK(1)     SETC  '&SPEC(1)'
&JUNK(2)     SETC  '&SPEC(2)'
&JUNK(3)     SETC  '&SPEC(3)'
&JUNK(4)     SETC  '&SPEC(4)'
             AIF   ('&#SUBLC(&I)' EQ '').DONE
&#SUBLN      SETA  &#SUBLN+1
         MNOTE *,'IM#SUBL I &I JUNK(1) &JUNK(1)'
         MNOTE *,'IM#SUBL I &I JUNK(2) &JUNK(2)'
         MNOTE *,'IM#SUBL I &I JUNK(3) &JUNK(3)'
         MNOTE *,'IM#SUBL I &I JUNK(4) &JUNK(4)'
         MNOTE *,'IM#SUBL I &I #SUBLNI &#SUBLNI(&I) #SUBLC &#SUBLC(&I)'
         AIF   (&I LT &MAXL).LOOP
.*
.DONE    MNOTE *,'IM#SUBL SUBLN &#SUBLN'
         MEND
./ ADD NAME=JASM     0100-02182-02182-0702-00012-00012-00000-XMIT370
//INSTALL  JOB CLASS=A,MSGCLASS=A,MSGLEVEL=(2,0)
//*
//RECV370 EXEC ASM370,M=RECV370
//*
//LINK     EXEC PGM=IEWL,PARM='LIST,MAP,XREF,LET,NCAL,RENT',COND=(5,LT)
//SYSPRINT  DD SYSOUT=*
//SYSLMOD   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR
//SYSLIB    DD DSN=SYS2.XMIT370.OBJ,DISP=SHR
//SYSUT1    DD UNIT=SYSDA,SPACE=(TRK,(5,5))
//* SLIN    DD DSN=SYS2.XMIT370.ASM(KXMIT),DISP=SHR
//SYSLIN    DD DSN=SYS2.XMIT370.ASM(KRECV),DISP=SHR
//
./ ADD NAME=JCBTUNLD 0100-02182-02182-0702-00010-00010-00000-XMIT370
//UNLOAD   JOB CBT,REGION=1024K,MSGCLASS=A,CLASS=A
//IEBCOPY  EXEC PGM=IEBCOPY
//SYSPRINT  DD SYSOUT=*
//SYSUT1    DD DSN=SYS2.XMIT370.ASM,DISP=SHR
//SYSUT2    DD DSN=SYS2.XMIT370.V0004.CBT,
//             UNIT=TAPE,VOL=SER=XV0004,
//             LABEL=(1,SL),
//             DISP=(,CATLG)
//SYSIN     DD DUMMY
//
./ ADD NAME=JCOMP    0100-02182-02182-0702-00012-00012-00000-XMIT370
//COMPRESS JOB CLASS=A,MSGCLASS=A
//*
//COMPRESS PROC DS=NULLFILE
//IEBCOPY  EXEC PGM=IEBCOPY,REGION=2048K
//SYSPRINT  DD SYSOUT=*
//SYSUT1    DD DSN=&DS,DISP=SHR
//SYSUT2    DD DSN=&DS,DISP=SHR
//SYSIN     DD DUMMY
//         PEND
//*
//ASM      EXEC COMPRESS,DS='SYS2.XMIT370.ASM'
//
./ ADD NAME=JDEBUGR  0100-02182-02182-0702-00028-00028-00000-XMIT370
//RECV370  JOB TESTING,REGION=1024K,MSGCLASS=A,CLASS=A
//*            //*JOBPARM LINECT=0
//DELETE   EXEC PGM=IEHPROGM
//SYSPRINT  DD DUMMY
//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR
 SCRATCH DSNAME=SYS2.RECV370.PDS,VOL=3380=MVS809
 UNCATLG DSNAME=SYS2.RECV370.PDS
 SCRATCH DSNAME=SYS2.RECV370.SYSUT1,VOL=3380=MVS809
 UNCATLG DSNAME=SYS2.RECV370.SYSUT1
//*
//RECV370  EXEC PGM=RECV370
//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR
//XMITPRT   DD SYSOUT=*
//XMITIN    DD DSN=SYS2.XMIT370.MVS38J.XMIT,DISP=SHR
//* ITIN    DD DSN=SYS2.XMIT370.MVS38J.XMIT2,DISP=SHR
//SYSPRINT  DD SYSOUT=*
//SYSIN     DD DUMMY
//SYSUT1    DD DSN=SYS2.RECV370.SYSUT1,
//             UNIT=3380,VOL=SER=MVS809,
//             SPACE=(CYL,(10,10),RLSE),
//             DISP=(,CATLG)
//SYSUT2    DD DSN=SYS2.RECV370.PDS,
//             UNIT=3380,VOL=SER=MVS809,
//             SPACE=(CYL,(10,10),RLSE),
//             DISP=(,CATLG)
//XMITDBUG  DD DSN=SYS2.XMIT370.ASM(KDEBUGR),DISP=SHR
//SYSUDUMP  DD SYSOUT=*
//
./ ADD NAME=JDEBUGX  0100-02182-02182-0702-00027-00027-00000-XMIT370
//XMIT370  JOB TESTING,REGION=1024K,MSGCLASS=A,CLASS=A
//*JOBPARM LINECT=0
//DELETE   EXEC PGM=IEHPROGM
//SYSPRINT  DD SYSOUT=*
//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR
 SCRATCH DSNAME=SYS2.XMIT370.MVS38J.XMI,VOL=3380=MVS809
 UNCATLG DSNAME=SYS2.XMIT370.MVS38J.XMI
 SCRATCH DSNAME=SYS2.XMIT370.UNLD.MVS38J,VOL=3380=MVS809
 UNCATLG DSNAME=SYS2.XMIT370.UNLD.MVS38J
//*
//XMIT370  EXEC PGM=XMIT370,PARM=1
//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR
//XMITPRT   DD SYSOUT=*
//SYSPRINT  DD SYSOUT=*
//SYSUDUMP  DD SYSOUT=*
//SYSIN     DD DUMMY
//* SUT1    DD DSN=SYS2.XMIT370.ASM,DISP=SHR
//SYSUT2    DD DSN=SYS2.XMIT370.UNLD.MVS38J,
//             UNIT=3380,VOL=SER=MVS809,
//             SPACE=(CYL,(5,1),RLSE),
//             DISP=(NEW,CATLG)
//XMITOUT   DD DSN=SYS2.XMIT370.MVS38J.XMI,
//             VOL=SER=MVS809,UNIT=3380,
//             SPACE=(CYL,(5,1),RLSE),
//             DISP=(,CATLG)
//XMITDBUG  DD DSN=SYS2.XMIT370.ASM(KDEBUGX),DISP=SHR
//
./ ADD NAME=JDEMOPDS 0100-02182-02182-0702-00027-00027-00000-XMIT370
//XMITPDS  JOB 'DEMO DSORG=PO',CLASS=A,MSGCLASS=A
//*
//* TRANSMIT XMIT370
//*
//DELETE   EXEC PGM=IEHPROGM
//SYSPRINT  DD SYSOUT=*
//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR
//SYSIN     DD *
 SCRATCH DSNAME=SYS2.XMIT370.DEMO.XMIT,VOL=3380=MVS809
 UNCATLG DSNAME=SYS2.XMIT370.DEMO.XMIT
//*
//XMIT     EXEC PGM=XMIT370
//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR
//SYSPRINT  DD SYSOUT=*
//XMITPRT   DD SYSOUT=*
//SYSUDUMP  DD SYSOUT=*
//SYSUT1    DD DSN=SYS2.XMIT370.ASM,DISP=SHR
//SYSUT2    DD DSN=&&SYSUT2,
//             UNIT=SYSDA,                            SYSALLDA
//             SPACE=(CYL,(5,1),
//             DISP=(,DELETE,DELETE)
//XMITOUT   DD DSN=SYS2.XMIT370.DEMO.XMIT,
//             UNIT=3380,VOL=SER=MVS809,
//             SPACE=(CYL,(5,1)),
//             DISP=(,CATLG,CATLG)
//SYSIN     DD DUMMY
//
./ ADD NAME=JDEMOSEQ 0100-02182-02182-0702-00023-00023-00000-XMIT370
//XMITSEQ  JOB 'DEMO DSORG=PS',CLASS=A,MSGCLASS=A
//*
//* TEST XMIT OF SEQUENTIAL DATASET
//*
//DELETE   EXEC PGM=IEHPROGM
//SYSPRINT  DD SYSOUT=*
//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR
//SYSIN     DD *
 SCRATCH DSNAME=SYS2.XMIT370.DEMO.XMIT,VOL=3330=MVS809
 UNCATLG DSNAME=SYS2.XMIT370.DEMO.XMIT
//*
//XMIT     EXEC PGM=XMIT370
//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR
//SYSPRINT  DD SYSOUT=*
//XMITPRT   DD SYSOUT=*
//SYSUDUMP  DD SYSOUT=*
//SYSUT1    DD DSN=JMM.SEQ001,DISP=SHR
//XMITOUT   DD DSN=SYS2.XMIT370.DEMO.XMIT
//             UNIT=3380,VOL=SER=MVS809,              SYSALLDA
//             SPACE=(CYL,(1,1)),
//             DISP=(,CATLG,CATLG)
//SYSIN     DD DUMMY
//
./ ADD NAME=JINITT   0100-02182-02182-0702-00007-00007-00000-XMIT370
//INITT    JOB CLASS=A,MSGCLASS=A
//IEHINITT EXEC PGM=IEHINITT
//SYSPRINT  DD SYSOUT=*
//TAPE      DD UNIT=(TAPE,,DEFER),DCB=DEN=4  6250 BPI
//SYSIN     DD *
TAPE     INITT SER=XV0004,OWNER='N9GTM'
//
./ ADD NAME=JINSTALL 0100-02182-02182-0702-00083-00083-00000-XMIT370
//INSTALL  JOB XMIT370,CLASS=A,MSGCLASS=A,
//             MSGLEVEL=(2,0),NOTIFY=N9GTM
//*            RESTART=XMITVTAB.ASMBLR
//* -------------------------------------------------------------------
//ASM370   PROC M=MISSING,LIST=,PRT=DISK
//ASMBLR   EXEC PGM=IFOX00,
//             COND=(5,LT),
//             REGION=6144K,
//             PARM='&LIST.LIST,NOXREF,NORLD,LINECOUNT(999)'
//SYSPRINT  DD DDNAME=&PRT
//SYSOUT    DD SYSOUT=*
//DISK      DD DSN=SYS2.XMIT370.LIST(&M),DISP=SHR
//SYSLIB    DD DSN=SYS2.XMIT370.ASM,DISP=SHR,
//             DCB=BLKSIZE=32720
//          DD DSN=SYS1.AMACLIB,DISP=SHR
//          DD DSN=SYS1.AMODGEN,DISP=SHR
//          DD DSN=SYS1.AGENLIB,DISP=SHR
//SYSPUNCH  DD DSN=SYS2.XMIT370.OBJ(&M),DISP=SHR
//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(35,10))
//SYSUT2    DD UNIT=SYSDA,SPACE=(CYL,(35,10))
//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(50,10))
//SYSIN     DD DSN=SYS2.XMIT370.ASM(&M),DISP=SHR
//         PEND
//* -------------------------------------------------------------------
//DELETE   EXEC PGM=IEHPROGM
//SYSPRINT  DD DUMMY
//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR
 SCRATCH DSNAME=SYS2.XMIT370.LIST,VOL=3380=MVS809
 UNCATLG DSNAME=SYS2.XMIT370.LIST
 SCRATCH DSNAME=SYS2.XMIT370.OBJ,VOL=3380=MVS809
 UNCATLG DSNAME=SYS2.XMIT370.OBJ
//*
//ALLOC    EXEC PGM=IEFBR14
//LIST      DD DSN=SYS2.XMIT370.LIST,
//             UNIT=3380,VOL=SER=MVS809,
//             SPACE=(CYL,(20,0,5),RLSE),
//             DCB=(RECFM=FB,LRECL=121,BLKSIZE=23474),
//             DISP=(,CATLG)
//OBJ       DD DSN=SYS2.XMIT370.OBJ,
//             UNIT=3380,VOL=SER=MVS809,
//             SPACE=(CYL,(5,0,5),RLSE),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),
//             DISP=(,CATLG)
//*
//* -------------------------------------------------------------------
//RECVBLK  EXEC ASM370,M=RECVBLK
//RECVCTL  EXEC ASM370,M=RECVCTL
//RECVGET  EXEC ASM370,M=RECVGET
//RECVRCPY EXEC ASM370,M=RECVRCPY
//RECVUTIL EXEC ASM370,M=RECVUTIL
//RECVVTAB EXEC ASM370,M=RECVVTAB
//RECV370  EXEC ASM370,M=RECV370
//UTILABND EXEC ASM370,M=UTILABND
//UTILDBUG EXEC ASM370,M=UTILDBUG
//UTILHEX  EXEC ASM370,M=UTILHEX
//UTILLOG  EXEC ASM370,M=UTILLOG
//UTILPSR  EXEC ASM370,M=UTILPSR
//UTILSNAP EXEC ASM370,M=UTILSNAP
//UTILTIOT EXEC ASM370,M=UTILTIOT
//XMITBUF  EXEC ASM370,M=XMITBUF
//XMITCPR1 EXEC ASM370,M=XMITCPR1
//XMITDIR  EXEC ASM370,M=XMITDIR
//XMITESZ  EXEC ASM370,M=XMITESZ
//XMITPUT  EXEC ASM370,M=XMITPUT
//XMITUNLD EXEC ASM370,M=XMITUNLD
//XMITVTAB EXEC ASM370,M=XMITVTAB
//XMIT01   EXEC ASM370,M=XMIT01
//XMIT02A  EXEC ASM370,M=XMIT02A
//XMIT02B  EXEC ASM370,M=XMIT02B
//XMIT03   EXEC ASM370,M=XMIT03
//XMIT06   EXEC ASM370,M=XMIT06
//XMIT370  EXEC ASM370,M=XMIT370
//* -------------------------------------------------------------------
//LINK     EXEC PGM=IEWL,
//             COND=(5,LT),
//             PARM='LIST,MAP,XREF,LET,NCAL,RENT'
//SYSPRINT  DD SYSOUT=*
//SYSLMOD   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR
//SYSLIB    DD DSN=SYS2.XMIT370.OBJ,DISP=SHR
//SYSUT1    DD UNIT=SYSDA,SPACE=(TRK,(5,5))
//SYSLIN    DD DSN=SYS2.XMIT370.ASM(KXMIT),DISP=SHR
//          DD DSN=SYS2.XMIT370.ASM(KRECV),DISP=SHR
//
./ ADD NAME=JLINK    0100-02182-02182-0702-00013-00013-00000-XMIT370
//LINK     JOB XMIT370,CLASS=A,MSGCLASS=A,
//             MSGLEVEL=(2,0),NOTIFY=JMM
//*
//LINK     EXEC PGM=IEWL,
//             COND=(5,LT),
//             PARM='LIST,MAP,XREF,LET,NCAL,RENT'
//SYSPRINT  DD SYSOUT=*
//SYSLMOD   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR
//SYSLIB    DD DSN=SYS2.XMIT370.OBJ,DISP=SHR
//SYSUT1    DD UNIT=SYSDA,SPACE=(TRK,(5,5))
//SYSLIN    DD DSN=SYS2.XMIT370.ASM(KXMIT),DISP=SHR   XMIT370
//*         DD DSN=SYS2.XMIT370.ASM(KRECV),DISP=SHR   RECV370
//
./ ADD NAME=JRECV    0100-02182-02182-0702-00042-00042-00000-XMIT370
//RECV370  JOB TESTING,REGION=1024K,MSGCLASS=A,CLASS=A
//*            //*JOBPARM LINECT=0
//*--------------------------------------------------------------------
//RECV370  PROC XMIT=
//RECV370  EXEC PGM=RECV370
//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR
//XMITPRT   DD SYSOUT=*
//XMITIN    DD DSN=SYS2.XMIT370.MVS38J.XMIT&XMIT,DISP=SHR
//SYSPRINT  DD SYSOUT=*
//SYSIN     DD DUMMY
//SYSUT1    DD DSN=SYS2.RECV370.MVS38J.XMIT&XMIT..SYSUT1,
//             UNIT=3380,VOL=SER=MVS809,
//             SPACE=(CYL,(10,10),RLSE),
//             DISP=(,CATLG)
//SYSUT2    DD DSN=SYS2.RECV370.MVS38J.XMIT&XMIT..PDS,
//             UNIT=3380,VOL=SER=MVS809,
//             SPACE=(CYL,(10,10,15),RLSE),
//             DISP=(,CATLG)
//* ITDBUG  DD DSN=SYS2.XMIT370.ASM(KDEBUGR),DISP=SHR
//SYSUDUMP  DD SYSOUT=*
//         PEND
//*--------------------------------------------------------------------
//DELETE   EXEC PGM=IEHPROGM
//SYSPRINT  DD DUMMY
//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR
 SCRATCH DSNAME=SYS2.RECV370.MVS38J.XMIT.PDS,VOL=3380=MVS809
 UNCATLG DSNAME=SYS2.RECV370.MVS38J.XMIT.PDS
 SCRATCH DSNAME=SYS2.RECV370.MVS38J.XMIT2.PDS,VOL=3380=MVS809
 UNCATLG DSNAME=SYS2.RECV370.MVS38J.XMIT2.PDS
 SCRATCH DSNAME=SYS2.RECV370.MVS38J.XMIT3.PDS,VOL=3380=MVS809
 UNCATLG DSNAME=SYS2.RECV370.MVS38J.XMIT3.PDS
 SCRATCH DSNAME=SYS2.RECV370.MVS38J.XMIT.SYSUT1,VOL=3380=MVS809
 UNCATLG DSNAME=SYS2.RECV370.MVS38J.XMIT.SYSUT1
 SCRATCH DSNAME=SYS2.RECV370.MVS38J.XMIT2.SYSUT1,VOL=3380=MVS809
 UNCATLG DSNAME=SYS2.RECV370.MVS38J.XMIT2.SYSUT1
 SCRATCH DSNAME=SYS2.RECV370.MVS38J.XMIT3.SYSUT1,VOL=3380=MVS809
 UNCATLG DSNAME=SYS2.RECV370.MVS38J.XMIT3.SYSUT1
//*
//RECV1    EXEC RECV370,XMIT=
//RECV2    EXEC RECV370,XMIT=2
//RECV3    EXEC RECV370,XMIT=3
//
./ ADD NAME=JUNLD    0100-02182-02182-0702-00017-00017-00000-XMIT370
//UNLOAD   JOB TESTING,REGION=1024K,MSGCLASS=A,CLASS=A
//DELETE   EXEC PGM=IEHPROGM
//SYSPRINT  DD SYSOUT=*
//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR
 SCRATCH DSNAME=SYS2.IEBCOPY.UNLD.MVS38J,VOL=3380=MVS809
 UNCATLG DSNAME=SYS2.IEBCOPY.UNLD.MVS38J
//*
//IEBCOPY  EXEC PGM=IEBCOPY
//SYSPRINT  DD SYSOUT=*
//IN        DD DSN=SYS2.XMIT370.ASM,DISP=SHR
//OUT       DD UNIT=3380,VOL=SER=MVS809,
//             DSN=SYS2.IEBCOPY.UNLD.MVS38J,
//             SPACE=(CYL,(10,10),RLSE),
//             DISP=(NEW,CATLG)
//SYSIN     DD *
 COPY OUTDD=OUT,INDD=IN
//
./ ADD NAME=JXMIT    0100-02182-02182-0702-00025-00025-00000-XMIT370
//XMIT370  JOB TESTING,REGION=1024K,MSGCLASS=A,CLASS=A
//*JOBPARM LINECT=0
//DELETE   EXEC PGM=IEHPROGM
//SYSPRINT  DD SYSOUT=*
//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR
 SCRATCH DSNAME=SYS2.XMIT370.MVS38J.XMIT,VOL=3380=MVS809
 UNCATLG DSNAME=SYS2.XMIT370.MVS38J.XMIT
 SCRATCH DSNAME=SYS2.XMIT370.MVS38J.UNLD,VOL=3380=MVS809
 UNCATLG DSNAME=SYS2.XMIT370.MVS38J.UNLD
//*
//XMIT370  EXEC PGM=XMIT370
//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR
//XMITPRT   DD SYSOUT=*
//SYSPRINT  DD SYSOUT=*
//SYSIN     DD DUMMY
//SYSUT1    DD DSN=SYS2.XMIT370.ASM,DISP=SHR
//SYSUT2    DD DSN=SYS2.XMIT370.MVS38J.UNLD,
//             UNIT=3380,VOL=SER=MVS809,
//             SPACE=(CYL,(5,1),RLSE),
//             DISP=(NEW,CATLG)
//XMITOUT   DD DSN=SYS2.XMIT370.MVS38J.XMIT,
//             VOL=SER=MVS809,UNIT=3380,
//             SPACE=(CYL,(5,1),RLSE),
//             DISP=(,CATLG)
//
./ ADD NAME=JXMIT2   0100-02182-02182-0702-00032-00032-00000-XMIT370
//XMIT370  JOB TESTING,REGION=1024K,MSGCLASS=A,CLASS=A
//*JOBPARM LINECT=0
//DELETE   EXEC PGM=IEHPROGM
//SYSPRINT  DD SYSOUT=*
//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR
 SCRATCH DSNAME=SYS2.XMIT370.MVS38J.XMIT2,VOL=3380=MVS809
 UNCATLG DSNAME=SYS2.XMIT370.MVS38J.XMIT2
 SCRATCH DSNAME=SYS2.XMIT370.MVS38J.UNLD,VOL=3380=MVS809
 UNCATLG DSNAME=SYS2.XMIT370.MVS38J.UNLD
//*
//XMIT370  EXEC PGM=XMIT370
//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR
//XMITPRT   DD SYSOUT=*
//SYSPRINT  DD SYSOUT=*
//SYSIN     DD DUMMY
//SYSUT2    DD DSN=SYS2.XMIT370.MVS38J.UNLD,
//             UNIT=3380,VOL=SER=MVS809,
//             SPACE=(CYL,(10,10),RLSE),
//             DISP=(NEW,CATLG)
//XMITOUT   DD DSN=SYS2.XMIT370.MVS38J.XMIT2,
//             UNIT=3380,VOL=SER=MVS809,
//             SPACE=(CYL,(5,1),RLSE),
//             DISP=(,CATLG)
//SYSUT1    DD DSN=SYS2.XMIT370.ASM,DISP=SHR
//SYSUDUMP  DD SYSOUT=*
//* ITDBUG  DD DSN=SYS2.XMIT370.ASM(KDEBUGX),DISP=SHR
//*
//* MVS38J  LRECL=56
//* MVS/ESA LRECL=60
//*
//COPYR1    DD DUMMY,DCB=LRECL=60
//
./ ADD NAME=JXMIT3   0100-02182-02182-0702-00031-00031-00000-XMIT370
//XMIT370  JOB TESTING,REGION=1024K,MSGCLASS=A,CLASS=A
//*JOBPARM LINECT=0
//DELETE   EXEC PGM=IEHPROGM
//SYSPRINT  DD SYSOUT=*
//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR
 SCRATCH DSNAME=SYS2.XMIT370.MVS38J.XMIT3,VOL=3380=MVS809
 UNCATLG DSNAME=SYS2.XMIT370.MVS38J.XMIT3
 SCRATCH DSNAME=SYS2.XMIT370.MVS38J.UNLD,VOL=3380=MVS809
 UNCATLG DSNAME=SYS2.XMIT370.MVS38J.UNLD
//*
//XMIT370  EXEC PGM=XMIT370
//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR
//XMITPRT   DD SYSOUT=*
//SYSPRINT  DD SYSOUT=*
//SYSIN     DD DUMMY
//SYSUT2    DD DSN=SYS2.XMIT370.MVS38J.UNLD,
//             UNIT=3380,VOL=SER=MVS809,
//             SPACE=(CYL,(10,1),RLSE),
//             DISP=(NEW,CATLG)
//XMITOUT   DD DSN=SYS2.XMIT370.MVS38J.XMIT3,
//             UNIT=3380,VOL=SER=MVS809,
//             SPACE=(CYL,(10,1),RLSE),
//             DISP=(,CATLG)
//SYSUT1    DD DSN=SYS2.XMIT370.ASM,DISP=SHR
//SYSUDUMP  DD SYSOUT=*
//* ITDBUG  DD DSN=SYS2.XMIT370.ASM(KDEBUGX),DISP=SHR
//*
//* MVS/ESA LRECL=64
//*
//COPYR1    DD DUMMY,DCB=LRECL=64
//
./ ADD NAME=JZAP     0100-02182-02182-0702-00011-00011-00000-XMIT370
//ZAP      JOB CLASS=A,MSGCLASS=A
//ZAP      EXEC PGM=IKJEFT01,REGION=1024K,DYNAMNBR=20,COND=EVEN
//SYSPRINT  DD SYSOUT=*
//SYSHELP   DD DISP=SHR,DSN=SYS1.HELP
//SYSTSPRT  DD SYSOUT=*
//ZAPLOG    DD SYSOUT=*
//SYSTSIN   DD *
ZAP 'SYS2.IEBCOPY.UNLD.MVS38J' NOT3270 LOG VERBOSE
DUMPE
END
//
./ ADD NAME=JZTEST   0100-02182-02182-0702-00019-00019-00000-XMIT370
//INSTALL  JOB CLASS=A,MSGCLASS=A
//*--------------------------------------------------------------------
//* DOES NOT APPLY TO XMIT370 0004
//*--------------------------------------------------------------------
//* IF YOU'RE USING AN OLDER ASSEMBLER (LIKE ASMF/IFOX00 FROM MVS38J),
//* YOU NEED TO ASSEMBLE THE FOLLOWING TO SEE IF YOU HAVE A BUG IN
//* MACRO OPERAND SUBLIST HANDLING.  REVIEW THE ASSEMBLY OUTPUT, AND
//* IF THE MNOTE OUTPUT DOESN'T MATCH WHAT IT SHOULD BE, YOU HAVE THE
//* BUG.  IF SO, EDIT XMIT#SET TO SPECIFY
//*
//*    &G#ASMF  SETB 1
//*
//* IF YOU DON'T HAVE THE BUG, EDIT XMIT#SET TO SPECIFY
//*
//*    &G#ASMF  SETB 0
//*
//* BEFORE YOU ASSEMBLE XMIT370/RECV370.
//*
//ZTEST   EXEC ASM370F,M=ZTEST
./ ADD NAME=KDEBUGR  0100-02182-02182-0702-00014-00014-00000-XMIT370
DEFAULT  1
UTILDBUG 1     TURN ON DEBUG MSGS RIGHT AWAY
RECV370  9
RECVBLK  0
RECVCTL  5
RECVGET  0
RECVRCPY
RECVUTIL 9
UTILABND 9
UTILHEX  0
UTILLOG  0
UTILPSR  0
UTILSNAP 0
UTILTIOT 0
./ ADD NAME=KDEBUGX  0100-02182-02182-0702-00020-00020-00000-XMIT370
DEFAULT  1
UTILDBUG 1     TURN ON DEBUG MSGS RIGHT AWAY
XMIT370
XMITBUF  0
XMITCPR1 9
XMITDIR  0
XMITESZ  0
XMITPUT  0
XMITUNLD 1
XMIT01
XMIT02A  3
XMIT02B
XMIT03
XMIT06
UTILABND 9
UTILHEX  0
UTILLOG  0
UTILPSR  0
UTILSNAP 0
UTILTIOT 0
./ ADD NAME=KRECV    0100-02182-02182-0702-00017-00017-00000-XMIT370
 SETCODE AC(1)
 INCLUDE SYSLIB(RECV370)
 INCLUDE SYSLIB(RECVBLK)
 INCLUDE SYSLIB(RECVCTL)
 INCLUDE SYSLIB(RECVGET)
 INCLUDE SYSLIB(RECVRCPY)
 INCLUDE SYSLIB(RECVUTIL)
 INCLUDE SYSLIB(RECVVTAB)
 INCLUDE SYSLIB(UTILABND)
 INCLUDE SYSLIB(UTILDBUG)
 INCLUDE SYSLIB(UTILHEX)
 INCLUDE SYSLIB(UTILLOG)
 INCLUDE SYSLIB(UTILPSR)
 INCLUDE SYSLIB(UTILSNAP)
 INCLUDE SYSLIB(UTILTIOT)
 ENTRY RECV370
 NAME RECV370(R)
./ ADD NAME=KXMIT    0100-02182-02182-0702-00023-00023-00000-XMIT370
 SETCODE AC(1)
 INCLUDE SYSLIB(XMIT370)
 INCLUDE SYSLIB(XMITBUF)
 INCLUDE SYSLIB(XMITCPR1)
 INCLUDE SYSLIB(XMITDIR)
 INCLUDE SYSLIB(XMITESZ)
 INCLUDE SYSLIB(XMITPUT)
 INCLUDE SYSLIB(XMITUNLD)
 INCLUDE SYSLIB(XMIT01)
 INCLUDE SYSLIB(XMIT02A)
 INCLUDE SYSLIB(XMIT02B)
 INCLUDE SYSLIB(XMIT03)
 INCLUDE SYSLIB(XMIT06)
 INCLUDE SYSLIB(XMITVTAB)
 INCLUDE SYSLIB(UTILABND)
 INCLUDE SYSLIB(UTILDBUG)
 INCLUDE SYSLIB(UTILHEX)
 INCLUDE SYSLIB(UTILLOG)
 INCLUDE SYSLIB(UTILPSR)
 INCLUDE SYSLIB(UTILSNAP)
 INCLUDE SYSLIB(UTILTIOT)
 ENTRY XMIT370
 NAME XMIT370(R)
./ ADD NAME=LICENSE  0100-02182-02182-0702-00106-00106-00000-XMIT370
<HTML>
<HEAD>
<TITLE>XMIT370 Q Public License</TITLE>
</HEAD>
<BODY TEXT="black" BGCOLOR="white" LINK="blue" VLINK="purple"
onload="if(top.frames.length!=0)top.location=self.location;">

<H1 ALIGN="center">THE Q PUBLIC LICENSE version 1.0<BR>
<BR>
<FONT SIZE="2">Copyright (C) 1999 Trolltech AS, Norway.<BR>
</FONT><FONT SIZE="1">Everyone is permitted to copy and<BR>
distribute this license document. </FONT></H1>

<P>The intent of this license is to establish freedom to share and
change the software regulated by this license under the open source
model.</P>
<P>This license applies to any software containing a notice placed
by the copyright holder saying that it may be distributed under the
terms of the Q Public License version 1.0. Such software is herein
referred to as the Software. This license covers modification and
distribution of the Software, use of third-party application
programs based on the Software, and development of free software
which uses the Software.</P>

<H2 ALIGN="center">Granted Rights</H2>

<P>1. You are granted the non-exclusive rights set forth in this
license provided you agree to and comply with any and all conditions
in this license. Whole or partial distribution of the Software, or
software items that link with the Software, in any form signifies
acceptance of this license.</P>
<P>2. You may copy and distribute the Software in unmodified form
provided that the entire package, including - but not restricted to
- copyright, trademark notices and disclaimers, as released by the
initial developer of the Software, is distributed.</P>
<P>3. You may make modifications to the Software and distribute your
modifications, in a form that is separate from the Software,
such as patches. The following restrictions apply to modifications:
</P>
<BLOCKQUOTE>
<P>a. Modifications must not alter or remove any copyright notices
in the Software.</P>
<P>b. When modifications to the Software are released under this
license, a non-exclusive royalty-free right is granted to the
initial developer of the Software to distribute your modification
in future versions of the Software provided such versions remain
available under these terms in addition to any other license(s)
of the initial developer.</P>
</BLOCKQUOTE>
<P>4. You may distribute machine-executable forms of the Software
or machine-executable forms of modified versions of the Software,
provided that you meet these restrictions:</P>
<BLOCKQUOTE>
<P>a. You must include this license document in the distribution.</P>
<P>b. You must ensure that all recipients of the machine-executable
forms are also able to receive the complete machine-readable source
code to the distributed Software, including all modifications,
without any charge beyond the costs of data transfer, and place
prominent notices in the distribution explaining this.</P>
<P>c. You must ensure that all modifications included in the
machine-executable forms are available under the terms of this
license.</P>
</BLOCKQUOTE>
<P>5. You may use the original or modified versions of the Software
to compile, link and run application programs legally developed by
you or by others.</P>
<P>6. You may develop application programs, reusable components and
other software items that link with the original or modified
versions of the Software. These items, when distributed, are
subject to the following requirements:</P>
<BLOCKQUOTE>
<P>a. You must ensure that all recipients of machine-executable
forms of these items are also able to receive and use the
complete machine-readable source code to the items without any
charge beyond the costs of data transfer.</P>
<P>b. You must explicitly license all recipients of your items to
use and re-distribute original and modified versions of the items
in both machine-executable and source code forms. The recipients
must be able to do so without any charges whatsoever, and they
must be able to re-distribute to anyone they choose.</P>
<P>c. If the items are not available to the general public, and
the initial developer of the Software requests a copy of the items,
then you must supply one.</P>
</BLOCKQUOTE>

<H2 ALIGN="center">Limitations of Liability</H2>

<P>In no event shall the initial developers or copyright holders be
liable for any damages whatsoever, including - but not restricted
to - lost revenue or profits or other direct, indirect, special,
incidental or consequential damages, even if they have been advised
of the possibility of such damages, except to the extent invariable
law, if any, provides otherwise.</P>

<H2 ALIGN="center">No Warranty</H2>

<P>The Software and this license document are provided AS IS with
NO WARRANTY OF ANY KIND, INCLUDING THE WARRANTY OF DESIGN,
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</P>

<H2 ALIGN="center">Choice of Law</H2>

<P>This license is governed by the Laws of the United States of
America and the State of Illinois.</P>
</BODY>
</HTML>
./ ADD NAME=RECVBLK  0100-02182-02182-0702-00202-00202-00000-XMIT370
RECVBLK  TITLE 'Assemble segments into data block'
*
* Copyright 2001, 2002 James M. Morrison
*
*----------------------------------------------------------------------
* Things to do:
*----------------------------------------------------------------------
         U#SET ,
*----------------------------------------------------------------------
* Function: Reads (via RECVGET calls) sufficient data segments to
*           reconstruct a data block
*
* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*
*
*         R0  =  buffer length
*         R1  =  buffer address
*
* Exit:   R15 =  Return code
*
*                0 = buffer contains data block
*
*                    R0 = length of block
*                    R1 = address of block
*
*                4 = encountered control segment
*
*                    R0 = 0
*                    R1 = address of control segment
*
* Abends: U0016  internal error - R14 useful
*         U0017  incomplete data block (XMIT probably damaged)
*         U0018  EOF encountered
*         U0019  buffer overflow (XMIT probably damaged)
*
* Notes:  Caller is responsible for supplying BDW & RDW.
*         The XMIT file doesn't contain them, and we don't
*         return them.
*
* Debug:  1  entry/exit; exit shows RC
*         2  exit shows block length
*            control segment snapped
*         3  exit shows data block
*----------------------------------------------------------------------
* R2     constant; SEGL - (R2) = # data bytes
* R3     constant; SEGL - (R3) = # data bytes minus one (for EX)
* R4     @ buffer slot to receive segment
* R5     buffer length remaining
* R6     block length
* R7     internal linkage
* R8     SEG
* R9     SEGL - (R3) = segment data EX length
* R10    # segment data bytes
* R11    XMTWA
* R12    base reg
* R13    savearea/workarea
*----------------------------------------------------------------------
         TITLE ' '
*----------------------------------------------------------------------
RECVBLK  UPROC L=L$SA,ID=RBLK,WA=SAVEAREA
         EJECT ,
*----------------------------------------------------------------------
*  Initialize
*----------------------------------------------------------------------
INIT     DS    0H
         BALR  R14,0
         LTR   R5,R0                        buffer length
         BZ    DIE
*
         BALR  R14,0
         LTR   R4,R1                        buffer address
         BZ    DIE
*
         UDIAG 1,'RECVBLK entered'
*
         ST    R4,SARADDR                   set R1 return
         LA    R2,SEGBUF-SEG                # seg overhead bytes
         LA    R3,1(,R2)                    use to get EX length
         SLR   R6,R6                        accumulate block length
         SLR   R9,R9                        only need to clear once
         BALR  R7,0                         faster looping
         EJECT ,
*----------------------------------------------------------------------
* Call RECVGET until block complete
*----------------------------------------------------------------------
GETSEG   DS    0H
         UCALL RECVGET                      retrieve segment (R1 = @)
         LTR   R8,R1                        got one?
         BZ    ENDOFILE                     shouldn't happen
*
         USING XMITSEG,R8
         TM    SEGFLG,SEG$C                 control segment?
         BO    HVCTL
*
HVDATA   DS    0H                           have data segment
         OI    SAFLG1,SA1DATA               saw data segment
         IC    R9,SEGL                      segment length
         LR    R10,R9
*
         SR    R10,R2                       R10 = # data bytes
         SR    R5,R10                       buffer overflow?
         BM    DIEBUF
*
         SR    R9,R3                        l' segment data minus one
         EX    R9,COPYSEG
         LA    R4,0(R10,R4)                 @ next buffer slot
         AR    R6,R10                       accumulate block length
         TM    SEGFLG,SEG$L                 last segment of block?
         BO    SEGFINI
*
         BR    R7                           continue building block
*
COPYSEG  MVC   0(*-*,R4),SEGBUF             copy segment to buffer
         EJECT ,
*----------------------------------------------------------------------
*  Internal error - invalid parms
*----------------------------------------------------------------------
DIE      UABEND SAREASON                    R14 useful
*----------------------------------------------------------------------
*  Block incomplete (truncated), no SEG$L before control segment
*----------------------------------------------------------------------
BLKTRUNC DS    0H
         STM   R0,R15,XMTREGS
         ULOG  'RECVBLK incomplete data block'
         MVI   SAREASON,17
         B     DIE
*----------------------------------------------------------------------
* End Of File
*----------------------------------------------------------------------
ENDOFILE DS    0H
         ULOG  'RECVBLK EOF'
         MVI   SAREASON,17
         B     DIE
*----------------------------------------------------------------------
*  Buffer overflow
*----------------------------------------------------------------------
DIEBUF   DS    0H
         STM   R0,R15,XMTREGS
         ULOG  'RECVBLK buffer overflow'
         USNAP 'RECVBLK buffer contents',*SARADDR,(R6)
         MVI   SAREASON,19
         B     DIE
*----------------------------------------------------------------------
*  Encountered control segment
*----------------------------------------------------------------------
HVCTL    DS    0H
         TM    SAFLG1,SA1DATA               saw DATA segment(s)?
         BO    BLKTRUNC
*
         ST    R8,SARADDR                   return ctl seg addr
         SLR   R3,R3
         IC    R3,SEGL
         UDIAG 2,'RECVBLK encountered control segment',(R8),(R3)
         LM    R15,R0,=A(4,0)
         STM   R15,R0,SARET
         B     EXIT
         EJECT ,
*----------------------------------------------------------------------
*  Segment complete
*----------------------------------------------------------------------
*                                           INIT set R1 return
SEGFINI  DS    0H                           PROC cleared SARC
         ST    R6,SARLEN                    return block length
         UPSR  2,'RECVBLK block length',(R6)
         UDIAG 3,'RECVBLK block',*SARADDR,(R6)
*----------------------------------------------------------------------
*  Return to caller
*----------------------------------------------------------------------
EXIT     DS    0H                           return values set
         UPSR  1,'RECVBLK exited rc',*SARC
         LM    R15,R1,SARET
         UPEND R0=PASS,R1=PASS              return R0, R1, R15
*----------------------------------------------------------------------
*  Data areas
*----------------------------------------------------------------------
         LTORG ,
         EJECT ,
*----------------------------------------------------------------------
*  Savearea/workarea
*----------------------------------------------------------------------
SAVEAREA DSECT ,
SA       DS    18F                     savearea for called code
*
SAFLG1   DS    X                       status flag
SA1DATA  EQU   128                     saw DATA segment
*
SAREASON DS    X                       UABEND reason code
*
SARET    DS    0F,0XL12
SARC     DS    F                       return code
SARLEN   DS    F                       block length
SARADDR  DS    A                       block address
*
         DS    0D
L$SA     EQU   *-SAVEAREA
         EJECT ,
         PRINT NOGEN
         WAXMT FUNC=RECV
         DXMITSEG ,
         PRINT GEN
*
RECVBLK  UFINI DXDRGET,L$SA
         END   ,
./ ADD NAME=RECVCTL  0100-02182-02182-0702-00694-00694-00000-XMIT370
*
*  Copyright 2001, 2002 James M. Morrison
*
*----------------------------------------------------------------------
*
*  Things to do:
*
*  2) research INMFFM vs. INMFM (CMS?)
*  4) add special-case code for handling DSN key - CLVE
*     (assuming we're going to do anything wth the DSN, like
*     display it)
*  5) PAIRCHAR - verify target field length before copy
*
*----------------------------------------------------------------------
*
*  XMIT control segment key table definition macro
*
         MACRO
&LABEL   KEY   &KEY,&TYPE,&TEXT,&SAVE=SAV,&FLAG=0
         LCLA  &L
         LCLC  &FIELD,&NDX,&SAV
&NDX     SETC  '&SYSNDX'
&L       SETA  K'&TEXT-1
&L       SETA  (&L/2)*2
&FIELD   SETC  '0'
&SAV     SETC  '0'
         AIF   ('&SAVE' EQ '').GEN
&FIELD   SETC  '&SAVE.&KEY'
&SAV     SETC  'L''&FIELD-1'
.GEN     ANOP
&LABEL   IM#SECT LABEL
TE&NDX   DC    AL2(INM&KEY)            XMIT control segment key
         DC    AL1(TAB$&TYPE)          key flag/count-length-value type
         DC    AL1(TL&NDX)             length of this TAB entry
         DC    S(&FIELD)               zero or save field Bddd
         DC    AL1(&FLAG)              special processing flag
         DC    AL1(&SAV)               SAVxxxxx field length minus one
         DC    CL&L.&TEXT
TL&NDX   EQU   *-TE&NDX
         MEND
*
RECVCTL  TITLE 'Handle XMIT Control segments'
*----------------------------------------------------------------------
         U#SET ,
*----------------------------------------------------------------------
* Function: Read the XMIT control segments, decide which to call:
*
*           a) RECVSEQ to handle sequential input datasets
*
*           b) RECVPDS to handle partitioned input datasets
*
*           If neither of the above, complain & abandon execution.
*           Depending on debug level, this code may also display
*           information about the XMIT control segments, such as
*           key, count, and length/value pairs.
*
* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*
*
*         R0  =
*         R1  =
*
* Exit:   R15 = return code
*         R15 = 00 success
*
* Abends: yes
*
* Notes:
*
* Debug:
*         2 - show status
*         3 - show control segment
*         4 - show control segment details
*         6 - show savearea at exit
*         7 - show sasavptr
*             show TAB entry
*         8 - show saved-hex value
*----------------------------------------------------------------------
* R2     scratch
* R3     current key
* R4     ptr to current key/count/length/value
* R5     scratch, TAB scan index
* R6     scratch, TAB scan entry length
* R7     scratch, TAB scan limit
* R8     segment length
* R9     segment ptr
* R10    scratch
* R11    XMTWA
* R12    base reg
* R13    savearea
*----------------------------------------------------------------------
         TITLE ' '
*----------------------------------------------------------------------
RECVCTL  UPROC L=L$SA,ID=RCTL,WA=SAVEAREA
         UDIAG 1,'RECVCTL entered'
         EJECT ,
*----------------------------------------------------------------------
*  Initialize
*----------------------------------------------------------------------
*
*  Activate the dummy CS2, for saved fields in TAB which can occur
*  before we've seen an INMR02 (but are based in the CS2s).
*  For instance, INMLRECL typically appears in INMR01s as well as
*  INMR02s.
*
         LA     R0,SACS2X                   dummy CS2
         ST     R0,SA@CS2
*----------------------------------------------------------------------
*  Read control segments
*----------------------------------------------------------------------
GETSEG   DS    0H
         TM    SAFLG1,SA1QCS                queued control seg?
         BNO   CALLGS
*
DQSEG    DS    0H
         MVI   SAREASON,10
         L     R9,SA@QCS                    dequeue ctl seg
         USING XMITSEG,R9
         SLR   R14,R14
         ICM   R14,1,SEGL
         BZ    DIE
*
         UDIAG 2,'RECVCTL dequeue cseg',(R9),(R14)
         NI    SAFLG1,255-SA1QCS
         B     CKSEG
*
CALLGS   DS    0H
         UCALL RECVGET                      retrieve XMIT segment
         LTR   R9,R1                        returned segment or zero
         BZ    EOF
*
CKSEG    DS    0H
         MVI   SAREASON,1
         TM    SEGFLG,SEG$C                 control segment?
         BNO   DIE                          we should never see data
         EJECT ,
*----------------------------------------------------------------------
*  We have an XMIT control segment
*----------------------------------------------------------------------
HAVESEG  DS    0H
         SLR   R8,R8
         IC    R8,SEGL                 segment length
*
         UDIAG 3,'RECVCTL control segment',(R9),(R8)
*
         CLC   SEGCTLNM,=C'INMR02'
         BNE   DISPLAY
*
*  Decide which INMR02 this is, and set up the correct CS2
*
*  XMIT files are built by TRANSMIT (or XMIT370), and the order
*  of the INMR02s reflects the sequence of operations that TRANSMIT
*  performed.  For an IEBCOPY unloaded PDS, the IEBCOPY INMR02 is
*  first, then the INMCOPY INMR02.  When performing the RECEIVE
*  function we need to reverse the order (INMCOPY first, then
*  IEBCOPY).  We could queue up the INMR02s, but there's only two
*  so that's more trouble than necessary.  Rather, we stuff all the
*  saved fields in the associated CS2 area.  The SA@CS2 field
*  determines which of those CS2s is to be current.
*
*  I might have to re-examine this logic once I get to the
*  point of supporting embedded messages (TERM flag), but I'm
*  not there yet and have lots to do before then
*
         OI    SAFLG1,SA1CS2           INMR02 seen
         L     R15,SA@CS2              current CS2 (might be dummy)
         LA    R15,L$CS2(,R15)         @ next CS2
         LA    R0,SACS2BAD             limit
         CR    R15,R0                  too many INMR02s?
         BL    NEWCS2
*
         UDIAG 0,'RECVCTL too many INMR02s'
         MVI   SAREASON,2
         B     DIE
*
NEWCS2   DS    0H
         ST    R15,SA@CS2
         USING CS2,R15
*
*  Retain # files in XMIT from INMR02
*
         SLR   R0,R0
         ICM   R0,15,SEGC2NUM          # files present in XMIT
         ST    R0,CS2#FILE
         DROP  R15
         UPSR  2,'RECVCTL INMR02: files present in XMIT',(R0)
         EJECT ,
*----------------------------------------------------------------------
*  Print the details header line
*----------------------------------------------------------------------
DISPLAY  DS    0H
         UDIAG 4,'RECVCTL control segment details'
*
         MVI   SAMSG,C' '
         MVC   SAMSG+1(L$SAMSG-1),SAMSG     clear message area
         MVC   SAMSG(3),=C'<4>'
         MVC   SATYPE,=C'TYPE'
         MVC   SAKEY,=C'KEY '
         MVC   SACOUNT-1(5),=C'COUNT'
         MVC   SALEN,=C'LEN '
         MVC   SAVALUE(5),=C'VALUE'
         MVC   SATEXT(11),=C'DESCRIPTION'
         BAL   R14,MSGOUT                   label output to follow
         EJECT ,
*----------------------------------------------------------------------
*  Examine each key in the control segment
*----------------------------------------------------------------------
DETAILS  DS    0H
         LA    R4,SEGCKEYS                  standard 1st key offset
         CLC   SEGCTLNM,=C'INMR02'          non-standard?
         BNE   *+8
         LA    R4,SEGC2KEY                  INMR02 1st key offset
*
*  R4 @ key, R8 segment length
*
NEXTKEY  DS    0H
         LA    R0,SEG(R8)                   @ end of segment
         CR    R4,R0
         BNL   FINSEG                       exhausted keys, finish seg
*
         SLR   R3,R3
         ICM   R3,3,0(R4)                   grab key
         LM    R5,R7,=A(TABLE,0,TABEND-1)   set TAB scan regs
         USING TAB,R5
*
*  Scan TAB for matching key
*
SCAN     DS    0H
         IC    R6,TABELEN                   get TAB entry length
         CLM   R3,3,TABKEY                  found key?
         BE    FOUND
*
         LA    R5,0(R6,R5)                  @ next entry
         CR    R5,R7                        fell off end?
         BL    SCAN
*
         UPSR  0,'RECVCTL unrecognized key (hex) value',(R3)
         UPSR  0,'RECVCTL unrecognized key address',(R4)
         MVI   SAREASON,3
SNAPDIE  UDIAG 0,'RECVCTL control segment',(R9),(R8)
         B     DIE
         EJECT ,
*----------------------------------------------------------------------
*  Found key, issue descriptive message(s) based on key type
*----------------------------------------------------------------------
COPYTEXT MVC   SATEXT(*-*),TABTEXT          copy text to display line
*
FOUND    DS    0H
         SLR   R15,R15
         IC    R15,TABELEN
         UDIAG 7,'RECVCTL TAB entry',(R5),(R15)
*
         ST    R5,SATABENT                  save @ entry for PAIR code
         LA    R0,L$TABOVH                  TAB entry overhead
         SR    R6,R0                        R6 = text length
         MVI   SAMSG,C' '
         MVC   SAMSG+1(L$SAMSG-1),SAMSG     clear message area
         MVC   SAMSG(3),=C'<4>'
*
         LR    R0,R3
         LA    R1,SAWORK
         UCALL UTILHEX
         MVC   SAKEY,SAWORK+4
         BCTR  R6,0
         EX    R6,COPYTEXT
         LA    R4,L$CKEY(,R4)               bump to next key/count
*
*  Set up pointer to save field for ease of handling in the PAIRS code
*
*  We build a LA instruction in SAINSTR (X'4110ssss') from the
*  S-con in the current TAB entry, then execute it to point R1
*  at the field which will be used to save the current value.
*  We use an S-con, since we only really care about the INMR02 values;
*  other values are either ignored or saved somewhere in SAVEAREA.
*
         LA    R1,SABOGUS                   field for unsaved fields
         CLC   TABSCON,=AL2(0)              is this one?
         BE    NULLSAVE
*
*  Avoid wiping out CS2s with INMR03 data by always pointing
*  saved fields to SABOGUS
*
         CLC   SEGCTLNM,=C'INMR03'
         BE    NULLSAVE
*
         MVC   SAINSTR(2),=X'4110'          initialize dynamic instr
         MVC   SAINSTR+2(2),TABSCON         add S-con
         MVI   SAREASON,4
         ICM   R15,15,SA@CS2                select current CS2
         BZ    DIE
*
*  The following instruction requires R15 point at (some) CS2
*
         EX    R0,SAINSTR                   R1 @ save field
*
NULLSAVE DS    0H
         ST    R1,SASAVPTR
         UPSR  7,'RECVCTL sasavptr',(R1)
         EJECT ,
*----------------------------------------------------------------------
*  Examine key type
*----------------------------------------------------------------------
         CLI   TABTYPE,TAB$FLAG             flag only?
         BNE   CKCLV
*
*  Flag only
*
         L     R1,SASAVPTR                  @ save field
         MVI   0(R1),C'Y'                   flag set
*
         MVC   SATYPE,=C'FLAG'
         BAL   R14,MSGOUT                   display message
         B     NEXTKEY
*
*  Common setup for either CLVE or CLVH
*
CKCLV    DS    0H
         SLR   R0,R0
         ICM   R0,3,0(R4)
         ST    R0,SAXCOUNT                  save count for PAIR code
         LA    R1,SAWORK
         UCALL UTILHEX
         MVC   SACOUNT,SAWORK+4
         LA    R4,L$CCOUNT(,R4)             bump to length/value pairs
*
         CLI   TABTYPE,TAB$CLVE             EBCDIC?
         BNE   CKCLVH
*
*  Key, Count, (Length,Value) pairs - EBCDIC
*
CLVE     DS    0H
         MVC   SATYPE,=C'CLVE'
         B     PAIRS
*
CKCLVH   DS    0H
         MVI   SAREASON,5
         CLI   TABTYPE,TAB$CLVH             HEX?
         BNE   DIE
*
*  Key, Count, (Length,Value) pairs - HEX
*
         MVC   SATYPE,=C'CLVH'
         EJECT ,
*----------------------------------------------------------------------
*  Handle length/value pairs (R4 @ first length, SAXCOUNT = # pairs)
*----------------------------------------------------------------------
PAIRS    DS    0H
         BAL   R14,MSGOUT
         ICM   R2,15,SAXCOUNT               # pairs
         BNZ   PAIRLOOP
*
         UPSR  0,'RECVCTL key count = zero; key (hex) value',(R3)
         MVI   SAREASON,6
         B     SNAPDIE
*
PAIRLOOP DS    0H
         SLR   R0,R0
         ICM   R0,3,0(R4)                   grab length
         LR    R10,R0                       save length in safe reg
         LA    R1,SAWORK
         UCALL UTILHEX
         MVC   SALEN,SAWORK+4
         LA    R4,L$CLEN(,R4)               point at value
*
         CLI   TABTYPE,TAB$CLVE             EBCDIC?
         BNE   PAIRHEX
         EJECT ,
*
*  EBCDIC - R4 @ value, R10 = value length
*
PAIRCHAR DS    0H
         L     R15,SASAVPTR                 @ save field
*
*  set up initial blanks in char fields, so that short values
*  (like CL7 ddname) are right blank padded after save
*
         MVI   0(R15),C' '                  blank 1st save char
         SLR   R14,R14
         ICM   R14,1,TABSAVL                L' save field minus one
         BZ    PCBLNKD                      only one char, already done
         BCTR  R14,0
         EX    R14,BLNKSAVE                 propagate blank
PCBLNKD  DS    0H
*
*  set up initial blanks in char fields
*
         BCTR  R10,0
         EX    R10,COPYVALU                 copy value to display line
         EX    R10,COPYSAVE                 copy value to save field
         BAL   R14,MSGOUT                   display message
         LA    R4,1(R10,R4)                 at next key/length
         BCT   R2,PAIRLOOP
         B     NEXTKEY
*
COPYVALU MVC   SAVALUE(*-*),0(R4)
COPYSAVE MVC   0(*-*,R15),0(R4)
BLNKSAVE MVC   1(*-*,R15),0(R15)
         EJECT ,
*
*  HEX - R4 @ value, R10 = value length
*
PAIRHEX  DS    0H
         MVI   SAREASON,7
         C     R10,=F'4'                    max supported HEX length
         BH    DIE
*
*  Copy hex value to save field
*
         SLL   R10,2
         L     R1,SASAVPTR
         SLR   R0,R0
         EX    R0,RETRIEVE-4(R10)
         STCM  R0,15,0(R1)                  store saved field
         SRL   R10,2
         UPSR  8,'RECVCTL saved-hex',(R0)
*
*  display hex value, one char at a time
*
         LA    R5,SAVALUE                   first hex char slot
         LA    R6,SALIMIT                   past last valid msg char
         LA    R7,0(R10,R4)                 @ next key/length
*
PHLOOP   DS    0H
         CR    R5,R6                        too much data?
         BNL   PHFINI                       yes, bail early
*
         IC    R0,0(R4)                     grab hex value byte
         LA    R1,SAWORK
         UCALL UTILHEX
         MVC   0(2,R5),SAWORK+6
         LA    R5,2(,R5)
         LA    R4,1(,R4)
         BCT   R10,PHLOOP
*
PHFINI   DS    0H
         BAL   R14,MSGOUT
         LR    R4,R7                        new key/length ptr
         BCT   R2,PAIRLOOP
         B     NEXTKEY
*
RETRIEVE ICM   R0,1,0(R4)
         ICM   R0,3,0(R4)
         ICM   R0,7,0(R4)
         ICM   R0,15,0(R4)
*
*  Internal error
*
DIE      UABEND SAREASON                    internal error
*----------------------------------------------------------------------
*  MSGOUT subroutine, returns via R14
*----------------------------------------------------------------------
*
*  This code should only be called to display debug level 4 messages
*
MSGOUT   DS    0H
         ST    R14,SASUB14                  save return reg
         UDIAG 4,SKIP=MSGCLEAR
         ULOG  SAMSG,L$SAMSG                display message
MSGCLEAR DS    0H
         MVI   SAMSG,C' '
         MVC   SAMSG+1(L$SAMSG-1),SAMSG     clear message area
         MVC   SAMSG(3),=C'<4>'
         L     R14,SASUB14                  restore return ret
         BR    R14                          return
         EJECT ,
*----------------------------------------------------------------------
*  Control segment parse complete
*----------------------------------------------------------------------
FINSEG   DS    0H
         CLC   SEGCTLNM,=C'INMR06'
         BNE   FSCK03
*
         OI    SAFLG1,SA1MR6                INMR06 (trailer) seen
         B     GETSEG                       let RECVGET close XMITIN
*
FSCK03   DS    0H
         CLC   SEGCTLNM,=C'INMR03'
         BNE   GETSEG
*
         TM    SAFLG1,SA1CS2                pending CS2(s)?
         BO    FSCS2
*
         ULOG  'RECVCTL ERROR: invalid XMIT'
         ULOG  'RECVCTL ERROR: INMR03, but no INMR02(s)'
         MVI   SAREASON,8
         B     DIE
*
*  Pop each CS2 off the stack, call RECVUTIL to handle
*
FSCS2    DS    0H
         L     R1,SA@CS2                    current CS2
*
FSUTIL   DS    0H
         UCALL RECVUTIL                     handle INMR02 utility
         LTR   R15,R15
         BZ    FSOK
*
         MVI   SAREASON,9
         C     R15,=F'4'                    returned ctl seg?
         BNE   DIE
*
         MVI   SAREASON,11                  error if SEGL=0
         ST    R1,SA@QCS                    queue control seg
         SLR   R14,R14
         ICM   R14,1,SEGL-SEG(R1)
         BZ    DIE
         OI    SAFLG1,SA1QCS
         UDIAG 2,'RECVCTL RECVUTIL returned ctl seg',(R1),(R14)
*
FSOK     DS    0H
         L     R1,SA@CS2
         XC    0(L$CS2,R1),0(R1)            clear processed CS2
         LA    R0,L$CS2
         SR    R1,R0                        unstack CS2
         ST    R1,SA@CS2                    possible CS2 re-use
         LA    R0,SACS2X                    dummy CS2
         CR    R1,R0                        another CS2?
         BH    FSUTIL                       yes, go handle it
*
         UDIAG 2,'RECVCTL exhausted CS2s'
         NI    SAFLG1,255-SA1CS2            no pending CS2s
         B     GETSEG
*----------------------------------------------------------------------
*  Return to caller
*----------------------------------------------------------------------
EOF      DS    0H
         UDIAG 2,'RECVCTL EOF'
         TM    SAFLG1,SA1MR6                saw trailer?
         BO    EXIT
*
         ULOG  'RECVCTL WARNING: INMR06 (trailer) missing'
         ULOG  'RECVCTL WARNING: XMIT file may be damaged'
*
EXIT     DS    0H
         UDIAG 6,'RECVCTL savearea at exit',(R13),SACS2X
         UDIAG 1,'RECVCTL exited'
         UPEND RC=0
         EJECT ,
*----------------------------------------------------------------------
*  XMIT control segment key attributes (see TAB DSECT)
*----------------------------------------------------------------------
         PUSH  USING
         USING CS2,R15
TABLE    DS    0D
         KEY   DDNAM,CLVE,'DDNAME'
         KEY   DSNAM,CLVE,'DSN',FLAG=TAB1DSN
         KEY   ERRCD,CLVH,'receive error code'
         KEY   FACK,CLVH,'acknowledgement request'
         KEY   FNODE,CLVE,'origin node name'
         KEY   FTIME,CLVE,'origin time stamp'
         KEY   FUID,CLVE,'origin userid'
         KEY   FVERS,CLVE,'origin version number'
         KEY   NUMF,CLVH,'number of files'
         KEY   RECCT,CLVH,'transmitted record count'
         KEY   SECND,CLVH,'secondary space qty'
         KEY   TNODE,CLVE,'target node name'
         KEY   TTIME,CLVE,'destination time stamp'
         KEY   TUID,CLVE,'target userid'
         KEY   TYPE,CLVH,'data set type'
*
         KEY   USERP,CLVE,'user parm string',SAVE=
*
         KEY   BLKSZ,CLVH,'BLKSIZE',SAVE=CS2
         KEY   DIR,CLVH,'directory blocks',SAVE=CS2
         KEY   CREAT,CLVH,'creation date',SAVE=CS2
         KEY   DSORG,CLVH,'DSORG',SAVE=CS2
         KEY   EXPDT,CLVH,'expiration date',SAVE=CS2
         KEY   LCHG,CLVH,'last changed date',SAVE=CS2
         KEY   LRECL,CLVH,'LRECL',SAVE=CS2
         KEY   LREF,CLVH,'last referenced date',SAVE=CS2
         KEY   MEMBR,CLVE,'member',SAVE=CS2
         KEY   RECFM,CLVH,'RECFM',SAVE=CS2
         KEY   SIZE,CLVH,'approx file size (bytes)',SAVE=CS2
         KEY   TERM,FLAG,'terminal alloc (msg)',SAVE=CS2
         KEY   UTILN,CLVE,'utility name',SAVE=CS2
*
*  I've not seen an example of the next key, so the following is
*  a great big guess.
*
         KEY   FFM,CLVE,'filemode number (CMS)',SAVE=
TABEND   DS    0X
         POP   USING
*
         LTORG ,
         EJECT ,
*----------------------------------------------------------------------
*  XMIT control segment key attributes table
*----------------------------------------------------------------------
TAB      DSECT ,
TABKEY   DS    XL2      INMRxxxx key
*
TABTYPE  DS    X        key type:
TAB$CLVH EQU   1             key, count, (length,value) pairs - hex
TAB$CLVE EQU   2             key, count, (length,value) pairs - EBCDIC
TAB$FLAG EQU   3             flag only (no count, length, value)
*
TABELEN  DS    X        length of complete TAB entry (including text)
*
TABSCON  DS    XL2      zero (don't save) or S-con for save field
*                       valid base regs: R13 (SAVEAREA), R15 (CS2)
*
TABFLG1  DS    X        flags for PAIR code
TAB1DSN  EQU   128           special DSN handling
*
TABSAVL  DS    X        length of save field minus one
*
TABTEXT  DS    0C       description of related key
*
L$TABOVH EQU   *-TAB    TAB entry overhead length
*
         EJECT ,
         DRCS2 ,
         EJECT ,
*----------------------------------------------------------------------
*  Savearea/workarea
*----------------------------------------------------------------------
SAVEAREA DSECT ,
SA       DS    18F
*
SAFLG1   DS    X             status flag
SA1MR6   EQU   128                INMR06 seen (trailer)
SA1CS2   EQU   64                 INMR02 seen
SA1QCS   EQU   32                 control seg queued
*
SAREASON DS    X             UABEND reason code
*
SAWORK   DS    D             hex conversion return
SAXCOUNT DS    F             hex count
SASAVPTR DS    A             zero or ptr to key value save field
SATABENT DS    A             ptr to TAB entry associated with key
SAINSTR  DS    F             dynamically built instruction
SA@CS2   DS    A             pointer to current INMR02 save (CS2)
SASUB14  DS    A             low-level subroutine return reg
SA@QCS   DS    A             addr of queued control seg
*
*  dynamically constructed message giving segment details
*
SAMSG    DS    0C
         DS    CL4
SATYPE   DS    CL4
         DS    CL4
SAKEY    DS    CL4
         DS    CL2
SACOUNT  DS    CL4
         DS    CL2
SALEN    DS    CL4
         DS    CL2
SAVALUE  DS    CL20
         DS    CL2
SATEXT   DS    CL30
SALIMIT  DS    0C                      last valid message char
L$SAMSG  EQU   *-SAMSG
         DS    0D
SABOGUS  DS    CL256                   protection from runaway SAVALUEs
*                                      and slot for unsaved fields
*
*  Save fields
*
         DS    0D
SAVDSNAM DS    CL44
SAVTNODE DS    CL8
SAVTUID  DS    CL8
SAVFNODE DS    CL8
SAVFUID  DS    CL8
SAVFVERS DS    CL8
SAVFTIME DS    CL16
SAVTTIME DS    CL16
SAVNUMF  DS    F
SAVFACK  DS    F
SAVERRCD DS    F
SAVRECCT DS    F
SAVDDNAM DS    CL8
SAVSECND DS    F
SAVTYPE  DS    F
*
*  CS2 stack (saved INMR02 info)
*
SACS2    DS    0D
SACS2X   DS    CL(L$CS2)     CS2 - dummy
SACS2A   DS    CL(L$CS2)     CS2 for 1st INMR02 (usually IEBCOPY)
SACS2B   DS    CL(L$CS2)     CS2 for 2nd INMR02 (usually INMCOPY)
SACS2C   DS    CL(L$CS2)     CS2 for 3rd INMR02 (future plans)
SACS2BAD EQU   *             too many CS2s if past here
*
         DS    0D
L$SA     EQU   *-SAVEAREA
         EJECT ,
         PRINT NOGEN
         WAXMT FUNC=RECV
*        EJECT ,
         DXMITSEG ,
*        EJECT ,
         PRINT ON,GEN
RECVCTL  UFINI DXDRCTL,L$SA
         END   ,
./ ADD NAME=RECVGET  0100-02182-02182-0702-00307-00307-00000-XMIT370
RECVGET  TITLE 'Get XMIT segment'
*
* Copyright 2001, 2002 James M. Morrison
*
*----------------------------------------------------------------------
* Things to do:
*----------------------------------------------------------------------
         U#SET ,
*----------------------------------------------------------------------
* Function: Returns a complete XMIT segment read from XMITIN, or EOF
*
*           XMITIN DCB is opened on the first call,
*           closed on EOF.
*
* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*
*
*         R0  =
*         R1  =
*
* Exit:   R1  =  Address of segment (XMITSEG)
*                upon EOF, R1 = 0
*
* Abends: U0001 XMITIN open failed
*         U0002 internal error (R0 = code)
*
* Notes: RGSWA contains a buffer holding residual data, which
*        represents data not yet returned to the caller, to be
*        saved for a later call to RECVGET.
*----------------------------------------------------------------------
* R2     RGSWA (our workarea)
* R3     DCB
* R4     XMITSEG (not strictly necessary, only covers one instruction)
*
* R5     pointer to residual data within RGSBUF
* R6     RGSROFF   - offset to residual data within RGSBUF
*
* R7     SEGL      - segment length for segment being built in RGSSEG
* R8     scratch, pointer within RGSSEG where residual data is appended
* R9     scratch, RGSSL    - # segment bytes currently in RGSSEG
*
* R10    scratch (careful)
* R11    XMTWA
* R12    base reg
* R13    savearea/workarea
*----------------------------------------------------------------------
L$REC    EQU   80                           XMITIN LRECL
INTE$1   EQU   1                            internal errors
INTE$2   EQU   2
INTE$3   EQU   3
INTE$4   EQU   4
         TITLE ' '
RECVGET  UPROC L=L$SA,ID=RGET,WA=SAVEAREA
         UDIAG 1,'RECVGET entered'
*
         ICM   R2,15,XMT@GS                 find our workarea
         BNZ   NORMAL                       already init'd, go
*----------------------------------------------------------------------
*  Initialize RGSWA
*----------------------------------------------------------------------
         UDIAG 2,'RECVGET: initializing RGSWA'
         LA    R2,XMTRGSWA
         USING RGSWA,R2
         UZERO (R2),L$RGSWA                 clear storage
         ST    R2,XMT@GS                    save ptr to our workarea
*----------------------------------------------------------------------
*  Initialize - null segment
*----------------------------------------------------------------------
NORMAL   DS    0H
         LA    R4,RGSSEG                    segment being built
         USING XMITSEG,R4
         NI    RGSFLG1,255-RGS1FINI         no segment in RGSSEG
         SLR   R0,R0
         STH   R0,RGSSL                     zero bytes in segment
         XC    RGSSEG,RGSSEG                clear segment
*----------------------------------------------------------------------
*  Check for call past EOF
*----------------------------------------------------------------------
         TM    RGSFLG2,RGS2EOF              already hit EOF?
         BNO   CKDCB
         UDIAG 2,'RECVGET EOF at entry'
         B     EXIT
*----------------------------------------------------------------------
*  Open XMITIN
*----------------------------------------------------------------------
CKDCB    DS    0H
         LA    R3,RGSDCB
         USING IHADCB,R3
         TM    DCBOFLG1,DCBOFOPN            dcb open?
         BO    DCBOPEN
*
         UDIAG 2,'RECVGET: opening XMITIN'
         MVC   RGSDCB(L$DCB),MODLDCB        copy model DCB macro
         MVC   RGSOPN(L$OPN),MODLOPN        copy model OPEN macro
         OPEN  ((R3),INPUT),MF=(E,RGSOPN)
         TM    DCBOFLG1,DCBOFOPN            opened?
         BO    DCBOPEN
*
         ULOG  'RECVGET: XMITIN DCB open error'
         UDIAG 0,'RECVGET: RGSWA',(R2),L$RGSWA
         MVI   SAREASON,1                   XMITIN DCB didn't open
         B     UABEND
*
DCBOPEN  DS    0H
         EJECT ,
*----------------------------------------------------------------------
*  Main loop - If no more residual data, read
*----------------------------------------------------------------------
*
*  Note it might be possible for the residual data to contain more
*  than one segment (or portions thereof), so we may leave RECVGET
*  with residual data still pending.
*
RESUME   DS    0H
         TM    RGSFLG1,RGS1FINI             seg complete?
         BO    EXIT                         yes, return to caller
*
         TM    RGSFLG1,RGS1RES              residual data?
         BNO   READ                         no, need to get data
         EJECT ,
*----------------------------------------------------------------------
*  Copy residual data to segment return area (RGSSEG).
*----------------------------------------------------------------------
COPY     DS    0H
         LH    R6,RGSROFF                   offset to residual data
         LA    R5,RGSBUF(R6)                @ residual data
*
         LA    R0,INTE$1                    internal error #
         LA    R10,L$REC                    XMITIN LRECL
         SR    R10,R6                       # residual data bytes
         BNP   DIE
*
         LH    R8,RGSSL                     # bytes in RGSSEG already
         LR    R9,R8
         AR    R9,R10
         LA    R8,RGSSEG(R8)                @ next seg byte to append
*
         UDIAG 9,'RECVGET: <COPY> regs',XMTREGS,16*4,REGS=YES
*
         BCTR  R10,0
         EX    R10,COPYRES                  copy residual to segment
         LA    R10,1(,R10)
         STH   R9,RGSSL                     new # bytes in RGSSEG
*
*  It is now safe to examine SEGL, since the above code copied at
*  least one byte to RGSSEG, so no matter what else, SEGL is valid.
*
         SLR   R7,R7
         IC    R7,SEGL                 segment length
*
         UDIAG 9,'RECVGET: <COPY> seg.segl',RGSSEG,(R7)
         B     CKSEG
*
COPYRES  MVC   0(*-*,R8),0(R5)
         EJECT ,
*----------------------------------------------------------------------
*  Determine if the segment is now complete
*----------------------------------------------------------------------
CKSEG    DS    0H
         CR    R7,R9                   seglen : bytes in seg
         BL    SCR                     segment   complete,    residual
         BE    SCNR                    segment   complete, no residual
*
*  The segment is not yet complete, and we've consumed all of
*  the residual data; get some more
*
SINR     DS    0H                           seg incomplete, no residual
         NI    RGSFLG1,255-RGS1RES
         SLR   R6,R6
         STH   R6,RGSROFF
         XC    RGSBUF,RGSBUF
         UDIAG 5,'RECVGET SINR',XMTREGS,16*4,REGS=YES
         B     READ                         finish segment
*
*  The segment is now complete, but ... there's some residual
*  data we need to reclaim from the RGSSEG
*
SCR      DS    0H                           segment complete, residual
         UDIAG 5,'RECVGET SCR1',XMTREGS,16*4,REGS=YES
         SR    R9,R7                   # bytes residual data remaining
         OI    RGSFLG1,RGS1FINI+RGS1RES         seg complete
         LA    R6,L$REC
         SR    R6,R9                        new residual data offset
         STH   R6,RGSROFF                   new resoff
         UDIAG 5,'RECVGET SCR2',XMTREGS,16*4,REGS=YES
         B     EXIT
*
*  The segment is now complete, and exactly consumed the residual
*  data
*
SCNR     DS    0H                           seg complete, no residual
         OI    RGSFLG1,RGS1FINI                 seg complete
         NI    RGSFLG1,255-RGS1RES              no residual
         SLR   R6,R6
         STH   R6,RGSROFF
         XC    RGSBUF,RGSBUF
         UDIAG 5,'RECVGET SCNR',XMTREGS,16*4,REGS=YES
         B     EXIT
*
DIE      STM   R0,R15,XMTREGS
         UPSR  0,'RECVGET internal error',(R0)
         UDIAG 0,'RECVGET regs',XMTREGS,16*4
         MVI   SAREASON,2
UABEND   UABEND SAREASON
*
         EJECT ,
*----------------------------------------------------------------------
*  Read input record from XMITIN
*----------------------------------------------------------------------
*
*  We're not allowed to read new data until we've drained RGSBUF
*  Likewise, reading past EOF seems excessively dense
*
READ     DS    0H
         LA    R0,INTE$2
         TM    RGSFLG1,RGS1RES              residual data?
         BO    DIE
*
         LA    R0,INTE$3
         TM    RGSFLG2,RGS2EOF              already hit EOF?
         BO    DIE
*
         LR    R10,R13                      save workarea ptr
         LA    R13,SADMSA                   provide data mgt savearea
         GET   (R3),RGSBUF                  read record
         LR    R13,R10                      restore workarea ptr
         TM    RGSFLG2,RGS2EOF              EOF?
         BO    ENDOFILE
*
         UDIAG 3,'RECVGET: GET record',RGSBUF,L'RGSBUF
*
*  Indicate residual data exists, restart residual code
*
         SLR   R6,R6
         STH   R6,RGSROFF                   offset = 0
         OI    RGSFLG1,RGS1RES              residual data valid
         B     RESUME                       continue building segment
         EJECT ,
*----------------------------------------------------------------------
* End Of File - XMITIN EODAD routine
*----------------------------------------------------------------------
EOFRTN   DS    0H
         OI    RGSFLG2,RGS2EOF              XMITIN EOF
         BR    R14
*----------------------------------------------------------------------
*  End Of File
*----------------------------------------------------------------------
ENDOFILE DS    0H
         UDIAG 2,'RECVGET: EOF, closing XMITIN'
         MVC   RGSCLOS(L$CLOS),MODLCLOS     copy model CLOSE macro
         CLOSE ((R3),),MF=(E,RGSCLOS)
         TM    RGSFLG1,RGS1FINI             segment complete?
         BO    EXIT                         fine, done
*
         ICM   R10,3,RGSSL
         BZ    EXIT
*
         UDIAG 2,'RECVGET incomplete seg at EOF',RGSSEG,L'RGSSEG
         B     EXIT
         EJECT ,
*----------------------------------------------------------------------
*  Return segment or EOF to caller
*----------------------------------------------------------------------
EXIT     DS    0H                           return code already set
         UDIAG 9,'RECVGET: partial RGSWA at exit',(R2),L$RGSNAP
         UDIAG 1,'RECVGET exited'
         SLR   R1,R1                        assume EOF, R1 = 0
         TM    RGSFLG1,RGS1FINI             valid segement to return?
         BNO   *+8
         LA    R1,RGSSEG                    R1 @ returned segment
         UPEND R1=PASS,RC=0                 return R1
         EJECT ,
*----------------------------------------------------------------------
*  Data areas
*----------------------------------------------------------------------
MODLOPN  OPEN  (,),MF=L                model OPEN
L$OPN    EQU   *-MODLOPN               l' model open
*
MODLCLOS CLOSE (,),MF=L                model CLOSE
L$CLOS   EQU   *-MODLCLOS              l' model close
*
MODLDCB  DCB   DDNAME=XMITIN,                                          +
               EODAD=EOFRTN,                                           +
               MACRF=GM,DSORG=PS,RECFM=FB,                             +
               LRECL=80
L$DCB    EQU   *-MODLDCB
*
         LTORG ,
         EJECT ,
*----------------------------------------------------------------------
*  Savearea/workarea
*----------------------------------------------------------------------
SAVEAREA DSECT ,
SA       DS    18F
SADMSA   DS    18F                     Data Management savearea
SAREASON DS    X                       UABEND reason code
SAEND    DS    0D
L$SA     EQU   *-SAVEAREA
         EJECT ,
         DXMITSEG ,
         EJECT ,
         WAXMT FUNC=RECV
         EJECT ,
         PRINT NOGEN
         DCBD  DSORG=PS,DEVD=DA
         PRINT GEN
RECVGET  UFINI DXDRGET,L$SA
         END   ,
./ ADD NAME=RECVRCPY 0100-02182-02182-0702-00255-00255-00000-XMIT370
RECVRCPY TITLE 'RECEIVE INMCOPY'
*
* Copyright 2001, 2002 James M. Morrison
*
*----------------------------------------------------------------------
*  Things to do:
*----------------------------------------------------------------------
         U#SET ,
*----------------------------------------------------------------------
* Function: Copy XMIT data blocks to the specified DDNAME
*
* Entry:  S/370 ECMODE KEY=8, STATE=PROB, AUTHORIZED
*
*         R0  = CL8'ddname' (output file)
*         R1  = address of CS2 representing INMCOPY
*
* Exit:   R15 = return code
*
*               00   success
*               04   control segment returned (everything else OK)
*
*         R1  = zero or address of control segment
*
* Abends: yes
*
* Notes:
*
* Debug:  1  -  entry/exit; show exit rc
*         2  -  CS2 at entry, DCB (open/close), RECVBLK nonzero rc
*         3  -  show returned data block
*----------------------------------------------------------------------
* R2
* R3     DCB
* R4
* R5
* R6
* R7
* R8     buffer addr
* R9     buffer length
* R10    CS2
* R11    XMTWA
* R12    base reg
* R13    savearea
*----------------------------------------------------------------------
         TITLE ' '
*----------------------------------------------------------------------
RECVRCPY UPROC L=L$SA,ID=RCPY,WA=SAVEAREA
         EJECT ,
*----------------------------------------------------------------------
*  Initialize
*----------------------------------------------------------------------
INIT     DS    0H
         BALR  R14,0
         LTR   R10,R1                       save CS2
         BZ    DIE
*
         BALR  R14,0
         LTR   R15,R0
         BZ    DIE
*
         MVC   SADDNAME,0(R15)              save DDNAME
*
         USING CS2,R10
         UDIAG 1,'RECVRCPY entered'
         UDIAG 2,'RECVRCPY INMCOPY CS2 at entry',(R10),L$CS2
         LA    R14,L$CS2
         SR    R10,R14
         UDIAG 2,'RECVRCPY IEBCOPY CS2 at entry',(R10),L$CS2
         LA    R14,L$CS2
         AR    R10,R14
         EJECT ,
*----------------------------------------------------------------------
*  Open output DDNAME
*----------------------------------------------------------------------
CKDCB    DS    0H
         LA    R3,SADCB
         USING IHADCB,R3
         MVC   SADCB(L$DCB),MODLDCB         copy model DCB macro
         MVC   SAOPN(L$OPN),MODLOPN         copy model OPEN macro
         MVC   DCBDDNAM,SADDNAME            overlay DDNAME
*
         MVC   DCBDSORG,CS2DSORG+2          overlay DSORG=PS
*
*  For some reason, RECFM isn't right in either the INMCOPY
*  or IEBCOPY CS2s.  We know it should be VS.
*
         MVC   DCBRECFM,=X'48'              overlay RECFM=VS
*
*        LA    R14,L$CS2
*        SR    R10,R14                      back up to IEBCOPY CS2
*
         BALR  R14,0
         ICM   R0,15,CS2BLKSZ               have BLKSIZE spec'd?
         BZ    DIE
         STCM  R0,3,DCBBLKSI                overlay BLKSIZE
*
*        BALR  R14,0
*        ICM   R0,15,CS2LRECL               have LRECL spec'd?
*        BZ    DIE
*        STCM  R0,3,DCBLRECL                overlay LRECL
         MVC   DCBLRECL,=X'7FF4'   <fakeout>
*
*        AR    R10,R14                      revert to INMCOPY CS2
*
         UDIAG 2,'RECVRCPY open DCB',(R3),L$DCB
         OPEN  ((R3),OUTPUT),MF=(E,SAOPN)
         TM    DCBOFLG1,DCBOFOPN            opened?
         BO    DCBOPEN
*
         UDIAG 0,'RECVRCPY DCB open error',(R3),L$DCB
         MVI   SAREASON,1                   DCB didn't open
UABEND   UABEND SAREASON                    ABEND w/ diagnostic msgs
*
DIE      STM   R0,R15,XMTREGS
         UPSR  0,'RECVRCPY ABENDing; R14',(R14)
         UDIAG 0,'RECVRCPY pre-ABEND regs',XMTREGS,16*4
         MVI   SAREASON,2                   internal error - R14 useful
         B     UABEND
*
DCBOPEN  DS    0H
*----------------------------------------------------------------------
*  Allocate buffer
*----------------------------------------------------------------------
BUFALLOC DS    0H
         L     R0,=A(32*1024)          max QSAM blocksize
         ST    R0,SALBUF
         GETMAIN R,LV=(0)              allocate buffer
         ST    R1,SA@BUF
         EJECT ,
*----------------------------------------------------------------------
*  Retrieve data block
*----------------------------------------------------------------------
GETBLOCK DS    0H
         LA    R14,4                   L'RDW
         LM    R0,R1,SAXBUF            R0=BUFL, R1@BUF
         LA    R1,0(R14,R1)            reserve RDW space
         SR    R0,R14
         UCALL RECVBLK,ERR=READCTL     retrieve data block
         LTR   R8,R1                   @ buffer
         BZ    READERR
*
         LTR   R9,R0
         BNZ   WRITE
*
READCTL  DS    0H
         ST    R1,SACTL                save ctl seg addr
         ST    R15,SARC                save RECVBLK rc
         UPSR  2,'RECVRCPY RECVBLK rc',(R15)
         OI    SAFLG1,SA1CTL           control segment returned
         B     CLOSE
*
READERR  DS    0H
         UDIAG 0,'RECVRCPY XMIT read error',XMTREGS,16*4,REGS=YES
         UDIAG 0,'RECVRCPY DCB',(R3),L$DCB
         MVI   SAREASON,22                  internal error - R14 useful
         B     UABEND
         EJECT ,
*----------------------------------------------------------------------
*  Write data block
*----------------------------------------------------------------------
WRITE    DS    0H
         L     R8,SA@BUF               @ RDW space
         LA    R9,4(,R9)               add RDW overhead
         STH   R9,0(,R8)               create RDW
         UPSR  2,'RECVRCPY PUT data block RDW length',(R9)
         UDIAG 3,'RECVRCPY PUT data block',(R8),(R9)
         PUT   (R3),(R8)               write IEBCOPY unload rec
         B     GETBLOCK
         EJECT ,
*----------------------------------------------------------------------
*  Close output
*----------------------------------------------------------------------
CLOSE    DS    0H
         UDIAG 2,'RECVRCPY closing DCB',(R3),L$DCB
         MVC   SACLOS(L$CLOS),MODLCLOS      copy model CLOSE macro
         CLOSE ((R3),),MF=(E,SACLOS)
*----------------------------------------------------------------------
*  Free buffer
*----------------------------------------------------------------------
FREEBUF  DS    0H
         LM    R0,R1,SAXBUF
         LTR   R0,R0
         BZ    NOFREE
*
         FREEMAIN R,LV=(0),A=(1)            free output buffer
NOFREE   DS    0H
*----------------------------------------------------------------------
*  Return to caller
*----------------------------------------------------------------------
EXIT     DS    0H
         L     R2,SARC
         UPSR  1,'RECVRCPY exited rc',(R2)
         L     R1,SACTL
         UPEND RC=(R2),R1=PASS              return R1, R15
         EJECT ,
*----------------------------------------------------------------------
*  Data areas
*----------------------------------------------------------------------
MODLOPN  OPEN  (,),MF=L                model OPEN
L$OPN    EQU   *-MODLOPN               l' model open
*
MODLCLOS CLOSE (,),MF=L                model CLOSE
L$CLOS   EQU   *-MODLCLOS              l' model close
*
MODLDCB  DCB   DDNAME=IEBUT1,                                          +
               MACRF=PM,                                               +
               DSORG=PS,                                               +
               LRECL=0
L$DCB    EQU   *-MODLDCB
         LTORG ,
*        EJECT ,
*----------------------------------------------------------------------
*  Savearea/workarea
*----------------------------------------------------------------------
SAVEAREA DSECT ,
SASA     DS    18F                     savearea for anyone we call
*
SAFLG1   DS    X
SA1CTL   EQU   128                     have control segment
*
SAREASON DS    X                       UABEND reason code
*
SARC     DS    F                       our return code
SADDNAME DS    CL8                     output DDNAME
*
SACTL    DS    F                       @ control segment
*
SAXBUF   DS    0F
SALBUF   DS    F                       output buffer length
SA@BUF   DS    A                       output buffer address
*
SAOPN    OPEN  (,),MF=L
SACLOS   OPEN  (,),MF=L
SADCB    DCB   DDNAME=IEBUT1,                                          +
               MACRF=PM,                                               +
               DSORG=PS
*
         DS    0D
L$SA     EQU   *-SAVEAREA
*
         EJECT ,
         DRCS2 ,
*
         PUSH  PRINT
         PRINT NOGEN
*
         WAXMT FUNC=RECV
*
         DCBD  DSORG=PS,DEVD=DA
*
         POP   PRINT
*
         PRINT GEN
RECVRCPY UFINI DXDRCPY,L$SA            pseudo-register
         END   ,
./ ADD NAME=RECVUTIL 0100-02182-02182-0702-00250-00250-00000-XMIT370
RECVUTIL TITLE 'Call UTILITY'
*
* Copyright 2001, 2002 James M. Morrison
*
*----------------------------------------------------------------------
*  Things to do:
*----------------------------------------------------------------------
         U#SET ,
*----------------------------------------------------------------------
* Function: Given a CS2 (RECVCS2), call the indicated UTILITY
*
* Entry:  S/370 ECMODE KEY=8, STATE=PROB, AUTHORIZED
*
*         R0  =
*         R1  = address of CS2
*
* Exit:   R15 = return code
*
*               00   success
*                    R1 = 0
*
*               04   control segment returned (everything else OK)
*                    R1 = address of control segment
*
*               16   Utility LOAD failed
*                    R1 = 0
*
* Abends:
*
* Notes:
*----------------------------------------------------------------------
* R2     return code
* R3
* R4
* R5     BXLE
* R6     BXLE
* R7     BXLE
* R8
* R9
* R10    CS2
* R11    XMTWA
* R12    base reg
* R13    savearea
*----------------------------------------------------------------------
         TITLE ' '
*----------------------------------------------------------------------
RECVUTIL UPROC L=L$SA,ID=RUTL,WA=SAVEAREA
         EJECT ,
*----------------------------------------------------------------------
*  Initialize
*----------------------------------------------------------------------
INIT     DS    0H
         LR    R10,R1                       save CS2
         USING CS2,R10
         UDIAG 1,'RECVUTIL entered'
         UDIAG 2,'RECVUTIL CS2 at entry',(R10),L$CS2
*
         LM    R5,R7,=A(TAB,12,TABEND-1)    BXLE regs
*
SCAN     DS    0H
         CLC   CS2UTILN,0(R5)               supported UTILITY?
         BE    FOUND
*
         BXLE  R5,R6,SCAN
*
         UDIAG 0,'RECVUTIL unsupported utility (CS2)',CS2,L$CS2
         LA    R2,16
         B     EXITRC
*
FOUND    DS    0H
         ICM   R15,15,8(R5)
         BNZR  R15                          call support routine
*
         STM   R0,R15,XMTREGS
         ULOG  'RECVCTL support routine unresolved'
         MVI   SAREASON,1
DIE      UABEND SAREASON                    installation error
         EJECT ,
*----------------------------------------------------------------------
*  INMCOPY
*----------------------------------------------------------------------
INMCOPY  DS    0H
         LA    R0,IEBUT1                    target DDNAME
         LR    R1,R10                       CS2
         UCALL RECVRCPY                     RECEIVE INMCOPY support
         LTR   R2,R15
         BZ    EXITRC
*
         ST    R1,SACTL                     returned ctl seg addr
         UPSR  2,'RECVUTIL RECVRCPY rc',(R2)
         MVI   SAREASON,2
         L     R15,SACTL
         SLR   R14,R14
         ICM   R14,1,SEGL-SEG(R15)
         BZ    DIE
*
         UDIAG 2,'RECVUTIL emit ctl seg',(R15),(R14)
         B     EXITRC
         EJECT ,
*----------------------------------------------------------------------
*  IEBCOPY setup
*----------------------------------------------------------------------
IEBCOPY  DS    0H
         LA    R0,SAPRM1
         ST    R0,SAPARM                    IEBCOPY parmlist
*
         LA    R0,IEBOPTS     SAPRM4
         ST    R0,SAPRM1                    IEBCOPY options (OS PARM)
*
         LA    R0,IEBDDLST    SAPRM6
         ST    R0,SAPRM2                    IEBCOPY DDNAME list
*
         LA    R0,IEBPAGEL    SAPRM8
         ST    R0,SAPRM3                    IEBCOPY page header
*
         OI    SAPRM2,128                   VL flag (ignore page hdr)
         B     LOAD
*
*  Extraneous setup, for ease of zapping
*
         LA    R0,0           SAPRM8
         ST    R0,SAPRM3                    IEBCOPY page header
         OI    SAPRM3,128                   VL flag
*
         MVC   SAPRM4,IEBOPTS               set OS PARM length
         MVC   SAPRM5,IEBPARM               copy OS PARM
*
         MVC   SAPRM6,IEBDDLST              set DDNAME list length
         MVC   SAPRM7,IEBDDN                copy DDNAME list
*
         MVC   SAPRM8,IEBPAGEL              set page header length
         MVC   SAPRM9,IEBPAGE               copy page header
         B     LOAD
*
         DS    0H
IEBOPTS  DC    AL2(0)                       length of OS parm string
IEBPARM  DC    C'                   '       IEBCOPY options (zappable)
*        DC    C'SIZE=nnnnK,WORK=nnK'       SIZE = buffer size
*                                           WORK = I/O buffer size
*
         DS    0H
IEBDDLST DC    AL2(IEBDDX-IEBDDN)           L' DDNAME list
IEBDDN   DS    0H
         DC    XL8'00'
         DC    XL8'00'
         DC    XL8'00'
         DC    XL8'00'
IEBSYSIN DC    CL8'SYSIN'                   SYSIN    DD DUMMY
IEBSYSPT DC    CL8'SYSPRINT'                SYSPRINT DD SYSOUT
         DC    XL8'00'
IEBUT1   DC    CL8'SYSUT1'                  SYSUT1   input unloaded ds
IEBUT2   DC    CL8'SYSUT2'                  SYSUT2   output PDS
IEBUT3   DC    CL8'SYSUT3'                  SYSUT3   spill
IEBUT4   DC    CL8'SYSUT4'                  SYSUT4   spill
IEBDDX   DS    0H
*
         DS    0H
IEBPAGEL DC    AL2(L'IEBPAGE)               PAGE HEADER length
IEBPAGE  DC    Z'1'                         PAGE HEADER
         EJECT ,
*----------------------------------------------------------------------
*  LOAD UTILITY
*----------------------------------------------------------------------
LOAD     DS    0H
         LA    R0,CS2UTILN
         LOAD  EPLOC=(0)                    load UTILITY
         LTR   R15,R15
         BZ    CALL
*
         MVI   SARC+3,16
         UPSR  0,'RECVUTIL ERROR: UTILITY LOAD rc',(R15)
         B     EXIT
*----------------------------------------------------------------------
*  Call UTILITY
*----------------------------------------------------------------------
CALL     DS    0H
         LR    R15,R0              get entry address
         LA    R15,0(,R15)         clear hi byte for DELETE
         LR    R9,R15              save EP
         L     R1,SAPARM           UTILITY parmlist ptr
         BALR  R14,R15             call UTILITY
         ST    R15,SARC
         UPSR  2,'RECVUTIL UTILITY rc %',(R15)
*----------------------------------------------------------------------
*  DELETE UTILITY
*----------------------------------------------------------------------
DELETE   DS    0H
         LA    R0,CS2UTILN
         DELETE EPLOC=(0)          delete UTILITY program
         UPSR  2,'RECVUTIL UTILITY DELETE rc %',(R15)
*----------------------------------------------------------------------
*  Return to caller
*----------------------------------------------------------------------
EXIT     DS    0H
         L     R2,SARC
*
EXITRC   DS    0H
         UPSR  1,'RECVUTIL exited rc',(R2)
         L     R1,SACTL
         UPEND RC=(R2),R1=PASS
         EJECT ,
*----------------------------------------------------------------------
*  Data areas
*----------------------------------------------------------------------
TAB      DS    0F
         DC    CL8'INMCOPY',A(INMCOPY)
         DC    CL8'IEBCOPY',A(IEBCOPY)
TABEND   DS    0X
         LTORG ,
*        EJECT ,
*----------------------------------------------------------------------
*  Savearea/workarea
*----------------------------------------------------------------------
SAVEAREA DSECT ,
SASA     DS    18F                     savearea for anyone we call
SARC     DS    F                       our return code
SACTL    DS    A                       addr of ctl seg from RECVRCPY
SAREASON DS    X                       UABEND reason code
*
*  General parm layout for calling IBM utilities
*
SAPARM   DS    A                       UTILITY parmlist ptr
*
SAPRM1   DS    A                       OS parm
SAPRM2   DS    A                       DDNAME list
SAPRM3   DS    A                       page header
*
SAPRM4   DS    H                       L' OS PARM
SAPRM5   DS    CL100                   UTILITY OS PARM
*
SAPRM6   DS    H                       L' ddname list
SAPRM7   DS    XL100                   UTILITY ddname list
*
SAPRM8   DS    H                       L' page number
SAPRM9   DS    CL4                     page number
*
         DS    0D
L$SA     EQU   *-SAVEAREA
*
         EJECT ,
         DRCS2 ,
*        EJECT ,
         PUSH  PRINT
         PRINT NOGEN
         DXMITSEG ,
         WAXMT FUNC=RECV
*        EJECT ,
         POP   PRINT
RECVUTIL UFINI DXDRUTL,L$SA            pseudo-register
         END   ,
./ ADD NAME=RECVVTAB 0100-02182-02182-0702-00037-00037-00000-XMIT370
RECVVTAB TITLE 'RECV370 VCON table'
*
* Copyright 2001, 2002 James M. Morrison
*
UTILVTAB CSECT ,                     XMITDBUG uses V(UTILVTAB)
         USING *,0
         USING XMTWA,11
*----------------------------------------------------------------------
*  CSECT table header - BXLE index, increment, limit
*----------------------------------------------------------------------
HEADER   DC    A(DBUGTAB,L$VTAB,DBUGEND-1)
*----------------------------------------------------------------------
*  CSECT table
*----------------------------------------------------------------------
DBUGTAB  DS    0F
         DC    CL8'RECV370',V(RECV370),AL2(XMTD370-XMTDLEV,0)
         DC    CL8'RECVBLK',V(RECVBLK),AL2(XMTDBLK-XMTDLEV,0)
         DC    CL8'RECVCTL',V(RECVCTL),AL2(XMTDCTL-XMTDLEV,0)
         DC    CL8'RECVGET',V(RECVGET),AL2(XMTDGET-XMTDLEV,0)
         DC    CL8'RECVRCPY',V(RECVRCPY),AL2(XMTDRCPY-XMTDLEV,0)
         DC    CL8'RECVUTIL',V(RECVUTIL),AL2(XMTDUTIL-XMTDLEV,0)
*
         DC    CL8'UTILABND',V(UTILABND),AL2(XMTDABND-XMTDLEV,0)
         DC    CL8'UTILDBUG',V(UTILDBUG),AL2(XMTDDBUG-XMTDLEV,0)
         DC    CL8'UTILHEX',V(UTILHEX),AL2(XMTDHEX-XMTDLEV,0)
         DC    CL8'UTILLOG',V(UTILLOG),AL2(XMTDLOG-XMTDLEV,0)
         DC    CL8'UTILPSR',V(UTILPSR),AL2(XMTDPSR-XMTDLEV,0)
         DC    CL8'UTILSNAP',V(UTILSNAP),AL2(XMTDSNAP-XMTDLEV,0)
         DC    CL8'UTILTIOT',V(UTILTIOT),AL2(XMTDTIOT-XMTDLEV,0)
DBUGEND  EQU   *
*----------------------------------------------------------------------
*  DSECTs
*----------------------------------------------------------------------
         DVTAB ,                  VCON table
         PRINT NOGEN
         WAXMT FUNC=RECV
         END   ,
./ ADD NAME=RECV370  0100-02182-02182-0702-00206-00206-00000-XMIT370
RECV370  TITLE 'TSO/E RECEIVE clone for MVS 3.8J'
*
* Copyright 2001, 2002 James M. Morrison
*
*----------------------------------------------------------------------
*  Copyright 2002, James M. Morrison
*----------------------------------------------------------------------
*  Things to do:
*----------------------------------------------------------------------
         U#SET ,
*----------------------------------------------------------------------
* Function: Given an input XMIT file, recreate original file (PDS
*           or sequential file).
*
* DDNAMEs:
*
*        ddname     opened description                opens    closes
*        --------   ------ -------------------------- -------- --------
*
*        XMITPRT    OUTPUT RECV370 messages           XMITLOG  XMITLOG
*
*        XMITIN     INPUT  XMIT                       RECVGET  RECVGET
*
*        XMITOUT    OUTPUT recreated PDS              IEBCOPY  IEBCOPY
*                   OUTPUT recreated sequential       RECVSEQ  RECVSEQ
*
*        XMITDBUG   INPUT  debug control stmts        UTILDBUG UTILDBUG
*
*        SYSPRINT   OUTPUT IEBCOPY messages           IEBCOPY  IEBCOPY
*
*        SYSUT1     OUTPUT unwrapped XMIT             RECVPDS  RECVPDS
*                   INPUT  IEBCOPY unload file        IEBCOPY  IEBCOPY
*
*        SYSIN      DUMMY  IEBCOPY control            IEBCOPY  IEBCOPY
*                          statements (optional)
*
* Processing overview:
*
*        RECVCTL           handle XMIT control segments
*          RECVPDS         handle IEBCOPY unloaded PDS
*            RECVCOPY      invoke IEBCOPY
*          RECVSEQ         handle sequential file
*
*    Utility:
*
*        RECVBLK           return IEBCOPY unloaded dataset block
*        RECVGET           return XMIT segment
*        RECVTAB           VCON/debug table (like XMIVTAB)
*        UTILDBUG          setup debug options from XMITDBUG ddname
*        XMITHEX           convert R0 to display hex
*        XMITLOG           log messages to XMITPRT ddname
*        XMITPSR           print string & R0 contents (display hex)
*        XMITSNAP          mini-SNAP
*
* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*
*
*         R0  =
*         R1  =  Address of OS parmlist
*         R13 =  savearea ptr
*         R14 =  return addr to caller
*         R15 =  address of RECV370
*
* Exit:   R15 = return code
*         R15 = 00 success
*
* Abends: U0001 DCB didn't open
*
* Notes:  This routine is responsible for setting up its registers
*         as required by the PROC and PEND macros.
*----------------------------------------------------------------------
* R2     XPSWA
* R3     DCB
* R4     OS parm ptr
* R5
* R6
* R7
* R8
* R9
* R10    our real program base reg
* R11    XMTWA ... ALWAYS (contains our savearea)
* R12    BASE REG ... ALL CSECTS (dummy for us)
* R13    savearea
*----------------------------------------------------------------------
         TITLE ' '
*----------------------------------------------------------------------
RECV370  CSECT ,
         USING *,R15
         B     MPASTID
         DC    AL1(MAINIDX-MAINID)
MAINID   DC    CL8'RECV370'       MODULE IDENTIFIER
         DC    CL8'&SYSDATE'      ASSEMBLY DATE
         DC    CL7' &SYSTIME'     ASSEMBLY TIME
MAINIDX  EQU   *
MAINSAL  DC    A(L$XMTWA)         XMTWA LENGTH
MPASTID  DS    0H
         DROP  R15
         STM   R14,R12,12(R13)    STANDARD REGISTER SAVE
         LR    R10,R15
         USING RECV370,R10        BASE REGISTER (exception to rule)
         LR    R4,R1              save parm ptr
*
         L     R3,L$DSA           LENGTH OF ALL DSAs
         LA    R3,4095(,R3)       ROUND
         SRL   R3,12              TO NEXT
         SLL   R3,12              PAGE
         GETMAIN R,LV=(R3)        GET STORAGE FOR DSAs
         LR    R11,R1
         USING XMTWA,R11
         UZERO (R11),(R3)         clear storage
*
* Init XMTWA
*
         MVC   XMTEYE,=C'RECVDSA '          set eyecatcher
         LA    R1,XMTSA1
         ST    R1,8(,R13)         FORWARD POINTER
         ST    R13,4(,R1)         BACKWARD POINTER
         LR    R13,R1
         USING SAVEAREA,R13
         ST    R3,XMTLDSA                   record l' dsa
         MVC   XMTRGSWE,=C'GETWORK '        set XPSWA eyecatcher
         MVI   XMTDLEV,C'0'                 default diagnostic level
         LTR   R4,R4
         BZ    NOPARM
         L     R4,0(,R4)                    @ OS parm string
         LH    R14,0(,R4)                   l' parm string
         LTR   R14,R14                      anything?
         BNP   NOPARM                       no, br
         ST    R4,XMT@PARM                  save parm ptr
         MVC   XMTDLEV,2(R4)                copy diag char
NOPARM   DS    0H
*----------------------------------------------------------------------
*  setup fake PROC based on R12 so PROC macro works for rest of code
*----------------------------------------------------------------------
         LR    R12,R10                       PROC assumes R12 set
         LA    R15,MAIN                      pretend we just got here
         PUSH  USING
         DROP  ,
         CNOP  0,8
MAIN     UPROC L=L$MAIN,SECT=LABEL,ID=MAIN,WA=
         POP   USING                         don't mess up our code
*----------------------------------------------------------------------
*  Wake up XMITLOG
*----------------------------------------------------------------------
    ULOG 'RECV370 v 00.00 Copyright 2002, James M. Morrison'
    ULOG 'RECV370 Initial Developer James M. Morrison'
    ULOG 'RECV370 may be distributed under the terms of the Q Public Li+
               cense version 1.0'
*----------------------------------------------------------------------
*  Handle XMITDBUG ddname
*----------------------------------------------------------------------
         UCALL UTILDBUG                     handle XMITDBUG ddname
*----------------------------------------------------------------------
*  Verify we're authorized
*----------------------------------------------------------------------
         TESTAUTH FCTN=1                    authorized?
         LTR   R15,R15
         BZ    AUTHOK
         ULOG  'RECV370 requires authorization'
         MVI   SAREASON,X'47'               not authorized
UABEND   UABEND SAREASON                    ABEND w/ diagnostics
AUTHOK   DS    0H
*----------------------------------------------------------------------
*  Handle the XMIT file, recreate PDS/sequential dataset
*----------------------------------------------------------------------
         UCALL RECVCTL,ERR=EXIT
         ULOG  'RECV370 done'
*----------------------------------------------------------------------
*  Close XMITPRT DCB
*----------------------------------------------------------------------
         SLR   R1,R1                        r1=0 ... close XMITPRT
         UCALL UTILLOG                      CLOSE XMITPRT
*----------------------------------------------------------------------
*  Return to caller
*----------------------------------------------------------------------
EXIT     DS    0H
         L     R3,XMTRC
         L     R13,XMTSA1+4        LOAD CALLER'S SAVE AREA PTR
         L     R0,XMTLDSA
         FREEMAIN R,LV=(0),A=(R11)      free XMITDSA
         L     R14,12(R13)        STANDARD REGISTER RESTORE
         LR    R15,R3             SET RETURN CODE
         LM    R0,R12,20(R13)     STANDARD REGISTER RESTORE
         XC    8(4,R13),8(R13)    ERASE RECV370'S SAVEAREA PTR
         BR    R14                RETURN TO CALLER
*
         LTORG ,
*
         EJECT ,
         WAXMT FUNC=RECV
         EJECT ,
         DXMITSEG ,
         EJECT ,
SAVEAREA DSECT ,
         DS    18F           dummy "main" proc savearea
SAREASON DS    X
SAEND    DS    0D
L$MAIN   EQU   *-SAVEAREA
*
         PRINT GEN
RECV370  UFINI DXDR370,L$XMTWA
RECV370  UFINI DXDRMAIN,L$MAIN
*
L$DSA    CXD   ,   LINKAGE EDITOR CALCULATES TOTAL DSA LENGTH FOR US
*                  NOTE: THIS TECHNIQUE WILL FAIL FOR RECURSIVE CALLS
*
         END   ,
./ ADD NAME=U#SET    0100-02182-02182-0702-00019-00019-00000-XMIT370
         MACRO
         U#SET &DIAG=,
.*
.* Copyright 2001, 2002 James M. Morrison
.*
         GBLB  &XMTDIAG
         GBLB  &G#ASMF
         GBLB  &G#HERC
         GBLC  &XMTREGS
         GBLC  &XMTABND
&G#ASMF  SETB  1                  ASMF macro operand sublist bug
&G#HERC  SETB  1                  Hercules emulator support
&XMTREGS SETC  'XMTREGS'          XMTWA field for debug regs
&XMTABND SETC  'XMTABEND'         XMTWA field for abend regs
.*
         AIF   ('&DIAG' EQ 'NO').NODIAG
&XMTDIAG SETB  1                  1 = enable XMITDIAG macro
.NODIAG  ANOP
         MEND
./ ADD NAME=UABEND   0100-02182-02182-0702-00037-00037-00000-XMIT370
         MACRO
&LABEL   UABEND &REASON,&DUMP=N,&STEP=N,&CODE=
.*
.* Copyright 2001, 2002 James M. Morrison
.*
.*---------------------------------------------------------------------
.* &CODE   - ABEND code
.* &REASON - ABEND reason code, RX address only
.*
.* Normal OS DUMP, STEP options are not provided.  UTILABND makes
.* a decision on it's own, for ease in consolidating ABEND behavior.
.*---------------------------------------------------------------------
         GBLC  &XMTABND
         LCLC  &NDX
         LCLB  &A1,&A2,&B1,&B2
         LCLA  &F1,&F2
.*
&NDX     SETC  '&SYSNDX'
&LABEL   STM   R14,R13,&XMTABND        save regs before ABEND
         AIF   ('&CODE' EQ '').CKRSN
         IM#LALR  R1,&CODE             load abend code
.CKRSN   AIF   ('&REASON' EQ '').NOCOD
         ICM   R1,8,&REASON            load reason code
.NOCOD   UCALL UTILABND                call ABEND support
         SVC   13                      UTILABND returns to ABEND here
.*
&A1      SETB  ('&DUMP' NE 'N')
&A2      SETB  ('&STEP' NE 'N')
.*
&B1      SETB  ('&REASON' NE '')
&B2      SETB  ('&CODE' NE '')
.*
&F1      SETA  (&A1*128)+(&A2*64)
&F2      SETA  (&B1*128)+(&B2*64)
.*
OPT&NDX  DC    AL1(&F1,&F2)            option flags
         MEND
./ ADD NAME=UCALL    0100-02182-02182-0702-00024-00024-00000-XMIT370
         MACRO
&LABEL   UCALL &WHAT,&PLIST=,&ERR=
.*
.* Copyright 2001, 2002 James M. Morrison
.*
.*---------------------------------------------------------------------
.* &WHAT  - CSECT name to call
.* &PLIST - optional parmlist (R1)
.* &ERR   - optional LTR of R15 after called CSECT returns
.*
.* Note UABEND macro depends on the BALR being last instruction gen'd.
.*--------------------------------------------------------------------
         AIF   (T'&LABEL EQ 'O').NOLABL
&LABEL   DS    0H
.NOLABL  ANOP
         AIF   (T'&PLIST EQ 'O').NOPLST
         IM#LALR R1,&PLIST             @ parmlist
.NOPLST  ANOP
         L     R15,=V(&WHAT)           load program address
         BALR  R14,R15                 call program
         AIF   ('&ERR' EQ '').MEND
         LTR   R15,R15                 check return code
         BNZ   &ERR
.MEND    MEND
./ ADD NAME=UDIAG    0100-02182-02182-0702-00083-00083-00000-XMIT370
         MACRO
&LABEL   UDIAG &LEVEL,&TEXT,&ADDR,&LEN,&SKIP=,&REGS=NO
.*
.* Copyright 2001, 2002 James M. Morrison
.*
.*---------------------------------------------------------------------
.* &LEVEL: 0   normal non-diagnostic messages (always shown)
.*         1   STATUS messages, entry & exit
.*         2   CSECT-SPECIFIC trace messages
.*     above   varies by CSECT
.*
.* During execution, if the proper debug level is not set in XMTWA,
.* the XMITLOG or XMITSNAP calls will not be executed
.*
.* &TEXT - RX or quoted string message to be issued, using either
.* calls to XMITLOG or XMITSNAP.  For RX specifications, see XMITLOG
.* or XMITSNAP for the layout of the message (they're different).
.* &TEXT will be displayed by XMITLOG, unless &ADDR is coded in which
.* XMITSNAP will display the text.
.* Briefly, XMITLOG - RX field consists of text only.
.* XMITSNAP - RX field has one byte length prefix, or may be delimited
.* by X'00' at the end (then no length prefix); 60 byte max text.
.*
.* &ADDR - XMITSNAP start address
.* &LEN  - XMITSNAP length (or stop address)
.*
.* REGS=NO suppresses STM of R0:R15 into &XMTREGS, code some other
.* value to generate STM (REGS=YES, REGS=SAVE, etc.).
.*
.* SKIP=label causes branch to label if diagnostic level msg would
.* not be issued; &TEXT, &ADDR, &LEN &REGS ignored when used.
.* SKIP=label would be used to branch around code only needed for
.* certain diag levels.
.*---------------------------------------------------------------------
         GBLB  &XMTDIAG
         GBLC  &XMTREGS
         LCLA  &LDBUG,&LSTR
         LCLC  &NDX
         LCLC  &DBUGBYT,&SKIPLAB
         LCLC  &NEWTEXT,&STRING
.*
         AIF   (&XMTDIAG).GO
&LABEL   IM#SECT LABEL       generate label for suppressed UDIAG
         MEXIT
.*
.GO      ANOP
&NDX     SETC  '&SYSNDX'
&LDBUG   SETA  K'&SYSECT
&DBUGBYT SETC  '&SYSECT'(5,&LDBUG-4)     set XMTD* byte name from CSECT
.*
.*  Put label for BL instruction into common format
.*
&SKIPLAB SETC  '&SKIP'
         AIF   ('&SKIP' NE '').NOSTR           SKIP=label ignores &TEXT
&SKIPLAB SETC  'SKIP&NDX'
.*
.*  Insert <n> into front of quoted string
.*
&NEWTEXT SETC  '&TEXT'
         AIF   ('&TEXT'(1,1) NE '''').NOSTR      skip if not quoted str
&LSTR    SETA  K'&TEXT-2                        length minus two quotes
&STRING  SETC  '&TEXT'(2,&LSTR)                strip quotes from string
&NEWTEXT SETC  '''<&LEVEL> &STRING'''              new text with quotes
.NOSTR   ANOP
.*
&LABEL   IM#SECT LABEL
         AIF   ('&LEVEL' EQ '0').STM        level=0 always runs
         CLI   XMTD&DBUGBYT,C'&LEVEL'       generate diag msg?
         BL    &SKIPLAB                     no, br
         AIF   ('&SKIP' EQ '').STM
         MEXIT
.*
.STM     AIF   ('&REGS' EQ 'NO').CKSNAP
         STM   R0,R15,&XMTREGS              <debug>
.*
.CKSNAP  AIF   ('&ADDR' NE '').SNAP
         ULOG  &NEWTEXT
SKIP&NDX DS    0H
         MEXIT
.*
.SNAP    USNAP &NEWTEXT,&ADDR,&LEN
SKIP&NDX DS    0H
         MEND
./ ADD NAME=UFINI    0100-02182-02182-0702-00019-00019-00000-XMIT370
         MACRO
&CSECT   UFINI &DXD,&LEN
.*
.* Copyright 2001, 2002 James M. Morrison
.*
.*---------------------------------------------------------------------
.* Define pseudo-register for our DSA
.* &CSECT - CSECT name to which this pseudo-register applies
.* &DXD   - DXD label
.* &LEN   - length of the pseudo-register area (savearea length)
.*---------------------------------------------------------------------
*----------------------------------------------------------------------
&CSECT   CSECT ,                            resume CSECT
*
&DXD     DXD   XL(&LEN)
         DC    Q(&DXD)                      our DSA requirement
         DS    0D
*----------------------------------------------------------------------
         MEND
./ ADD NAME=ULOG     0100-02182-02182-0702-00030-00030-00000-XMIT370
         MACRO
&LABEL   ULOG &TEXT,&LENGTH
.*
.* Copyright 2001, 2002 James M. Morrison
.*
.*---------------------------------------------------------------------
.* &TEXT   - RX or quoted string.  RX fields consists of text only.
.* &LENGTH - optional, only needed to specify length if it can't
.* be determined by the L' length attribute
.*---------------------------------------------------------------------
         LCLC  &NDX
&NDX     SETC  '&SYSNDX'
.*
         AIF   ('&TEXT'(1,1) EQ '''').STRING
.*
&LABEL   IM#LALR R1,&TEXT                        message text
         AIF   ('&LENGTH' EQ '').LENATTR
         IM#LALR R0,&LENGTH                      length of text
         AGO   .CALL
.*
.LENATTR LA    R0,L'&TEXT                        length of text
         AGO   .CALL
.*
.STRING  ANOP
&LABEL   BAL   R1,CODE&NDX                       skip msg, r1 @ msg txt
MSG&NDX  DC    C&TEXT
CODE&NDX LA    R0,L'MSG&NDX                              message length
.*
.CALL    UCALL UTILLOG                                      log message
         MEND
./ ADD NAME=UPEND    0100-02182-02182-0702-00041-00041-00000-XMIT370
         MACRO
&LABEL   UPEND &R0=RESTORE,&R1=RESTORE,&RC=
.*
.* Copyright 2001, 2002 James M. Morrison
.*
.* R15 is never restored
.*
&LABEL   IM#SECT LABEL            conditionally generate label
         AIF   ('&RC' EQ '').HVRC
         AIF   ('&RC' EQ '0').RC0
         IM#LALR R15,&RC
         AGO   .HVRC
.RC0     SLR   R15,R15            return code zero
.HVRC    ANOP
         L     R13,4(,R13)        R13 @ caller's savearea
         L     R14,12(,R13)       restore return addr
.*
         AIF   ('&R1' NE 'RESTORE').NOR1
         AIF   ('&R0' NE 'RESTORE').NOR0
         LM    R0,R12,20(R13)     restore caller's regs (NOT R15)
         AGO   .XC
.*
.NOR0    LM    R1,R12,24(R13)     restore caller's regs (NOT R0,R15)
         AGO   .XC
.*
.*
.NOR1    AIF   ('&R0' NE 'RESTORE').R2
         L     R0,20(R13)         restore caller's regs
         LM    R2,R12,28(R13)     EXCEPT R1, R15
         AGO   .XC
.*
.R2      LM    R2,R12,28(R13)     restore caller's regs (NOT R15,R0,R1)
.*
.XC      XC    8(4,R13),8(R13)    erase forward ptr
         BR    R14                return to caller
*
         PUSH  PRINT
         PRINT DATA
PATCH    DC    32S(*)             PATCH AREA
         POP   PRINT
         MEND
./ ADD NAME=UPROC    0100-02182-02182-0702-00051-00051-00000-XMIT370
         MACRO
&NAME    UPROC  &L=(19*4),&SECT=CSECT,&ID=XMT0,&WA=SAVEAREA
.*
.* Copyright 2001, 2002 James M. Morrison
.*
&NAME    IM#SECT &SECT
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11                  XMTWA
WAREG    EQU   11                  for open code usage
R12      EQU   12                  program base
BASEREG  EQU   12                  for open code usage
R13      EQU   13                  savearea/workarea
SAREG    EQU   13                  for open code usage
R14      EQU   14
R15      EQU   15
         USING *,R15
         B     PASTID
         DC    AL1(IDX-ID)
ID       DC    CL8'&NAME'          CSECT NAME
         DC    CL8'&SYSDATE'       ASSEMBLY DATE MM/DD/YY
         DC    CL7' &SYSTIME'      ASSEMBLY TIME HH.MM
IDX      EQU   *
DSALEN   DC    A(&L)               LENGTH OF SAVEAREA & WORKAREA
PASTID   STM   R14,R12,12(R13)     STANDARD REGISTER SAVE
         DROP  R15
         LR    R2,R13              CALLER'S R13 + CALLER'S DSALEN
         A     R2,DSALEN-&NAME.(,R12)    = R2 @ OUR SAVEAREA
         LR    R3,R2               SAVE OUR SA PTR FOR BELOW
         LR    R12,R15
         USING &NAME,R12           BASE REGISTER ... ALL CSECTS
         UZERO (R2),*DSALEN        CLEAR SAVEAREA
         ST    R2,8(,R13)          FORWARD POINTER
         ST    R13,4(,R2)          BACKWARD POINTER
         LR    R15,R2              save sa ptr for a bit
         LM    R0,R2,20(R13)       restore input regs
         LR    R13,R15             R13 @ OUR SAVEAREA & WORKAREA
         MVC   0(4,R13),=C'&ID'    set eyecatcher
         USING XMTWA,R11           ALWAYS
         AIF   ('&WA' EQ '').MEND
         USING &WA,R13             SAVEAREA AND WORKAREA
.MEND    MEND
./ ADD NAME=UPSR     0100-02182-02182-0702-00047-00047-00000-XMIT370
         MACRO
&LABEL   UPSR &LEVEL,&TEXT,&VALUE,&SKIP=
.*
.* Copyright 2001, 2002 James M. Morrison
.*
.* LEVEL - see XMITDIAG macro
.* TEXT  - message to be displayed (string or RX-expression)
.*         For string, we insert <n> into string
.*         RX-expressions are on their own
.* VALUE - register to load into R0 before call to XMITPSR
.*
         LCLA  &LDBUG,&LSTR
         LCLC  &NDX
         LCLC  &DBUGBYT
         LCLC  &NEWTEXT,&STRING
&NDX     SETC  '&SYSNDX'
&LDBUG   SETA  K'&SYSECT
&DBUGBYT SETC  '&SYSECT'(5,&LDBUG-4)   set XMTD* byte name from CSECT
&LABEL   IM#SECT LABEL
         AIF   ('&LEVEL' EQ '0').GEN2       level=0 always runs
         CLI   XMTD&DBUGBYT,C'&LEVEL'       generate diag msg?
         AIF   ('&SKIP' EQ '').GEN
         BL    &SKIP                        no, br
         MEXIT
.GEN     ANOP
         BL    SKIP&NDX                     no, br
.GEN2    AIF   ('&VALUE' EQ '').NOVAL
         IM#LALR R0,&VALUE
.NOVAL   ANOP
.*
.*  &TEXT     'STRING' will generate correct call to XMITPSR.
.*    OR      RX-TYPE address or (reg) for buffer address
.*
.*  APPEND TRAILING % sign to denote R0 inclusion.
.*
         AIF   ('&TEXT'(1,1) EQ '''').STRING  1st char = '?
         IM#LALR R1,&TEXT              message address
         UCALL UTILPSR                 log msg w/ R0 in hex appended
         AGO   .SKIP
*
.STRING  ANOP
         BAL   R1,CALL&NDX             skip inline message text
         DC    C'<&LEVEL> ',C&TEXT,C' %'
CALL&NDX UCALL UTILPSR                 log msg w/ R0 in hex appended
.SKIP    ANOP
SKIP&NDX DS    0H
         MEND
./ ADD NAME=USNAP    0100-02182-02182-0702-00031-00031-00000-XMIT370
         MACRO
&LABEL   USNAP &TITLE,&ADDR,&LEN,&PLIST=WKSNAP,&MF=
.*
.* Copyright 2001, 2002 James M. Morrison
.*
         LCLC  &NDX
         LCLC  &L2
&NDX     SETC  '&SYSNDX'
         AIF   ('&MF' EQ 'L').MFL
&L2      SETC  'L''&ADDR'              assume &LEN default to L'&ADDR
         AIF   (T'&LEN EQ 'O').SKIP2
&L2      SETC  '&LEN'
.SKIP2   ANOP
         AIF   ('&TITLE'(1,1) NE '''').NSTR
&LABEL   BAL   R0,CODE&NDX             skip inline message text
LMSG&NDX DC    AL1(L'MSG&NDX)          message length
MSG&NDX  DC    C&TITLE
CODE&NDX IM#SECT LABEL
         AGO   .HVADR
.NSTR    IM#LALR R0,&TITLE
.HVADR   ST    R0,0+&PLIST
         IM#STA &ADDR,4+&PLIST         @ storage to snap
         IM#STA &L2,8+&PLIST           length or end address
         LA    R1,&PLIST               @ parm list
         UCALL UTILSNAP                display storage
         MEXIT
.*
.MFL     ANOP
&PLIST   DS    0F
&LABEL   DS    3F                      SNAP parmlist
         MEND
./ ADD NAME=UTILABND 0100-02182-02182-0702-00472-00472-00000-XMIT370
UTILABND TITLE 'UABEND macro support'
*
* Copyright 2001, 2002 James M. Morrison
*
*----------------------------------------------------------------------
*  Things to do:
*
*  1) Finish playing with Hercules diagnose, STSI, etc.  See *<>
*
*  2) Route codes on WTO (probably need to adjust offsets)
*
*----------------------------------------------------------------------
         U#SET DIAG=NO
*----------------------------------------------------------------------
* Function:    UABEND macro support routine to issue a few messages
*              before an XMIT370/RECV370 ABEND
*
* Entry: R0         SNAP/SDUMP parm
*
*                    BITS
*        R1         (00:07)  REASON code
*                   (08:19)  reserved
*                   (20:31)  ABEND code
*
*        R14 ->     SVC 13, followed immediately by option bytes:
*
*                   +00 (1) ABEND macro options
*
*                           1... .... DUMP
*                           .1.. .... STEP
*
*                   +01 (1) Parm validity bits
*
*                           1... .... R1(00:07) REASON code
*                           .1.. .... R1(20:31) ABEND code
*                           ..1. .... R0 SNAP/SDUMP parm reg
*                           .... ...1 +02, +03 option bytes present
*
*                   +02 (1) not currently generated by UABEND
*
*                   +03 (1) not currently generated by UABEND
*
* Exit:  Returns to callers' SVC 13 instruction (ABEND SVC)
*
* Notes: UABEND macro stored regs R14,R13 in &XMTABND before call.
*
*        UTILABND assumes caller follows normal XMIT370/RECV370
*        register conventions:
*
*        R11  -  XMTWA
*        R12  -  program base
*        R13  -  savearea/workarea
*
*        UTILABND returns to the caller's ABEND SVC, so that any
*        dumps reflect the actual code that wished to ABEND, rather
*        than issuing ABEND from here.
*
*        UTILABND calls UTILHEX, so UTILHEX isn't allowed to have
*        any errors or issue ABENDs.
*
*        UTILABND doesn't call ULOG/UPSR/UDIAG in case the XMITPRT
*        ddname either isn't present, didn't open, or those support
*        routines are issuing the UABEND macro.
*
*        UTILABND originally issued the WTL macro, but it didn't
*        seem to produce output under MVS38j, so the WTO macro is now
*        what is issued.
*
*----------------------------------------------------------------------
* R2
* R3
* R4     options
* R5     loop ctl
* R6     loop ctl
* R7     loop ctl
* R8     internal linkage
* R9     @ caller's savearea
* R10    @ caller's return, options
* R11    @ XMTWA
* R12    pgm base
* R13    @ savearea
*----------------------------------------------------------------------
         TITLE ' '
UTILABND UPROC ID=UABD,L=L$SAV
         EJECT ,
*----------------------------------------------------------------------
*  Zappable options for UTILABND
*----------------------------------------------------------------------
         B     INIT
*
         DS    0F
ABOPT    DS    0XL4               UTILABND option bytes
*
*                01234567
*
ABOPT1   DC    B'10000000'        IBM ABEND macro options
*                1.......         DUMP
*                .1......         STEP
*
ABOPT2   DC    B'00000000'        spare
*
ABOPT3   DC    B'00000000'        spare
*
ABOPT4   DC    B'00000000'        spare
*
*  UABEND currently only defines 2 option bytes
*
UOPTMASK EQU   B'1100'            ICM mask for UABEND option bytes
*
*
ABOPT5   DC    B'00000000'        UTILABND overrides
AB5IGN1 EQU 128  1.......         ignore UABEND 1st option byte
AB5IGN2 EQU 64   .1......         ignore UABEND 2nd option byte
AB5IGN3 EQU 32   ..1.....         ignore UABEND 3rd option byte
AB5IGN4 EQU 16   ...1....         ignore UABEND 4th option byte
*
ABOPT6   DC    B'00000000'        spare
*
         EJECT ,
*----------------------------------------------------------------------
*  Initialize
*----------------------------------------------------------------------
INIT     DS    0H
         L     R9,4(,R13)              @ caller's SA
         L     R10,12(,R9)             caller's R14 @ SVC 13 + options
*----------------------------------------------------------------------
*  Ignore UABEND option bytes as per ABOPT5
*----------------------------------------------------------------------
         SLR   R4,R4
         ICM   R4,UOPTMASK,2(R10)      grab UABEND option bytes
*
         TM    ABOPT5,AB5IGN1
         BNO   *+8
         ICM   R4,8,ZERO               ignore UABEND 1st option byte
*
         TM    ABOPT5,AB5IGN2
         BNO   *+8
         ICM   R4,4,ZERO               ignore UABEND 2nd option byte
*
         TM    ABOPT5,AB5IGN3
         BNO   *+8
         ICM   R4,2,ZERO               ignore UABEND 3rd option byte
*
         TM    ABOPT5,AB5IGN4
         BNO   *+8
         ICM   R4,1,ZERO               ignore UABEND 4th option byte
*----------------------------------------------------------------------
*  If ABOPT specified a value, make sure it gets used
*----------------------------------------------------------------------
         O     R4,ABOPT                assert ABOPT choices
         ST    R4,SAOPTS               save options bytes in SA
*----------------------------------------------------------------------
*  If we're recursing give up hope right now
*----------------------------------------------------------------------
         MVC   SARABND(16*4),XMTABEND  in case of recursion
         TM    XMTFLG1,XMT1ABND        UABEND recursing?
         BO    RECURSE                 abandon all hope
*
         OI    XMTFLG1,XMT1ABND        UABEND in progress
*----------------------------------------------------------------------
*  Handle ABEND, REASON code(s)
*----------------------------------------------------------------------
         L     R0,20(,R9)              UABEND R0 contents
         ST    R0,SARUR0               UABEND R0 contents
         TM    SAOPT1,SA1SNAP          valid SNAP/SDUMP parm?
         BNO   *+8
         ST    R0,SAPARM0              ABEND R0 value
*
         L     R0,24(,R9)              UABEND R1 contents
         ST    R0,SARUR1               UABEND R1 contents
         TM    SAOPT1,SA1RSN           valid reason code?
         BNO   *+8
         STCM  R0,8,SAREASON+3         yes
*
         TM    SAOPT1,SA1COD           valid abend code?
         BNO   NORSN
         N     R0,=X'00000FFF'
         ST    R0,SAABEND              yes
NORSN    DS    0H
*----------------------------------------------------------------------
*  Set up WTO macro expansion & BR R8 in savearea
*----------------------------------------------------------------------
         MVC   SAWTO,MODLWTO           copy model WTO
         MVC   SAWTORET,MODLRET        copy BR instruction
*----------------------------------------------------------------------
*  Issue initial ABEND explanation message
*----------------------------------------------------------------------
         MVI   SAWTXT,C' '                       blank out
         MVC   SAWTXT+1(L'SAWTXT-1),SAWTXT       WTO text area
         MVC   SAWTXT(L'MSGABEND),MSGABEND
         MVC   SAWTXT+MAFUNC(4),XMTEYE           XMIT/RECV
         L     R1,SARUR12                        @ caller's CSECT
         MVC   SAWTXT+MAPGM(8),ID-UTILABND(R1)   caller's pgm name
         L     R0,SAREASON
         LA    R1,SAJUNK
         UCALL UTILHEX
         MVC   SAWTXT+MARSN(2),SAJUNK+6          caller's reason (hex)
*<>      BAL   R8,HSNGL                          single-step Hercules
         BAL   R8,SAWTO                          issue WTO
*----------------------------------------------------------------------
*  Display regs prior to abend
*----------------------------------------------------------------------
         MVI   SAWTXT,C' '                       blank out
         MVC   SAWTXT+1(L'SAWTXT-1),SAWTXT       WTO text area
         MVC   SAWTXT(L'MSG0),MSG0     copy MSG
         LA    R5,SARABND              @ 1st abend reg value
         LA    R6,SAWREG               @ 1st text reg slot
         LA    R7,4                    # regs shown in msg
*
LINE1    DS    0H
         L     R0,0(,R5)               UTILHEX input (R0)
         LR    R1,R6                   UTILHEX output CL8
         UCALL UTILHEX                 convert reg to display hex
         LA    R5,4(,R5)
         LA    R6,9(,R6)
         BCT   R7,LINE1
         BAL   R8,SAWTO                issue WTO from savearea
*
         MVI   SAWTXT,C' '                  blank out
         MVC   SAWTXT+1(L'SAWTXT-1),SAWTXT  WTO text area
         MVC   SAWTXT(L'MSG1),MSG1     copy MSG
         LA    R6,SAWREG               @ 1st text reg slot
         LA    R7,4                    # regs shown in msg
*
LINE2    DS    0H
         L     R0,0(,R5)               UTILHEX input (R0)
         LR    R1,R6                   UTILHEX output CL8
         UCALL UTILHEX                 convert reg to display hex
         LA    R5,4(,R5)
         LA    R6,9(,R6)
         BCT   R7,LINE2
         BAL   R8,SAWTO                issue WTO from savearea
*
         MVI   SAWTXT,C' '                  blank out
         MVC   SAWTXT+1(L'SAWTXT-1),SAWTXT  WTO text area
         MVC   SAWTXT(L'MSG2),MSG2     copy MSG
         LA    R6,SAWREG               @ 1st text reg slot
         LA    R7,4                    # regs shown in msg
*
LINE3    DS    0H
         L     R0,0(,R5)               UTILHEX input (R0)
         LR    R1,R6                   UTILHEX output CL8
         UCALL UTILHEX                 convert reg to display hex
         LA    R5,4(,R5)
         LA    R6,9(,R6)
         BCT   R7,LINE3
         BAL   R8,SAWTO                issue WTO from savearea
*
         MVI   SAWTXT,C' '                  blank out
         MVC   SAWTXT+1(L'SAWTXT-1),SAWTXT  WTO text area
         MVC   SAWTXT(L'MSG3),MSG3     copy MSG
         LA    R6,SAWREG               @ 1st text reg slot
         LA    R7,4                    # regs shown in msg
*
LINE4    DS    0H
         L     R0,0(,R5)               UTILHEX input (R0)
         LR    R1,R6                   UTILHEX output CL8
         UCALL UTILHEX                 convert reg to display hex
         LA    R5,4(,R5)
         LA    R6,9(,R6)
         BCT   R7,LINE4
         BAL   R8,SAWTO                issue WTO from savearea
         UDIAG 9,'UTILABND savearea',SAVEAREA,L$SAV
*----------------------------------------------------------------------
*  Close XMITPRT before ABENDING to flush pending messages
*----------------------------------------------------------------------
CLOSE    DS    0H
         SLR   R1,R1
         UCALL UTILLOG
*----------------------------------------------------------------------
*  Things haven't gone very well for XMIT370/RECV370
*----------------------------------------------------------------------
ABEND    DS    0H
*<>      IC    R1,SAMASK1              retrieve system's old mask
*<>      EX    R1,RESET                return to normal PSW mask
*<>      BAL   R14,STPROB              return to problem state
*
         L     R0,SAPARM0              SNAP/SDUMP parm
         L     R1,DEFABND              default abend code
         TM    SAOPT1,SA1COD           valid abend code?
         BNO   *+8
         L     R1,SAABEND              abend code
         ICM   R1,8,SAOPT0             ABEND options
*
         LR    R14,R10                 restore caller's return addr
         L     R15,SARUR15                restore caller's regs
         LM    R2,R13,SARUR2              except R0, R1, and R14
         BR    R14                     return to caller's ABEND SVC
*
DEFABND  DC    F'200'                  default abend code
RESET    STOSM SAMASK2,0
         EJECT ,
*----------------------------------------------------------------------
*  Hercules-assisted debugging code
*----------------------------------------------------------------------
HSNGL    DS    0H
         STM   R14,R1,SATEMP
         BAL   R14,STSUPR              check/enter SUPERVISOR state
         STNSM SAMASK1,B'10111100'     disable PER, I/O, EXTERNAL
         TM    XMTFLG2,XMT2QID         CPUid queried for Herc presence?
         BO    HSNGL1
*
         L     R0,STSIR0
         L     R1,STSIR1
         L     R15,=F'4096'
         LA    R14,SAEND
         LA    R14,X'FFF'(R15,R14)
         N     R14,=X'FFFFF000'
*        STSI  SASYSIB                 store system info
         DC    X'B27D',S(0)  S(0(R14)) store system info
         BC    1,NOSYSIB               cc=3, no SYSIB stored
         USNAP 'UTILABND SYSIB',(R14),(R15)
         OI    XMTFLG2,XMT2QID         queried CPUid, XMT2HERC valid
*
* R0(00:07)    Version code = X'FF' when under VM and/or Hercules
* R0(08:31)    CPU identification number
* R1(00:15)    Model number
* R1(16:31)    Maximum MCEL length
*
HSNGL1   DS    0H
         HERC  HDI$SNGL                single step Hercules emulator
         NOPR  0                       something for ifetch
NOSYSIB  DS    0H
         LM    R14,R1,SATEMP
         BR    R8
*
STSIR0   DC    F'0'
STSIR1   DC    F'1'
HDI$NORM EQU   3840                    normal execution
HDI$SNGL EQU   3844                    single step execution
*----------------------------------------------------------------------
*  State switch subroutines
*----------------------------------------------------------------------
STPROB   DS    0H
         TM    XMTFLG2,XMT2SUPR        entered SUPERVISOR state?
         BNOR  R14
         STM   R14,R1,SATEMP2
         MODESET MODE=PROB
         LM    R14,R1,SATEMP2
         NI    XMTFLG2,255-XMT2SUPR    PROBLEM state
         BR    R14
*
STSUPR   DS    0H
         TM    XMTFLG2,XMT2SUPR        entered SUPERVISOR state?
         BOR   R14
         STM   R14,R1,SATEMP3
         MODESET MODE=SUP
         LM    R14,R1,SATEMP3
         OI    XMTFLG2,XMT2SUPR        SUPERVISOR state
         BR    R14
*----------------------------------------------------------------------
*  Recursive UABENDs, WTO & bail
*----------------------------------------------------------------------
RECURSE  DS    0H
         STM   R0,R15,SACURSE
         WTO   'UTILABND recursing; ABEND U(400)'
         ABEND 400,DUMP
*----------------------------------------------------------------------
*  Data areas
*----------------------------------------------------------------------
MODLWTO  WTO   '123456789/123456789/123456789/123456789/123456789/'
L$WTO    EQU   *-MODLWTO
L$TXT    EQU   50                      maximum text length
MODLRET  BR    R8
*
*                0123456789/123456789/123456789/123456789/123456789
MSGABEND DC    C'xxxx370 ABENDing in xxxxyyyy reason xx'
MAFUNC   EQU   00,4
MAPGM    EQU   20,8
MARSN    EQU   36,2
*
MSG0     DC    C'R14 - R1'
MSG1     DC    C'R2  - R5'
MSG2     DC    C'R6  - R9'
MSG3     DC    C'R10 - R13'
*
ZERO     DC    F'0'
PATCH    DC    64S(*)
*
         LTORG ,
*----------------------------------------------------------------------
*  Dynamic savearea & workarea - based R13
*----------------------------------------------------------------------
SAVEAREA DSECT ,
SAVREGS  DS    18F
SACURSE  DS    16F
*
SAPARM0  DS    F                       UTILABND parm R0
SAPARM1  DS    F                       UTILABND parm R1
SAREASON DS    F                       UTILABND reason code
SAABEND  DS    F                       UTILABND abend code
*
SAOPTS   DS    F                       UTILABND options from UABEND
*
SAOPT0   EQU   SAOPTS+0,1              IBM ABEND macro options
SA0DUMP  EQU   128                     ABEND n,DUMP
SA0STEP  EQU   64                      ABEND n,,STEP
*
SAOPT1   EQU   SAOPTS+1,1              UTILABND parm validity options
SA1RSN   EQU   128                     REASON code valid
SA1COD   EQU   64                      ABEND code valid
SA1SNAP  EQU   32                      SNAP/SDUMP parm reg R0
SA1MORE  EQU   1                       Options +2 & +3 valid
*
SAOPT2   EQU   SAOPTS+2,1              spare
SAOPT3   EQU   SAOPTS+3,1              spare
*
*
SARABND  DS    16F                     XMTABEND copied here @ entry
SARUR14  EQU   SARABND+0
SARUR15  EQU   SARABND+4
SARUR0   EQU   SARABND+(2*4)+(00*4)
SARUR1   EQU   SARABND+(2*4)+(01*4)
SARUR2   EQU   SARABND+(2*4)+(02*4)
SARUR3   EQU   SARABND+(2*4)+(03*4)
SARUR4   EQU   SARABND+(2*4)+(04*4)
SARUR5   EQU   SARABND+(2*4)+(05*4)
SARUR6   EQU   SARABND+(2*4)+(06*4)
SARUR7   EQU   SARABND+(2*4)+(07*4)
SARUR8   EQU   SARABND+(2*4)+(08*4)
SARUR9   EQU   SARABND+(2*4)+(09*4)
SARUR10  EQU   SARABND+(2*4)+(10*4)
SARUR11  EQU   SARABND+(2*4)+(11*4)
SARUR12  EQU   SARABND+(2*4)+(12*4)
SARUR13  EQU   SARABND+(2*4)+(13*4)
*
         DS    0F
SAWTO    DS    XL(L$WTO)               WTO macro copied here
SAWTXT   EQU   SAWTO+08,L$TXT          text area
SAWREG   EQU   SAWTXT+10,8             1st reg display hex area
SAWTORET BR    R8                      return instruction copied here
*
SAJUNK   DS    CL8                     UTILHEX return area
*
SAFLAG1  DS    X                       status flags
SA1SUPVR EQU   128                     entered SUPVR state
*
SACPUID  DS    D                       STIDP return
SATEMP   DS    4F                      temp savearea
SATEMP2  DS    4F                      temp savearea
SATEMP3  DS    4F                      temp savearea
SAMASK1  DS    X                       PSW mask, bits 0:7
SAMASK2  DS    X                       PSW mask, bits 0:7
*
         DS    0D
SAEND    DS    0D
L$SAV    EQU   *-SAVEAREA              length of savearea
*
         WAXMT FUNC=UTIL,GEN=,DATA=,PRINT=ON
         EJECT ,
*----------------------------------------------------------------------
*  Address of regs saved in XMTABEND by UABEND macro (relative R11)
*----------------------------------------------------------------------
ABNDR0   EQU   XMTABEND+(2*4)+(00*4)
ABNDR1   EQU   XMTABEND+(2*4)+(01*4)
ABNDR2   EQU   XMTABEND+(2*4)+(02*4)
ABNDR3   EQU   XMTABEND+(2*4)+(03*4)
ABNDR4   EQU   XMTABEND+(2*4)+(04*4)
ABNDR5   EQU   XMTABEND+(2*4)+(05*4)
ABNDR6   EQU   XMTABEND+(2*4)+(06*4)
ABNDR7   EQU   XMTABEND+(2*4)+(07*4)
ABNDR8   EQU   XMTABEND+(2*4)+(08*4)
ABNDR9   EQU   XMTABEND+(2*4)+(09*4)
ABNDR10  EQU   XMTABEND+(2*4)+(10*4)
ABNDR11  EQU   XMTABEND+(2*4)+(12*4)
ABNDR12  EQU   XMTABEND+(2*4)+(12*4)
ABNDR13  EQU   XMTABEND+(2*4)+(13*4)
ABNDR14  EQU   XMTABEND+0
ABNDR15  EQU   XMTABEND+4
*
UTILABND UFINI DXDUABND,L$SAV
         END   ,
./ ADD NAME=UTILDBUG 0100-02182-02182-0702-00277-00277-00000-XMIT370
UTILDBUG TITLE 'Parse XMITDBUG ddname, set debug options'
*
* Copyright 2001, 2002 James M. Morrison
*
*----------------------------------------------------------------------
*  Things to do:
* 1) Maybe someday, move XMITDLEV code from XMIT370, move here.
*    Keep PARM= ptr setting code in XMIT370.
* 3) Add support for comments (1st char = *, #, or ;) in XMITDBUG
*    to enable addition of debug level notes for each CSECT
*----------------------------------------------------------------------
         U#SET ,
*----------------------------------------------------------------------
* Function: Parse XMITDBUG ddname, set debugging option bytes
*           XMTD* in XMTWA.  The values for each byte vary from
*           C'0' to C'9', and control XMITDIAG/XMITPSR macro execution.
*
* XMITDBUG syntax:
*
*           Each XMIT370 CSECT has one statement which is used to
*           set it's corresponding debug byte.  The syntax is
*
*               Column  1: CSECT name (upcase)
*               Column 10: debug value (C'0' - C'9')
*
*           Blank debug values are allowed, and ignored so that
*           a standard list of CSECTs may be maintained and only
*           modified when needed.
*
*           When CSECT name = 'DEFAULT', all debug bytes are primed
*           with this value.  When used, it should appear as the
*           first line of input.
*
*           Before XMITDBUG is processed, all debug bytes are
*           set to whatever XMIT370 set XMITDLEV to
*           (C'0' or PARM= value).
*
* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*
*
*         R0  =
*         R1  =
*
* Exit:   R15 = return code
*         R15 = 00 success
*
* Abends:
*
* Notes:    This routine manages the XMITDBUG DCB, no one else
*           need worry about it.  The ddname is optional.
*----------------------------------------------------------------------
* Reg  DSECT    usage
*----------------------------------------------------------------------
* R2            ptr to debug byte for current CSECT
* R3   INREC    input record
* R4
* R5   TABLE    BXLE index
* R6            BXLE increment
* R7            BXLE compare value (table limit)
* R8   DCBD     XMITDBUG DCB
* R9
* R10           saved R13 across GET macro
* R11  XMTWA    common
* R12           base reg
* R13  XDGWA    savearea
*----------------------------------------------------------------------
         TITLE ' '
*----------------------------------------------------------------------
UTILDBUG UPROC L=L$XDGWA,ID=UDBG,WA=XDGWA
         UDIAG 1,'UTILDBUG entered'
*----------------------------------------------------------------------
*  Initialize XMTD* values to default (set by XMIT370)
*----------------------------------------------------------------------
         MVC   XMTDLEV+1(XMTDEND-XMTDLEV-1),XMTDLEV   propagate value
*----------------------------------------------------------------------
*  Initialize XDGWA workarea
*----------------------------------------------------------------------
         MVC   XDGDCB(L$DCB),MODLDCB        copy model DCB macro
         MVC   XDGOPN(L$OPN),MODLOPN        copy model OPEN macro
         MVI   XDGEOF,0                     not EOF
*----------------------------------------------------------------------
*  Open DCB
*----------------------------------------------------------------------
         LA    R8,XDGDCB
         USING IHADCB,R8
         LA    R1,DCBDDNAM                  DDNAME=XMITDBUG
         UCALL UTILTIOT                     ddname allocated?
         LTR   R1,R1
         BZ    RCZERO                       nope, never mind
*
         OPEN  (XDGDCB,INPUT),MF=(E,XDGOPN)
         TM    DCBOFLG1,DCBOFOPN            opened?
         BNO   RCZERO                       no, don't cares why, done
*
         UDIAG 2,'UTILDBUG processing XMITDBUG ddname'
*----------------------------------------------------------------------
*  Read input record
*----------------------------------------------------------------------
         LR    R10,R13                      preserve our savearea
READ     DS    0H
         LA    R13,XDGDMSA                  give GET it's own sa
*
         GET   (R8)                         locate record
*
         LR    R13,R10                      back to R13
         CLI   XDGEOF,X'00'                 EOF?
         BNE   ENDOFILE                     yes, br
*
         LR    R3,R1                        ptr to input record
         USING INREC,R3
*----------------------------------------------------------------------
*  Process input record
*----------------------------------------------------------------------
PROCESS  DS    0H
         ICM   R5,15,=V(UTILVTAB)           @ VCON table header
         BZ    OOPS
*
         LM    R5,R7,0(R5)                  index, incr, limit
         USING VTABLE,R5
         CLC   =CL8'DEFAULT',INAME          setting DEFAULT?
         BNE   CKCSECT
*
         MVC   XMTDLEV,INVAL
         MVC   XMTDLEV+1(XMTDEND-XMTDLEV-1),XMTDLEV  propagate default
         B     READ
*
CKCSECT  DS    0H
         CLC   VTABNAME,INAME               found CSECT name?
         BNE   CKNEXT                       no, advance index
*
         CLI   INVAL,C' '                   blank ... ignore
         BE    READ                         (but shows CSECT entry)
*
         LH    R2,VTABOFF                   debug byte offset
         LA    R15,XMTDLEV(R2)              @ debug byte
         MVC   0(1,R15),INVAL               set debug byte
         B     READ
*
CKNEXT   DS    0H
         BXLE  R5,R6,CKCSECT                find CSECT name in table
*
         UDIAG 1,'UTILDBUG unknown CSECT ignored',(R3),L$IN
         B     READ
*
OOPS     ULOG  'UTILDBUG - installation error'
         ULOG  'UTILDBUG - unable to locate UTILVTAB CSECT'
         UABEND ,
         EJECT ,
*----------------------------------------------------------------------
*  EOF - close DCB
*----------------------------------------------------------------------
EOFRTN   DS    0H                           EODAD exit routine
         MVI   XDGEOF-XDGWA(R10),1          hit EOF, set flag
         BR    R14                          return to GET macro
*
ENDOFILE DS    0H
         MVC   XDGCLOS(L$CLOS),MODLCLOS     copy model CLOSE macro
         CLOSE (XDGDCB,),MF=(E,XDGCLOS)
         EJECT ,
*----------------------------------------------------------------------
*  Show some info about each CSECT, and give XMTWA's address
*----------------------------------------------------------------------
*
*  Issue the diagnostics AFTER input has been handled, so XMITDBUG's
*  debug byte has a user-selected value
*  The SKIP=RCZERO skips the following code (thru BXLE) if the
*  diagnostic level is less than 1.
*
         UDIAG 1,SKIP=RCZERO
*
*  Say where XMTWA is located
*
         UPSR  1,'UTILDBUG XMTWA @ %',(R11)
*
         L     R5,=V(UTILVTAB)              @ VCON table header
         LM    R5,R7,0(R5)                  index, incr, limit
*
*  For each CSECT, issue message containing:
*  debug level, address, CSECT name, assembly date and time
*
VCONLOOP DS    0H
         MVI   XDGBUF,C' '                  blank out buffer
         MVC   XDGBUF+1(L$XDGBUF-1),XDGBUF
*
         MVC   XDGBEYE,=C'<1> '             fake diag level prefix
*
         LH    R2,VTABOFF                   debug byte offset
         LA    R15,XMTDLEV(R2)              @ debug byte
         MVC   XDGBLVL,0(R15)               copy debug byte to msg
*
         L     R0,VTABVCON                  CSECT addr
         LA    R1,XDGBADR                   display hex
         UCALL UTILHEX                      convert R0 to display hex
         MVC   XDGBCS,VTABNAME              copy CSECT name
*
         ICM   R15,15,VTABVCON              @ CSECT or zero
         BZ    MESSAGE
*
         MVC   XDGBCS,5(R15)                copy CSECT
         MVC   XDGBDATE,13(R15)             copy asm date
         MVC   XDGBTIME,21(R15)             copy asm time
*
MESSAGE  ULOG  XDGBUF,L$XDGBUF              display message
*
         BXLE  R5,R6,VCONLOOP               next CSECT
         EJECT ,
*----------------------------------------------------------------------
*  Return to caller with zero return code
*----------------------------------------------------------------------
RCZERO   DS    0H
         L     R5,=V(UTILVTAB)              @ VCON table header
         LM    R5,R7,0(R5)                  index, incr, limit
         UDIAG 3,'UTILDBUG DEBUG BYTES',XMTDLEV,XMTDEND
         UDIAG 3,'UTILDBUG CSECT table',(R5),(R7)
         UPEND RC=0
         EJECT ,
*----------------------------------------------------------------------
*  Data areas
*----------------------------------------------------------------------
MODLOPN  OPEN  (,),MF=L                model OPEN
L$OPN    EQU   *-MODLOPN               l' model open
*
MODLCLOS CLOSE (,),MF=L                model CLOSE
L$CLOS   EQU   *-MODLCLOS              l' model close
*
MODLDCB  DCB   DDNAME=XMITDBUG,MACRF=GL,DSORG=PS,RECFM=FB,LRECL=80,    +
               EODAD=EOFRTN
L$DCB    EQU   *-MODLDCB
*
         LTORG ,
         EJECT ,
*----------------------------------------------------------------------
*  XDGWA workarea
*----------------------------------------------------------------------
XDGWA    DSECT ,
XDGSA    DS    18F
XDGOPN   OPEN  0,MF=L
XDGCLOS  CLOSE 0,MF=L
XDGEOF   DS    X                       set not = X'00' on EOF
XDGDCB   DCB   DDNAME=XMITDBUG,MACRF=GL,DSORG=PS,RECFM=FB,LRECL=80,    +
               EODAD=EOFRTN
XDGDMSA  DS    18F                     data management (GET) savearea
*
XDGBUF   DS    0C                      diagnostic message buffer
XDGBEYE  DS    C'<1> '
XDGBLVL  DS    C                       diagnostic level
         DS    C
XDGBADR  DS    CL8                     CSECT address
         DS    C
XDGBID   DS    0C                      CSECT name, asm date/time
XDGBCS   DS    CL8                     CSECT name
         DS    C
XDGBDATE DS    CL8                     CSECT assembly date
         DS    C
XDGBTIME DS    CL7                     CSECT assembly time
L$XDGBUF EQU   *-XDGBUF                length of buffer
*
         DS    0D
L$XDGWA  EQU   *-XDGWA
*----------------------------------------------------------------------
*  Input record
*----------------------------------------------------------------------
INREC    DSECT ,
INAME    DS    CL8           CSECT name
         DS    C             ignored
INVAL    DS    C             Debug value - C'0' to C'9' (assumed)
L$IN     EQU   *             length of significant part of input rec
         EJECT ,
         DVTAB ,
         EJECT ,
         WAXMT FUNC=UTIL
*
         PRINT NOGEN
         DCBD  DSORG=PS,DEVD=DA
*
         PRINT ON,GEN
UTILDBUG UFINI DXDUDBUG,L$XDGWA
         END   ,
./ ADD NAME=UTILHEX  0100-02182-02182-0702-00060-00060-00000-XMIT370
UTILHEX  TITLE 'Convert R0 into displayable hex'
*
* Copyright 2001, 2002 James M. Morrison
*
*----------------------------------------------------------------------
         U#SET ,
*----------------------------------------------------------------------
* Function:    converts R0 into displayable hex
*
* Entry:  R0 = contents of R0 to be converted & displayed
*         R1 = address of CL8 field to receive output
*              when zero, this field is not modified
*
* Exit:   R15 =  0     everything is OK
*         R0  =  1st word of output
*         R1  =  2nd word of output
*
* Notes:  UTILHEX is called by UTILABND, and is neither allowed to have
*         errors in its code, nor to issue ABEND/UABEND.
*
*----------------------------------------------------------------------
UTILHEX  UPROC ID=UHEX,L=L$SAV
*
         ST    R0,WKFWORD              value to translate
         UNPK  WKWORK,WKFWORD(5)       spread out digits
         LA    R15,HEXCHAR             addressability game
         LA    R14,C'0'
         SR    R15,R14
         TR    WKWORK,0(R15)           hexchar-c'0' translate to char
         LTR   R1,R1                   caller supplied field addr?
         BZ    RETREGS                 no, return regs only
*
         MVC   0(8,R1),WKWORK          copy input msg to caller's buf
*
RETREGS  LM    R0,R1,WKWORK            return values
*
         UPEND R0=PASS,R1=PASS,RC=0    return to caller
*
         LTORG ,
*
HEXCHAR  DC    C'0123456789ABCDEF'     Hex translate table
*----------------------------------------------------------------------
*  Dynamic savearea & workarea
*----------------------------------------------------------------------
SAVEAREA DSECT ,
SAVREGS  DS    18F
*
WKFWORD  DS    F,C
*
         DS    0F
WKWORK   DS    CL9                     8 bytes plus trailing slop byte
*
         DS    0D                      align
L$SAV    EQU   *-SAVEAREA              length of savearea
*
         PRINT NOGEN
         WAXMT FUNC=UTIL
         PRINT GEN
UTILHEX  UFINI DXDUHEX,L$SAV
         END   ,
./ ADD NAME=UTILLOG  0100-02182-02182-0702-00118-00118-00000-XMIT370
UTILLOG  TITLE 'LOG output line to XMITPRT ddname'
*
* Copyright 2001, 2002 James M. Morrison
*
*----------------------------------------------------------------------
*  Things to do:
*----------------------------------------------------------------------
         U#SET ,
*----------------------------------------------------------------------
* Function: Write output line to XMITPRT ddname
*
* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*
*
*         R0  =  text length
*         R1  =  Address of text to be written
*                when 0, XMITPRT DCB will be closed.
*
* Exit:   R15 = 0
*
* Abends: U0001 DCB didn't open
*
* Notes:  UTILLOG maintains the XMITPRT DCB, opening it as required.
*----------------------------------------------------------------------
* R2
* R3     DCB
* R4     input buffer
* R5     length of input buffer
* R6
* R7
* R8
* R9
* R10
* R11    XMTWA
* R12    base reg
* R13    savearea
*----------------------------------------------------------------------
         TITLE ' '
*----------------------------------------------------------------------
UTILLOG  UPROC L=L$LOGWA,ID=ULOG,WA=LOGWA
         LA    R3,XMTDCBL
         USING IHADCB,R3
         LTR   R5,R1                        @ text, or CLOSE request
         BZ    CLOSE
*
         LR    R4,R0                        l'text
         TM    DCBOFLG1,DCBOFOPN            dcb open?
         BO    NORMAL
*----------------------------------------------------------------------
*  Initialize
*----------------------------------------------------------------------
         MVC   XMTDCBL(L$DCB),MODLDCB        copy model DCB macro
         MVC   LWAOPN(L$OPN),MODLOPN         copy model OPEN
         OPEN  XMTDCBL,MF=(E,LWAOPN)
         TM    DCBOFLG1,DCBOFOPN            opened?
         BO    NORMAL
         WTO   'UTILLOG: XMITPRT ddname did not open'
         UABEND ,                           output DCB didn't open
*----------------------------------------------------------------------
*  Close XMITPRT
*----------------------------------------------------------------------
CLOSE    DS    0H
         MVC   XMTCLOS(L$CLOS),MODLCLOS     copy model CLOSE macro
         TM    DCBOFLG1,DCBOFOPN            XMITPRT open?
         BNO   EXITRC0
         CLOSE XMTDCBL,MF=(E,XMTCLOS)
         FREEPOOL XMTDCBL
         B     EXITRC0
*----------------------------------------------------------------------
*  Normal write request
*----------------------------------------------------------------------
NORMAL   DS    0H
         XC    LWARESV,LWARESV              clear reserved
         A     R4,=A(L'LWAPFX+L'LWARESV+L'LWACC)
         STH   R4,LWAPFX                    set vb file's rdw
         S     R4,=A(L'LWAPFX+L'LWARESV+L'LWACC)
         MVI   LWACC,C' '                   set carriage control
         BCTR  R4,0
         EX    R4,COPY                      copy record to buffer
         LA    R0,LWAPFX                    record address
         PUT   XMTDCBL                      write record
*
EXITRC0  SLR   R15,R15                      set good return code
EXIT     DS    0H
         UPEND ,
*
COPY     MVC   LWABUF(*-*),0(R5)            executed
*
MODLOPN  OPEN  (,OUTPUT),MF=L          model OPEN
L$OPN    EQU   *-MODLOPN               l' model open
*
MODLCLOS CLOSE (,),MF=L                model CLOSE
L$CLOS   EQU   *-MODLCLOS              l' model close
*
MODLDCB  DCB   DDNAME=XMITPRT,                                         +
               MACRF=PM,DSORG=PS,RECFM=VBA,                            +
               LRECL=133+4,BLKSIZE=6144
L$DCB    EQU   *-MODLDCB
*
         LTORG ,
*----------------------------------------------------------------------
LOGWA    DSECT ,
         DS    18F
LWAOPN   OPEN  (,),MF=L
         DS    0F
LWAPFX   DS    H                       rdw length (includes l' rdw)
LWARESV  DS    H                       rdw reserved
LWACC    DS    C' '                    asa carriage control
LWABUF   DS    CL133                   output record
         DS    0D
L$LOGWA  EQU   *-LOGWA
         EJECT ,
         WAXMT FUNC=UTIL
         EJECT ,
         PRINT NOGEN
         DCBD  DSORG=PS,DEVD=DA
         PRINT GEN
UTILLOG  UFINI DXDULOG,L$LOGWA
         END   ,
./ ADD NAME=UTILPSR  0100-02182-02182-0702-00116-00116-00000-XMIT370
UTILPSR  TITLE 'PRINT String and Register 0'
*
* Copyright 2001, 2002 James M. Morrison
*
*----------------------------------------------------------------------
         U#SET ,
*----------------------------------------------------------------------
* Function:    converts R0 into displayable hex, then
*              appends converted data onto input message text,
*              finally calls XMITLOG to output completed
*              text.
*
* Entry:  R0 = contents of R0 to be converted & displayed
*         R1 = address of message text, delimited by trailing % sign.
*
* Exit:   R15 =  0     everything is OK
*                else  error
*
*----------------------------------------------------------------------
* R2     ptr to currently scanning char in input buffer
* R3     max chars allowed to be scanned
* R4     length of input message text (not including % sign)
* R5     ptr to slot for converted R0 in our buffer
* R6
* R7
* R8     input R0
* R9     input message text ptr
* R10
*----------------------------------------------------------------------
         TITLE ' '
UTILPSR  UPROC ID=UPSR,L=L$SAV
         EJECT ,
*
         LR    R8,R0              save input R0
         LA    R9,0(R1)           save msg text ptr
*----------------------------------------------------------------------
*  Convert R0 contents to displayable hex
*----------------------------------------------------------------------
XLATE    DS    0H
         ST    R0,WKFWORD              value to translate
         UNPK  WKWORK,WKFWORD(5)       spread out digits
         LA    R15,HEXCHAR
         LA    R14,C'0'
         SR    R15,R14
         TR    WKWORK,0(R15)           hexchar-c'0' translate to char
*----------------------------------------------------------------------
*  Find end of input message
*----------------------------------------------------------------------
L$MAXIN  EQU   120                maximum allowed input text length
*
         LR    R2,R9                   @ beginning of input msg txt
         LA    R3,L$MAXIN
SCAN     DS    0H
         CLI   0(R2),C'%'
         BE    HIT
*
         LA    R2,1(,R2)
         S     R3,=F'1'           too many chars scanned?
         BP    SCAN               not yet, ok to keep looking
*
*----------------------------------------------------------------------
*  Copy input message (less % sign) to our buffer
*----------------------------------------------------------------------
HIT      DS    0H
         MVI   WKMSG,C' '
         MVC   WKMSG+1(L'WKMSG-1),WKMSG
*
         LR    R4,R2
         SR    R4,R9              calc msg length
*        BCTR  R4,0               minus one for execute
         EX    R4,EXMVC           copy input msg to our buffer
*----------------------------------------------------------------------
*  Append displayable hex contents of R0 to our buffer
*----------------------------------------------------------------------
         LA    R5,WKMSG(R4)       @ spot to put data
         MVC   0(8,R5),WKWORK     append converted data
         LA    R5,8(,R5)          past last char
         LA    R0,WKMSG
         SR    R5,R0              length of message
*----------------------------------------------------------------------
*  Output our buffer
*----------------------------------------------------------------------
         ULOG WKMSG,(R5)          print out the message
*----------------------------------------------------------------------
*  Return to caller
*----------------------------------------------------------------------
EXIT     UPEND                    RETURN to caller
*
EXMVC    MVC   WKMSG(*-*),0(R9)   copy input msg to our buffer
*
         EJECT ,
*
         LTORG ,
*
*  Placed last so it's addressable as hexchar-c'0'
*  Oops, still not enough ... use base reg instead
*
HEXCHAR  DC    C'0123456789ABCDEF'     Hex translate table
*----------------------------------------------------------------------
*  Dynamic savearea & workarea
*----------------------------------------------------------------------
SAVEAREA DSECT ,
SAVREGS  DS    18F
WKMSG    DS    CL(L$MAXIN+9)      input msg, blank, 8 bytes of hex
WKFWORD  DS    F
         DS    F                  slop ... must be behind WKFWORD
WKWORK   DS    CL9                8 bytes plus trailing slop byte
         DS    XL20                    spare
         DS    0D                      align
L$SAV    EQU   *-SAVEAREA              length of savearea
         EJECT ,
         WAXMT FUNC=UTIL
*
         PRINT GEN
UTILPSR  UFINI DXDUPSR,L$SAV
         END   ,
./ ADD NAME=UTILSNAP 0100-02182-02182-0702-00318-00318-00000-XMIT370
UTILSNAP TITLE 'DIAGNOSTIC tool: display storage'
*
* Copyright 2001, 2002 James M. Morrison
*
*----------------------------------------------------------------------
*  Things to do:
*  1)  Display length of snap in hex & decimal
*----------------------------------------------------------------------
         U#SET ,
*----------------------------------------------------------------------
*
* Function: display dump-formatted storage on XMITLOG ddname
*
* Input:  R1 points at following parameter list:
*
*  +0     Zero or address of TITLE (see below).
*
*  +4     Address of virtual storage address at which to begin.
*
*  +8     Address of virtual storage address at which to end.
*         Alternatively, this parameter may contain the length
*         of storage to be displayed, rather than an address.
*
*         TITLE:
*
*         The length of the title is determined by the following
*         technique:  if the first byte of the title < 60,
*         then the first byte is the length of following title.
*         Otherwise, the title is delimited by X'00'.
*         The title's maximum length is 60.
*
*         R13 points to caller-provided savearea
*
*         R14 return address
*
*         R15 entry point address of this routine
*
* Output: Input data displayed.
*
*         R15 =  00
*
* Notes:
*----------------------------------------------------------------------
         TITLE ' '
UTILSNAP UPROC L=L$SAV,ID=USNP,WA=SAVEAREA
         EJECT ,
*
* Initialize
*
         LM    R3,R5,0(R1)             save input parms
         STM   R3,R5,PARMS
**************************************************************
* Process title
**************************************************************
         LTR   R3,R3                   title supplied?
         BZ    NOTITLE                 no, br
*
         ULOG  ' '                     blank line
*
         CLI   0(R3),MAXLEN            1st byte length?
         BH    SCANTITL                no, br ... need to scan
*
         SLR   R6,R6
         IC    R6,0(R3)                get title's length
         LA    R7,1(,R3)               1st byte of title
         B     TITLEOUT
*
SCANTITL DS    0H
         LR    R7,R3                   @ 1st byte of title
         TRT   0(MAXLEN,R3),ZVALID     scan for non-display
         BZ    MAXLENT                 found all displayable
*
         SR    R1,R3                   calculate length
         LR    R6,R1
         C     R6,=A(MAXLEN)           too long?
         BNH   TITLEOUT
*
MAXLENT  DS    0H
         LA    R6,MAXLEN               set maximum title length
*
TITLEOUT DS    0H
         LR    R0,R6                   length of title
         LR    R1,R7                   address of title
         UCALL UTILLOG                 print title
*
MAXLEN   EQU   60                      Maximum title length
NOTITLE  DS    0H
**************************************************************
* Display storage specifications
**************************************************************
         MVC   CLABEL,=C'DISPLAYING '
         MVI   CRANGE,C':'             set range char
*
         L     R0,@START               starting address
         LA    R1,CSTART               char format
         BAL   R14,XLATE               convert to display hex
*
         LM    R14,R15,@START
         CR    R15,R14                 ending addr > starting?
         BH    USE@END                 yes, ok to use
*
         AR    R15,R14                 calculate ending addr
         ST    R15,@END                fake out parmlist
*
USE@END  DS    0H
         L     R0,@END                 ending address
         BCTR  R0,0                    minus one
         LA    R1,CEND                 char format
         BAL   R14,XLATE               convert to display hex
*
         MVI   CSPACE1,C' '
         L     R0,@END
         S     R0,@START
         LA    R1,CHEXLEN              length (hex)
         BAL   R14,XLATE
*
         LA    R0,L$SPECS
         LA    R1,CLABEL               label following output
         UCALL UTILLOG                 type output
**************************************************************
* Format output line(s)
**************************************************************
FORMAT   DS    0H
         XC    DISPL,DISPL             zero displacement
         L     R4,@START               @ beginning of area
*        N     R4,=X'FFFFFFFC'         align on fullword boundary
*
FLINE    DS    0H
         LR    R8,R4                   storage @ start of line
         MVI   CFORMAT,C' '
         MVC   CFORMAT+1(L$FORMAT-1),CFORMAT    clear line,
         MVI   CSTAR1,C'*'                      delimit
         MVI   CSTAR2,C'*'                      char area
*
         LR    R0,R4
         LA    R1,CADDR
         BAL   R14,XLATE               make ADDRESS char
*
         L     R0,DISPL
         LA    R1,CJUNK
         BAL   R14,XLATE               make DISPLACEMENT char
         MVC   CDISPL(4),CJUNK+4       copy last 4 digits
         A     R0,=F'16'               using 4 fullwords
         ST    R0,DISPL                setup for next time
*
         LA    R5,4                    # word slots avail
         LA    R6,CWORD1               @ first slot
*
FLOOP    DS    0H
         ICM   R0,15,0(R4)             grab 1st 4 bytes
         LA    R1,CBYTES               workarea
         BAL   R14,XLATE               make 1st word char
* copy only right # chars from CYTES to CWORDn
         LM    R14,R15,CBYTES          get display hex in regs
         L     R1,@END                 addr last char to display
         SR    R1,R4                   calc # chars to put in CWORDn
PUTC     STCM  R14,8,0(R6)             put char in CWORDn
         STCM  R14,4,1(R6)
         SLDL  R14,16                  discard char
         LA    R6,2(,R6)
         LTR   R14,R14                 got 'em all?
         BZ    BUMPC                   yep
         S     R1,=F'1'
         BP    PUTC
BUMPC    DS    0H
         LA    R4,4(,R4)               setup for next time
         LA    R6,1(,R6)               space between CWORDs
*
         C     R4,@END                 displayed enough?
         BNL   FCHAR                   yes, do chars now
         S     R5,=F'1'                one less slot
         BP    FLOOP                   still have some left
*
*        Format character display portion of output line
*
FCHAR    DS    0H
         LA    R9,16                   # chars in char display
         LR    R15,R8                  @ begin of line's data
         LA    R14,CCHAR
         MVC   CCHAR,=CL16' '          init to blanks
*
CLOOP    DS    0H
         MVC   0(1,R14),0(R15)         copy for displaying
         LA    R15,1(,R15)
         LA    R14,1(,R14)
         C     R15,@END
         BNL   CLOOP2
         S     R9,=F'1'
         BP    CLOOP
*
CLOOP2   DS    0H
         TR    CCHAR,ZDISP             convert non-display
         LR    R8,R4                   now done with those
*
         LA    R0,L$FORMAT             length of output line
         LA    R1,CFORMAT              addr of output line
         UCALL UTILLOG                 type output
*
         C     R4,@END                 more lines to format?
         BL    FLINE                   yes, br
**************************************************************
* Return to caller
**************************************************************
EXIT     DS    0H
         SLR   R15,R15
         UPEND ,                       return to caller
         TITLE 'XLATE Subroutine'
**************************************************************
* XLATE subroutine
**************************************************************
*
* Input:   R0  = value to translate
*
*          R1  = address of 8 bytes to receive translated
*                "display hexadecimal" output
*
*          R14 = return address
*
XLATE    DS    0H
         ST    R0,FWORD                value to translate
         UNPK  XWORK,FWORD(5)          spread out digits
         TR    XWORK,HEXCHAR-C'0'      translate to char
         MVC   0(8,R1),XWORK           return data to caller
         BR    R14                     return to caller
*
HEXCHAR  DC    C'0123456789ABCDEF'     Hex translate table
         TITLE 'DATA AREAS'
**************************************************************
* Data areas (not modified)
**************************************************************
ZVALID   DS    0X
*                000102030405060708090A0B0C0D0E0F    ..
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' X'00'
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' X'10'
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' X'20'
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' X'30'
         DC    X'00FFFFFFFFFFFFFFFFFF000000000000' X'40'
         DC    X'00FFFFFFFFFFFFFFFFFF000000000000' X'50'
         DC    X'00FFFFFFFFFFFFFFFFFF000000000000' X'60'
         DC    X'FFFFFFFFFFFFFFFFFF00000000000000' X'70'
         DC    X'FF000000000000000000FFFFFFFFFFFF' X'80' a-i
         DC    X'FF000000000000000000FFFFFFFFFFFF' X'90' j-r
         DC    X'FF000000000000000000FFFFFFFFFFFF' X'A0' s-z
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' X'B0'
         DC    X'00000000000000000000FFFFFFFFFFFF' X'C0' A-I
         DC    X'00000000000000000000FFFFFFFFFFFF' X'D0' J-R
         DC    X'00FF0000000000000000FFFFFFFFFFFF' X'E0' S-Z
         DC    X'00000000000000000000FFFFFFFFFFFF' X'F0' 0-9
*                000102030405060708090A0B0C0D0E0F    ..
*
ZDISP    DS    0X
*                0123456789ABCDEF
         DC    C'................'                       X'00'
         DC    C'................'                       X'10'
         DC    C'................'                       X'20'
         DC    C'................'                       X'30'
         DC    X'40',C'.........',X'4A4B4C4D4E4F'        X'40'
         DC    X'50',C'.........',X'5A5B5C5D5E5F'        X'50'
         DC    X'60',C'.........',X'6A6B6C6D6E6F'        X'60'
         DC    C'.........',X'797A7B7C7D7E7F'            X'70'
         DC    C'.ABCDEFGHI',X'8A8B8C8D8E8F'             X'80'
         DC    C'.JKLMNOPQR',X'9A9B9C9D9E9F'             X'90'
         DC    C'.',X'A1',C'STUVWXYZ',X'AAABACADAEAF'    X'A0'
         DC    C'................'                       X'B0'
         DC    X'C0',C'ABCDEFGHI',X'CACBCCCDCECF'        X'C0'
         DC    X'D0',C'JKLMNOPQR.',X'DBDCDDDEDF'         X'D0'
         DC    X'E0',C'.STUVWXYZ',X'EAEB',C'.',X'EDEEEF' X'E0'
         DC    C'0123456789......'                       X'F0'
*                0123456789ABCDEF
*
         LTORG ,
         TITLE 'DSECTS'
**************************************************************
* Dynamic savearea & workarea
**************************************************************
SAVEAREA DSECT ,
         DS    19F
XWORK    DC    CL9' '
FWORD    DC    F'0'
*
PARMS    DS    0XL12                   parmlist:
@TITLE   DC    A(0)                    A(title)
@START   DC    A(0)                    A(beginning of storage)
@END     DC    F'0'                    A(end of storage)
*
CLABEL   DC    C'DISPLAYING '
CSTART   DC    CL8' '
CRANGE   DC    C':'
CEND     DC    CL8' '
CSPACE1  DC    C' '
CHEXLEN  DC    CL8' '
L$SPECS  EQU   *-CLABEL                length of stor specs
*
CFORMAT  DS    0C
CADDR    DC    C'XXXXYYYY  '           address
CDISPL   DC    C'DDDD  '               displacement
CWORD1   DC    C'AABBCCDD '            1st word
CWORD2   DC    C'AABBCCDD '            2nd word
CWORD3   DC    C'AABBCCDD '            3rd word
CWORD4   DC    C'AABBCCDD '            4th word
CSTAR1   DC    C'*'
CCHAR    DC    C'....++++....++++'     char values
CSTAR2   DC    C'*'
L$FORMAT EQU   *-CFORMAT               length of output line
*
         DS    0F                      align
CBYTES   DC    C'AABBCCDD '            CWORDn workarea
*
         DS    0F
CJUNK    DC    CL8' '
DISPL    DC    F'0'
         DS    0D
L$SAV    EQU   *-SAVEAREA              length of savearea
         EJECT ,
         WAXMT FUNC=UTIL
         PRINT GEN
UTILSNAP UFINI DXDUSNAP,L$SAV
         END   ,
./ ADD NAME=UTILTIOT 0100-02182-02182-0702-00110-00110-00000-XMIT370
*
* Copyright 2001, 2002 James M. Morrison
*
         PRINT  NOGEN
         IHAPSA DSECT=YES              PREFIXED STORAGE AREA
*
         IKJTCB DSECT=YES,LIST=NO      TASK CONTROL BLOCK
*
TIOT     DSECT
         IEFTIOT1                      TASK INPUT-OUTPUT TABLE
*
         PRINT GEN
UTILTIOT TITLE 'Scan TIOT for DDNAME'
*----------------------------------------------------------------------
*
*  UTILTIOT is called before UTILDIAG has finished setting up the
*  debug bytes, so UTILTIOT's message(s) always appear.
*  Not really very useful, and mildly annoying.  The DIAG=NO
*  suppresses expansion of XMITDIAG in this CSECT.
*
         U#SET DIAG=NO                 suppress XMITDIAG
*----------------------------------------------------------------------
* Function:    Given a DDNAME, determine whether it is allocated
*              by scanning the TIOT.
*
* Entry:  R0 =
*         R1 = address of CL8'ddname' field
*
* Exit:   R1  =  address of TIOT entry
*                0     DDNAME not allocated
*
* Notes:
*
*----------------------------------------------------------------------
         TITLE ' '
*----------------------------------------------------------------------
* R2     TIOT entry
* R3
* R4
* R5
* R6
* R7
* R8
* R9     DDNAME ptr
* R10
*----------------------------------------------------------------------
UTILTIOT UPROC ID=UTIO,L=L$SAV
         LR    R9,R1                        save caller's R1
         UDIAG 1,'UTILTIOT entered'
         UDIAG 3,'UTILTIOT: ddname',(R9),8
         EJECT ,
*----------------------------------------------------------------------
*  Find TIOT, see if ddname allocated
*----------------------------------------------------------------------
         USING PSA,0
         L     R15,PSATOLD             my TCB
         USING TCB,R15
*
         L     R14,TCBTIO              TCB's TIOT
         DROP  R15
         USING TIOT1,R14
*
         LA    R2,TIOENTRY             @ 1st entry
         DROP  R14
         USING TIOENTRY,R2
*
         SLR   R6,R6
*
NEXTENT  DS    0H
         ICM   R6,1,TIOELNGH           TIOT entry length
         BZ    EOT                     no more entries
*
         CLC   TIOEDDNM,0(R9)          found DDNAME?
         BE    FOUND
*
         LA    R2,0(R6,R2)             @ next entry
         B     NEXTENT
*
EOT      DS    0H
         UDIAG 3,'UTILTIOT ddname not allocated'
         XC    SARETVAL,SARETVAL       TIOT entry ptr = 0
         B     EXIT
*
FOUND    DS    0H
         UDIAG 3,'UTILTIOT ddname allocated'
         ST    R2,SARETVAL             TIOT entry ptr
*----------------------------------------------------------------------
*  Return to caller
*----------------------------------------------------------------------
EXIT     UDIAG 1,'UTILTIOT exited'
         L     R1,SARETVAL             return value = TIOT ptr or 0
         SLR   R15,R15
         UPEND R1=PASS                 return to caller w/ R1 intact
*
         LTORG ,
*----------------------------------------------------------------------
*  Dynamic savearea & workarea
*----------------------------------------------------------------------
SAVEAREA DSECT ,
SAVREGS  DS    18F
SARETVAL DS    F                       return value (R1)
         DS    0D
L$SAV    EQU   *-SAVEAREA              length of savearea
*
         PRINT NOGEN
         WAXMT FUNC=UTIL
*
         PRINT GEN
UTILTIOT UFINI DXDUTIOT,L$SAV
         END   ,
./ ADD NAME=UZERO    0100-02182-02182-0702-00022-00022-00000-XMIT370
         MACRO
&LABEL   UZERO &ADDR,&LENGTH
.*
.* Copyright 2001, 2002 James M. Morrison
.*
&LABEL   IM#LALR R0,&ADDR              destination address
         AIF   ('&LENGTH'(1,1) EQ '(').LALR
         AIF   ('&LENGTH'(1,1) EQ '*').LALR
         AIF   ('&LENGTH'(1,1) EQ '.').LALR
.*
         L     R1,=A(&LENGTH)          destination length
         AGO   .JOIN
.*
.LALR    IM#LALR R1,&LENGTH            destination length
.*
.*       Put off clearing R15 until the last possible moment
.*       in case the contents of R0 & R1 above depend on R15
.*       Also, since R15 is zero we don't need to set R14
.*
.JOIN    SLR   R15,R15                 source length
         MVCL  R0,R14                  set storage to x'00'
         MEND
./ ADD NAME=WARGS    0100-02182-02182-0702-00037-00037-00000-XMIT370
         MACRO
         WARGS &SECT=DSECT
.*
.* Copyright 2001, 2002 James M. Morrison
.*
*----------------------------------------------------------------------
*  WARGS: RECVGET workarea (embedded in WAXMT)
*----------------------------------------------------------------------
RGSWA    IM#SECT &SECT                 RECVGET workArea
*
RGSFLG1  DS    X                       status flag 1
RGS1FINI EQU   128                     segment complete
RGS1RES  EQU   1                       residual data valid
*
RGSFLG2  DS    X                       status flag 2
RGS2EOF  EQU   1                       XMITIN EOF
*
         DS    0D
RGSROFF  DS    H                       residual data offset w/i RGSBUF
RGSBUF   DS    XL80                    residual data
*
RGSSL    DS    H                       # bytes in RGSSEG
RGSSEG   DS    XL255                   segment buffer (XMITSEG)
*
L$RGSNAP EQU   *-RGSWA                 length of RECVGET exit SNAP
         DS    CL80                    slop for RECVGET overexuberance
*
RGSOPN   OPEN  (,),MF=L
RGSCLOS  CLOSE (,),MF=L
*
RGSDCB   DCB   DDNAME=XMITIN,                                          +
               MACRF=GM,DSORG=PS,RECFM=FB,                             +
               LRECL=80
*
         DS    0D
L$RGSWA  EQU   *-RGSWA                 L'RGSWA
         MEND
./ ADD NAME=WAXMT    0100-02182-02182-0702-00192-00192-00000-XMIT370
         MACRO
         WAXMT &FUNC=XMIT,&GEN=NO,&DATA=NO,&PRINT=OFF
.*
.* Copyright 2001, 2002 James M. Morrison
.*
.*---------------------------------------------------------------------
.* &FUNC  - XMIT, RECV, or UTIL
.* &GEN   - NO, or null
.* &DATA  - NO, or null
.* &PRINT - ON, or OFF
.*---------------------------------------------------------------------
         PUSH  PRINT,USING
         PRINT &PRINT.,&GEN.GEN,&DATA.DATA
.*
         AIF   ('&FUNC' NE 'XMIT').NOPS
         EJECT ,
         WAXPS ,                       need length of XMITPUT workarea
.NOPS    AIF   ('&FUNC' NE 'RECV').NOGS
         EJECT ,
         WARGS ,                       need length of RECVGET workarea
.NOGS    ANOP
         EJECT ,
*----------------------------------------------------------------------
* XMTWA: XMIT370 and RECV370 common workarea - based R11
*----------------------------------------------------------------------
XMTWA    DSECT ,
XMTEYE   DC    C'XMITDSA '             eyecatcher
*
XMTSA1   DS    18F                     XMIT370/RECV370 savearea
XMTLDSA  DS    F                       # bytes gotten for DSA
XMTRC    DS    F                       XMIT370 return code
XMT@PARM DS    A                       address of OS entry parm
*----------------------------------------------------------------------
*  Global status flags
*----------------------------------------------------------------------
XMTFLG1  DS    X
XMT1ABND EQU   128                     UABEND in progress
XMTF1$U  EQU   64                      XMTDCBI is unloaded DS
*
XMTFLG2  DS    X
XMT2SUPR EQU   128                     Supervisor state
XMT2HERC EQU   64                      Hercules emulator present
XMT2QID  EQU   32                      CPUid queried, XMT2HERC valid
*
XMTFLG3  DS    X
*
XMTFLG4  DS    X
*----------------------------------------------------------------------
*  Debug bytes
*----------------------------------------------------------------------
*
*  Debug level bytes, set by XMITDBUG, tested by XMITDIAG & XMITPSR
*  One byte per CSECT that issues XMITDIAG or XMITPSR
*  Values range from C'0' (always issue msg) or C'9'
*  XMITDIAG & XMITPSR manufacture the XMTDxxxx name from CSECT name
*
         DS    0F
XMTDLEV  DS    C             default from PARM=
XMTDABND DS    C                       UTILABND
XMTDBLK  DS    C                       RECVBLK
XMTDBUF  DS    C                       XMITBUF
XMTDCPR1 DS    C                       XMITCPR1
XMTDCTL  DS    C                       RECVCTL
XMTDDBUG DS    C                       UTILDBUG
XMTDDIR  DS    C                       XMITDIR
XMTDESZ  DS    C                       XMITESZ
XMTDGET  DS    C                       RECVGET
XMTDHEX  DS    C                       UTILHEX
XMTDLOG  DS    C                       UTILLOG
XMTDPSR  DS    C                       UTILPSR
XMTDPUT  DS    C                       XMITPUT
XMTDRCPY DS    C                       RECVRCPY
XMTDSNAP DS    C                       UTILSNAP
XMTDTIOT DS    C                       UTILTIOT
XMTDUNLD DS    C                       XMITUNLD
XMTDUTIL DS    C                       RECVUTIL
XMTD01   DS    C                       XMIT01
XMTD02A  DS    C                       XMIT02A
XMTD02B  DS    C                       XMIT02B
XMTD03   DS    C                       XMIT03
XMTD06   DS    C                       XMIT06
XMTD370  DS    C                       XMIT370/RECV370
XMTDEND  EQU   *                       end of diagnostic area
         DS    CL4                     spares
*----------------------------------------------------------------------
*  Data management areas
*----------------------------------------------------------------------
XMT@PS   DS    A                       @ XPSWA XMITPUT workarea
XMT@GS   EQU   XMT@PS,4                @ XGSWA RECVGET workarea
*
XMTOPN   OPEN  (,),MF=L
XMTCLOS  CLOSE (,),MF=L
*
XMT@JFCB DS    A                       @ JFCB for open XMTDCBI
XMTJFCBL DS    F                       JFCB exlst for XMTDCBI
*
         DS    0F
XMTJFCB1 DS    XL176                   SYSUT1 JFCB area
*
         DS    0F
XMTJFCB2 DS    XL176                   SYSUT2 JFCB area
*
*  XMIT02A fills in 44 byte dsn from JFCB, to make IEFJFCBN
*  offsets usable (based from XMTDSCB), and debug ease.
*
         DS    0F
XMTDSCB  DS    CL44                    SYSUT1 DSCB dsname
*
*  Format-1 DSCB of dataset to be XMIT'd.
*  OBTAIN macro returns first 96 bytes of XMTDSCB1 = data portion
*  of DSCB, next 5 bytes = CCHHR of DSCB (zero for VSAM/VIO).
*
         DS    0F
XMTDSCB1 DS    XL140                   SYSUT1 OBTAIN area
*----------------------------------------------------------------------
* Input DCB
*----------------------------------------------------------------------
XMTDCBI  DCB   DDNAME=SYSUT2,                                          +
               MACRF=PM,DSORG=PS,RECFM=VB,                             +
               LRECL=0,BLKSIZE=6144
*----------------------------------------------------------------------
* Output DCB
*----------------------------------------------------------------------
XMTDCBO  DCB   DDNAME=OUTPUT,                                          +
               MACRF=PM,DSORG=PS,RECFM=FB,                             +
               LRECL=80,BLKSIZE=3200
*----------------------------------------------------------------------
* Log DCB
*----------------------------------------------------------------------
XMTDCBL  DCB   DDNAME=XMITPRT,                                         +
               MACRF=PM,DSORG=PS,RECFM=FB,                             +
               LRECL=80,BLKSIZE=6080
*----------------------------------------------------------------------
*  Debug areas
*----------------------------------------------------------------------
         DS    0D
         USNAP MF=L                    common diagnostic parmlist
*
         DS    0D
XMTREGS  DS    16F                     R0:R15  - diagnostic workarea
*
         DS    0D
XMTABEND DS    16F                     R14:R13 - pre-ABEND
*
XMTZAP   DS    8F                      zap workarea
.*
.*  FUNC=XMIT or FUNC=RECV workarea
.*
.*
.*  The following areas vary depending on whether or not we're
.*  running as XMIT370 or RECV370.  Any data common to both
.*  should occur before here.  FUNC=UTIL code may not place
.*  data following this point.
.*
         AIF   ('&FUNC' NE 'XMIT').NOXMIT
*----------------------------------------------------------------------
*  XMITPUT's workarea
*----------------------------------------------------------------------
         DS    0D
XMTXPSWE DC    CL8'PUTWORK '
XMTXPSWA DS    XL1024                  1K reserved for XMITPUT workarea
XXPUT    EQU   1024-L$XPSWA            Asm error if workarea exceeds 1K
         AGO   .FINI
.*
.NOXMIT  AIF   ('&FUNC' NE 'RECV').NORECV
*----------------------------------------------------------------------
*  RECVGET's workarea
*----------------------------------------------------------------------
         DS    0D
XMTRGSWE DC    CL8'GETWORK '           RECVGET workarea eyecatcher
XMTRGSWA DS    XL1024                  1K reserved for RECVGET workarea
XXGET    EQU   1024-L$RGSWA            Asm error if workarea exceeds 1K
         AGO   .FINI
.*
.NORECV  AIF   ('&FUNC' NE 'UTIL').FINI
*----------------------------------------------------------------------
*  Space allocated for either XMITPUT or RECVGET workarea
*  Note FUNC=UTIL routines may not use any of this space
*----------------------------------------------------------------------
         DS    0D
XMTXUTL1 DC    CL8'xxxWORK '           GETWORK or PUTWORK
XMTXUTL2 DS    XL1024                  1K - XPSWA or RGSWA
         AGO   .FINI
.*
.FINI    ANOP
*----------------------------------------------------------------------
*  End of XMTWA
*----------------------------------------------------------------------
XMTFINI  DS    0D                      end of XMTWA
L$XMTWA  EQU   *-XMTWA
         POP   PRINT,USING
         MEND  ,
./ ADD NAME=WAXPS    0100-02182-02182-0702-00029-00029-00000-XMIT370
         MACRO
         WAXPS &SECT=DSECT
.*
.* Copyright 2001, 2002 James M. Morrison
.*
*----------------------------------------------------------------------
*  WAXPS: XMIT370 PUTSEG support workarea (embedded in WAXMT)
*  Our eyecatcher is in XMTWA, and is 'PUTWORK '
*----------------------------------------------------------------------
XPSWA    IM#SECT &SECT                 Xmit370 PutSeg WorkArea
XPSSA    DS    18F                     savearea for QSAM
XPSFLG1  DS    X                       status flag
XPS1OPN  EQU   128                     DCB opened (once is enough)
*
         DS    0D
XPSRL    DS    F                       residual length in XPSSEG
XPSSEG   DS    XL(12+80)               segment workarea + slop
*
         DS    0D
XPSOPN   OPEN  (,),MF=L
XPSCLOS  CLOSE (,),MF=L
XPSEXL   DS    4F                      DCB exit list
*
XPSDCB   DCB   DDNAME=SYSUT1,                                          +
               MACRF=PM,DSORG=PS,RECFM=FB,                             +
               LRECL=80,BLKSIZE=3200   might need EXLST to fix blksize
         DS    0D
L$XPSWA  EQU   *-XPSWA                 L'XPSWA
         MEND
./ ADD NAME=XMITBUF  0100-02182-02182-0702-00110-00110-00000-XMIT370
XMITBUF  TITLE 'SPLIT buffer into segment(s), write'
*
* Copyright 2001, 2002 James M. Morrison
*
*----------------------------------------------------------------------
*  Things to do:
*----------------------------------------------------------------------
         U#SET ,
*----------------------------------------------------------------------
* Function: Given a BSAM buffer, split the buffer into segment(s),
*           and write the segments by calling XMITPUT (PUTSEG).
*
* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*
*
*         R0  = length of buffer
*         R1  = address of buffer
*
* Exit:   R15 = return code
*         R15 = 00 success
*
* Abends:
*
* Notes:
*----------------------------------------------------------------------
* R2     XBUWA
* R3     2 (constant)
* R4     @ segment data
* R5     length remaining in segment data
* R6     length of input buffer = blksize
* R7     address of input buffer
* R8     length of segment to be written
* R9     253 (constant)
* R10
* R11    XMTWA
* R12    base reg
* R13    savearea
*----------------------------------------------------------------------
         TITLE ' '
*----------------------------------------------------------------------
XMITBUF  UPROC L=L$XBUWA,ID=XBUF,WA=XBUWA
         LR    R6,R0
         LR    R7,R1
         UDIAG 1,'XMITBUF entered'
         UDIAG 3,'XMITBUF input block',(R7),(R6)
*----------------------------------------------------------------------
* Create segment
*----------------------------------------------------------------------
         LA    R3,L'XBUSEGL+L'XBUSEGF  l' overhead
         LA    R9,L'XBUSEGD            max # seg data bytes permitted
         MVI   XBUSEGF,SEG$1           turn on 'first' flag
SPLIT    DS    0H
         LTR   R6,R6                   anything left in buffer?
         BNP   EXITRC0
         LR    R8,R9                   assume max # bytes in segment
         CR    R6,R9
         BH    NOTLAST
         OI    XBUSEGF,SEG$L           last segment
         LR    R8,R6
NOTLAST  DS    0H
         AR    R8,R3                   segment length (except flag)
         STC   R8,XBUSEGL
         SR    R8,R3
         BCTR  R8,0
         EX    R8,COPY                 copy buffer data to segment
         LA    R8,1(,R8)
         LA    R7,0(R8,R7)             bump to next avail char
         SR    R6,R8
*----------------------------------------------------------------------
* Write INMR03 segment
*----------------------------------------------------------------------
WRITE    DS    0H
         LA    R1,XBUSEG
         UCALL XMITPUT                 write INMR03 segment
         NI    XBUSEGF,255-SEG$1       not first segment anymore
         LTR   R15,R15
         BZ    SPLIT
         BNZ   EXIT
*
EXITRC0  DS    0H
         SLR   R15,R15
*
EXIT     DS    0H
         ST    R15,XBURC
         UDIAG 1,'XMITBUF exited'
         L     R15,XBURC
         UPEND ,
*
COPY     MVC   XBUSEGD(*-*),0(R7)      copy data
*
         LTORG ,
         EJECT ,
*----------------------------------------------------------------------
XBUWA    DSECT ,
XBUSA    DS    18F
*
XBURC    DS    F             return code
XBUSEG   DS    0D            segment
XBUSEGL  DS    X             segment length
XBUSEGF  DS    X             segment flag
XBUSEGD  DS    XL253         segment data
         DS    0D
L$XBUWA  EQU   *-XBUWA
         EJECT ,
         PRINT NOGEN
         DXMITSEG ,
         EJECT ,
         WAXMT FUNC=XMIT
         PRINT GEN
XMITBUF  UFINI DXDXBUF,L$XBUWA
         END   ,
./ ADD NAME=XMITCPR1 0100-02182-02182-0702-00356-00356-00000-XMIT370
*
* Copyright 2001, 2002 James M. Morrison
*
         PRINT  NOGEN
*
         DCBD   DSORG=PS,DEVD=DA
*
JFCB     DSECT ,
         IEFJFCBN ,
L$JFCB   EQU   *-JFCB
*
DSCB1    DSECT ,
         IECSDSL1 (1)                  FORMAT-1 DSCB
*
*  The following 'DX' definition(s) are to allow us to assemble on
*  either MVS38j or something more modern.  They echo the 'DS'
*  definitions in later MVS versions.
*
DX1SMSFG EQU   DS1DSNAM+X'4E',1          SMS indicators
DX1SCEXT EQU   DS1DSNAM+X'4F',3          secondary space extension
L$DSCB1  EQU   *-DSCB1
*
         PRINT GEN
         EJECT ,
         DCOPYR1 BDW=YES,RDW=YES
XMITCPR1 TITLE 'Fix IEBCOPY COPYR1 record'
*----------------------------------------------------------------------
         U#SET ,
*----------------------------------------------------------------------
* Function:    Given an IEBCOPY unload COPYR1 record, change it's
*              length as specified by the COPYR1 DDNAME's LRECL.
*              Fields in the extended section are filled in, where
*              possible, only if they are x'00's.
*
* Entry:  R0 =
*         R1 = address of IEBCOPY COPYR1 record's BDW
*
* Exit:   R15 =  0     everything is OK
*                else  error
*
* Notes:  The IEBCOPY program has changed the length and contents of
*         the COPYR1 record based on the maintenance level of IEBCOPY.
*
*         When the user wishes to create a COPYR1 record which doesn't
*         match the current level of IEBCOPY running on this system,
*         coding DCB attributes on the COPYR1 DDNAME will instruct this
*         code to modify the COPYR1 record before it's written to the
*         XMIT output file.  Following are the values to code on
*         COPYR1 DDNAME for various levels of IEBCOPY maintenance:
*
*         MVS38j      (RDW)  LRECL=56     payload: 52 bytes (x'34')
*         MVS/ESA     (RDW)  LRECL=60     payload: 56 bytes (x'38')
*
*         which is to say the LRECL= value specifies the length to
*         drop into the RDW, which is 4 greater than the payload's
*         (data following the RDW) length.
*
*         The DCB attributes are what are appropriate to RECEIVE the
*         XMIT file on the specified levels of MVS.  The COPYR1
*         allocation doesn't have to specify an actual dataset, it
*         can be DUMMY, as below:
*
*         //COPYR1  DD DUMMY,DCB=LRECL=xx
*
*         If no LRECL value is specified, XMITCPR1 will default
*         to the longest COPYR1 of which it is aware, which should
*         usually work pretty well.  In such a case, simply code
*
*         //COPYR1  DD DUMMY
*
*         Allowing the LRECL length to be coded might allow for
*         some future distinctions between further variations,
*         or possibly have use to someone modifying this code.
*
*----------------------------------------------------------------------
         TITLE ' '
*----------------------------------------------------------------------
* Register usage (except MODTAB code)
*----------------------------------------------------------------------
* R2     TIOT entry
* R3     DCB
* R4     JFCB
* R5
* R6     scratch
* R7     old COPYR1 record length
* R8     new COPYR1 record length
* R9     address of COPYR1 record (@ BDW)
* R10
*----------------------------------------------------------------------
XMITCPR1 UPROC ID=XCP1,L=L$SAV
         LR    R9,R1                        save caller's R1
         USING COPYR1,R9
         LH    R7,XC1BDW                    old COPYR1 BDW
         UDIAG 1,'XMITCPR1 entered'
         UDIAG 3,'XMITCPR1: COPYR1 block @ entry',(R9),(R7)
*----------------------------------------------------------------------
*  See if COPYR1 ddname allocated
*----------------------------------------------------------------------
         LA    R1,=CL8'COPYR1'         target DDNAME
         UCALL UTILTIOT                scan TIOT for DDNAME
         LTR   R1,R1                   found?
         BNZ   FOUND                   yes
*
NOTFOUND DS    0H
         ULOG  'XMITCPR1 found no COPYR1 ddname, COPYR1 unmodified'
         B     EXIT
         EJECT ,
*----------------------------------------------------------------------
*  COPYR1 ddname allocated, RDJFCB to retrieve LRECL=
*----------------------------------------------------------------------
FOUND    DS    0H
         LA    R3,SAVDCB
         USING IHADCB,R3
         MVC   SAVOPN(L$OPN),MODLOPN        copy model OPEN macro
         STCM  R3,7,SAVOPN+1                relocate DCB ptr
*
         MVC   SAVDCB(L$DCB),MYDCB          copy DCB
         LA    R0,SAVEXLST                  relocate DCB's EXLST
         STCM  R0,7,DCBEXLSA
*
         MVC   SAVEXLST(L$JFCBL),JFCBLST
         LA    R4,SAVJFCB                   relocate EXLST's JFCB addr
         USING JFCB,R4
         STCM  R4,7,SAVEXLST+1
*
         RDJFCB SAVDCB,MF=(E,SAVOPN)
         LTR   R15,R15
         BZ    SNAPJFCB
         UDIAG 0,'XMITCPR1: COPYR1 RDJFCB failed'
         UABEND ,
SNAPJFCB DS    0H
         UDIAG 3,'XMITCPR1: COPYR1 JFCB',SAVJFCB,L$JFCB
         EJECT ,
*----------------------------------------------------------------------
*  Modify the COPYR1 record length as per COPYR1 ddname specification
*----------------------------------------------------------------------
L$DEFR1  EQU   L$XC1CUR-L'XC1BDW            default new RDW length
*
         LA    R6,4                         L'BDW & L'RDW
         LH    R7,XC1RDW                    old COPYR1 LRECL (RDW)
         SR    R7,R6
         UPSR  3,'XMITCPR1 old COPYR1 payload length (hex)',(R7)
*
         SLR   R8,R8
         ICM   R8,3,JFCLRECL                user spec'd new RDW length
         BNZ   *+8
         LH    R8,=AL2(L$DEFR1)             default new RDW length
*
         SR    R8,R6
         UPSR  3,'XMITCPR1 new COPYR1 payload length (hex)',(R8)
         AR    R8,R6
         STH   R8,XC1RDW                    update COPYR1 RDW
         AR    R8,R6
         STH   R8,XC1BDW                    update COPYR1 BDW
         EJECT ,
         PUSH  USING
*----------------------------------------------------------------------
*  Modify the COPYR1 record as per MODTAB specification
*----------------------------------------------------------------------
* R0  = source value
* R2  @ modification destination field
* R3  @ modification source field
* R4  = modification length
* R5  = MODTAB BXLE index
* R6  = MODTAB BXLE increment
* R7  = MODTAB BXLE limit
* R8  = max COPYR1 offset we're allowed to change (approximate at best)
* R9  @ COPYR1 BDW
* R14 = modification destination offset
* R15 = modification source offset
*
         UDIAG 5,'XMITCPR1 DSCB',XMTDSCB,L$DSCB1
         UDIAG 5,'XMITCPR1 MODTAB',MODTAB,MODEND
         LM    R5,R7,=A(MODTAB,L$MODENT,MODEND-1)
         USING XMODTAB,R5
         BCTR  R8,0                            adjust max offset
         B     MODREC
*
MODSKIP  DS    0H                              modification skipped
         OI    SAFLAG1,SA1MDSKP
         UDIAG 5,'XMITCPR1 SKIP',XMTREGS,16*4,REGS=YES
*
MODREC   DS    0H
         UDIAG 9,'XMITCPR1: COPYR1 MODREC',(R9),80
         SLR   R14,R14
         ICM   R14,3,XMDSTOFF
         LA    R2,COPYR1(R14)                  destination field addr
*
         SLR   R15,R15
         ICM   R15,3,XMSRCOFF
         LA    R3,XMTDSCB(R15)                 source field addr
*
         SLR   R4,R4
         ICM   R4,3,XMDSTLEN                   field length
         BCTR  R4,0
         SLL   R4,2                            index RETRIEVE
*
         CR    R14,R8                          exceeded max offset?
         BH    MODFIN2
*
         SLR   R0,R0
         EX    R0,RETRIEVE(R4)                 source data
         LTR   R0,R0                           value retrieved?
         BZ    *+8                             no, place new value
         BXLE  R5,R6,MODSKIP                   yes, IEBCOPY knows best
*
         CLC   =X'0000',XMSRCLEN               hardcoded source?
         BE    MODHARD
*
MODNORML DS    0H                              normal value
         EX    R0,MODIFY(R4)                   destination data
         UDIAG 5,'XMITCPR1 NORM',XMTREGS,16*4,REGS=YES
         BXLE  R5,R6,MODREC
         B     MODFIN
*
MODHARD  DS    0H                              hard-coded value
         SLR   R0,R0
         ICM   R0,3,XMSRCOFF                   source data
         EX    R0,MODIFY(R4)                   modify destination data
         UDIAG 5,'XMITCPR1 HARD',XMTREGS,16*4,REGS=YES
         BXLE  R5,R6,MODREC
         B     MODFIN
*
RETRIEVE ICM   R0,1,0(R3)
         ICM   R0,3,0(R3)
         ICM   R0,7,0(R3)
         ICM   R0,15,0(R3)
*
MODIFY   STCM  R0,1,0(R2)
         STCM  R0,3,0(R2)
         STCM  R0,7,0(R2)
         STCM  R0,15,0(R2)
         POP   USING
*
XMODTAB  DSECT ,
XMDSTOFF DS    XL2                     destination field offset
XMDSTLEN DS    XL2                     destination field length
XMSRCOFF DS    XL2                     source field offset
XMSRCLEN DS    XL2                     source field length
XMITCPR1 CSECT ,
         EJECT ,
*----------------------------------------------------------------------
*  COPYR1 update complete
*----------------------------------------------------------------------
MODFIN   DS    0H
         TM    SAFLAG1,SA1MDSKP        modification(s) skipped?
         BNO   MODFIN3
MODFIN2  DS    0H
         STM   R0,R15,XMTREGS
         ULOG  'XMITCPR1 ignored some MODTAB updates'
         UDIAG 3,'XMITCPR1 regs',XMTREGS,16*4
MODFIN3  DS    0H
         LH    R6,0(,R9)                    COPYR1 BDW
         UDIAG 3,'XMITCPR1: COPYR1 block @ exit',(R9),(R6)
*----------------------------------------------------------------------
*  Return to caller
*----------------------------------------------------------------------
EXIT     UDIAG 1,'XMITCPR1 exited'
         UPEND ,                       return to caller
         EJECT ,
*----------------------------------------------------------------------
*  COPYR1 mods table
*----------------------------------------------------------------------
*
*  Format of table entry:
*
*     Destination offset, destination length
*     Source offset, source length,
*
*  when source length = 0, source offset is the value to be applied;
*  else source length = destination length.
*
*  Entries are in ascending destination offset order.
*
         PUSH  PRINT,USING
         PRINT DATA
         USING DSCB1,R15                       bogus using
*
MODTAB   DS    0D
         DC    AL2(XC1SMSFG-COPYR1,L'XC1SMSFG)
         DC    AL2(DX1SMSFG-DSCB1,L'DX1SMSFG)      SMS indicators
L$MODENT EQU   *-MODTAB
*
         DC    AL2(XC1HDRCT-COPYR1,L'XC1HDRCT)     hdrcount
         DC    AL2(2,0)
*
         DC    AL2(XC1RESV1-COPYR1,L'XC1RESV1)     resv1 = x'00'
         DC    AL2(0,0)
*
         DC    AL2(XC1LREFD-COPYR1,L'XC1LREFD)
         DC    AL2(DS1REFD-DSCB1,L'DS1REFD)        last ref date
*
         DC    AL2(XC1SCEXT-COPYR1,L'XC1SCEXT)
         DC    AL2(DX1SCEXT-DSCB1,L'DX1SCEXT)      secondary extent
*
         DC    AL2(XC1SCALO-COPYR1,L'XC1SCALO)
         DC    AL2(DS1SCALO-DSCB1,L'DS1SCALO)      secondary allocation
*
         DC    AL2(XC1LSTAR-COPYR1,L'XC1LSTAR)
         DC    AL2(DS1LSTAR-DSCB1,L'DS1LSTAR)      last used TTR
*
         DC    AL2(XC1TRBAL-COPYR1,L'XC1TRBAL)
         DC    AL2(DS1TRBAL-DSCB1,L'DS1TRBAL)      trk balance
*
         DC    AL2(XC1RESV2-COPYR1,L'XC1RESV2)     resv2 = x'0000'
         DC    AL2(0,0)
MODEND   EQU   *
         POP   PRINT,USING
         EJECT ,
MODLOPN  OPEN  (,INPUT),MF=L           model OPEN
L$OPN    EQU   *-MODLOPN               l' model open
*
         PUSH  PRINT
         PRINT NOGEN
MYDCB    DCB   DDNAME=COPYR1,EXLST=0,DSORG=PS,MACRF=E
L$DCB    EQU   *-MYDCB
         POP   PRINT
*
JFCBLST  DS    0F
         DC    XL1'87'
         DC    AL3(0)
L$JFCBL  EQU   *-JFCBLST
*
CAMLST   CAMLST SEARCH,1,2,3           OBTAIN parmlist
         LTORG ,
*----------------------------------------------------------------------
*  Dynamic savearea & workarea
*----------------------------------------------------------------------
SAVEAREA DSECT ,
SAVREGS  DS    18F
*
SAFLAG1  DS    X
SA1MDSKP EQU   128                     some MODTAB mod(s) skipped
*
         DS    0F
SAVOPN   OPEN  (,INPUT),MF=L           open parmlist
         PUSH  PRINT
         PRINT NOGEN
SAVDCB   DCB   DDNAME=COPYR1,DSORG=PS,MACRF=E
         POP   PRINT
SAVEXLST DS    F                       DCB EXLST=
         DS    0D                      align
SAVJFCB  DS    CL(L$JFCB)              JFCB
SAVCAML  CAMLST SEARCH,1,2,3           CAMLST
L$CAMLST EQU   *-SAVCAML
         DS    0D
SAVDSCB  DS    CL140                   Format1 DSCB (minus dsn), cchhr
         DS    CL5
         DS    0D
L$SAV    EQU   *-SAVEAREA              length of savearea
         EJECT ,
*
         WAXMT FUNC=XMIT,PRINT=OFF
*
XMITCPR1 UFINI DXDXCPR1,L$SAV
         END   ,
./ ADD NAME=XMITDIR  0100-02182-02182-0702-00149-00149-00000-XMIT370
XMITDIR  TITLE 'Determine Directory blocks allocated'
*
* Copyright 2001, 2002 James M. Morrison
*
*----------------------------------------------------------------------
*  Things to do:
*----------------------------------------------------------------------
         U#SET ,
*----------------------------------------------------------------------
* Function: Determine number of directory blocks allocated
*
* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*
*
*         R0  =
*         R1  =  open SYSUT1 DCB, DSORG=PO
*
* Exit:   R15 = return code
*         R15 = 00 success; R0 = # directory blocks
*
* Abends: input PDS broken in some way
*
* Notes:  It's OK for us to read the directory of the PDS, since no
*         one else (like XMIT02B) will read a DSORG=PO dataset.
*         Well, except IEBCOPY when we tell him to.
*----------------------------------------------------------------------
* R2     DCB
* R3
* R4     IOB
* R5     # dir blocks
* R6     DECB
* R7     DCBBLKSI
* R8     length of directory block
* R9     @ directory block
* R10
* R11    XMTWA
* R12    base reg
* R13    savearea
*----------------------------------------------------------------------
         TITLE ' '
*----------------------------------------------------------------------
XMITDIR  UPROC L=L$XDRWA,ID=XMDR,WA=XDRWA
         LR    R2,R1                   SYSUT1 open DCB
         USING IHADCB,R2
         UDIAG 1,'XMITDIR entered'
*----------------------------------------------------------------------
*  Initialize
*----------------------------------------------------------------------
         TM    DCBRECFM,DCBRECF        PDS directory must be recfm=f
         BNO   BROKEN
         TM    DCBRECFM,DCBRECU             recfm=u not acceptable
         BO    BROKEN
         LA    R0,EOFRTN
         STCM  R0,7,DCBEODA                 set EOF exit rtn addr
         MVC   XDRDECBI(L$DECB),MODLDECB    copy model DECB
         LH    R7,DCBBLKSI                  get blksize
         ST    R7,XDRBUFL
         GETMAIN R,LV=(R7)                  alloc input buffer
         LR    R9,R1
*
*  Read pds directory, counting directory blocks
*  This is offensively simple-minded, but there doesn't appear to be
*  an MVS control block which records the number of directory blocks
*  allocated to a PDS; even the DSCB doesn't have the info.
*  We return the # dir blocks allocated, not used, so hopefully
*  the RECEIVE program at the other end will allocate sufficient
*  directory blocks, rather than the usual number used, which causes
*  me huge amounts of grief, and probably you, too.
*
         SLR   R5,R5                        # dir blocks = 0
*----------------------------------------------------------------------
*  Read a directory block
*----------------------------------------------------------------------
         LA    R6,XDRDECBI                  @ DECB
         USING DECB,R6
READ     DS    0H
         READ  (R6),SF,(R2),(R9),'S',MF=E
         UDIAG 2,'XMITDIR: read issued'
         CHECK XDRDECBI
         UDIAG 3,'XMITDIR: dcb after CHECK',(R2),L$DCB
         UDIAG 3,'XMITDIR: decb after CHECK',(R6),L$DECB
*----------------------------------------------------------------------
*  Determine length of data retrieved, bail if not 256
*----------------------------------------------------------------------
         LH    R8,DCBBLKSI             l' READ 'S' request
         L     R4,DECIOBPT             @ IOB
         USING IOBSTDRD,R4
         UDIAG 3,'XMITDIR: IOB',(R4),20
         LH    R0,IOBSTBYT+2           residual count
         SR    R8,R0                   = l' read
*
         UDIAG 3,'XMITDIR directory block',(R9),(R8)
         C     R8,=F'256'              verify block length valid
         BNE   BROKEN
*----------------------------------------------------------------------
*  Count block just read
*----------------------------------------------------------------------
         LA    R5,1(,R5)               accumulate # dir blocks
         B     READ
*
EOFRTN   DS    0H                      END OF FILE branches here
         SLR   R15,R15
*
EXIT     DS    0H
         ST    R15,XDRRC
         L     R0,XDRBUFL
         LTR   R0,R0
         BZ    NOFREE
         LR    R1,R9
         FREEMAIN R,LV=(0),A=(1)
NOFREE   DS    0H
         ST    R15,XDRRC
         UDIAG 1,'XMITDIR exited'
         L     R15,XDRRC
         LR    R0,R5                        return dir blocks
         UPEND R0=RETURN
*
BROKEN   DS    0H
         ULOG  'XMITDIR: input dataset broken'
         ULOG  'Either RECFM not F or dir block length not 256'
         UABEND ,                           recfm=v or bad l' dirblk
*
MODLDECB READ MODLECB,SF,0,0,'S',MF=L
L$DECB   EQU  *-MODLDECB
*
         LTORG ,
*----------------------------------------------------------------------
         EJECT ,
XDRWA    DSECT ,
XDRSA    DS    18F
XDRBUFL  DS    F             l' gotten buffer
XDRDECBI READ  XDRECBI,SF,0,0,'S',MF=L
*
XDRRC    DS    F             return code
         DS    0D
L$XDRWA  EQU   *-XDRWA
*
         EJECT ,
         PRINT NOGEN
         WAXMT FUNC=XMIT
*        EJECT ,
         IHADECB ,
*        EJECT ,
         IEZIOB ,
*        EJECT ,
         DCBD  DSORG=PS,DEVD=DA
L$DCB    EQU   *-IHADCB
         PRINT GEN
XMITDIR  UFINI DXDXDIR,L$XDRWA
         END   ,
./ ADD NAME=XMITESZ  0100-02182-02182-0702-00140-00140-00000-XMIT370
XMITESZ  TITLE 'Estimate dataset SiZe'
*
* Copyright 2001, 2002 James M. Morrison
*
*----------------------------------------------------------------------
*  Things to do:
*----------------------------------------------------------------------
         U#SET ,
*----------------------------------------------------------------------
* Function: Estimate the number of bytes allocated to a dataset
*
* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*
*
*         R0  =
*         R1  =  open DCB
*
* Exit:   R15 = return code
*         R15 = 00 success; R0 = # bytes allocated (approximately)
*
* Abends: yes
*
* Notes:
*----------------------------------------------------------------------
* R2     scratch
* R3     DVCT
* R4     UCB associated with extent
* R5     # extents
* R6     DCB
* R7     DEB, DEBDASD
* R8     estimated file size in bytes
* R9
* R10
* R11    XMTWA
* R12    base reg
* R13    savearea
*----------------------------------------------------------------------
         TITLE ' '
*----------------------------------------------------------------------
XMITESZ  UPROC L=L$XESWA,ID=XESZ,WA=XESWA
         LR    R6,R1                   SYSUT1/SYSUT2 open DCB
         USING IHADCB,R6
         UDIAG 1,'XMITESZ entered'
*
*  Calculate estimated file size
*
         SLR   R8,R8                   # bytes allocated (estimate)
         SLR   R7,R7
         ICM   R7,7,DCBDEBA            @ DEB for DCB
         USING DEBBASIC,R7
*
         LR    R1,R7
         S     R1,=A(DEBPREFX-DEBBASIC)     back up to prefix
         SLR   R2,R2
         IC    R2,DEBLNGTH-DEBPREFX(,R1)    l' DEB in doublewords
         SLL   R2,3                         l' DEB in bytes
         MODESET KEY=ZERO                   DEB in key 5
         UDIAG 3,'XMITESZ DEB',(R7),(R2)
*
         SLR   R5,R5
         IC    R5,DEBNMEXT                  # extents
         LTR   R5,R5
         BZ    EXTDONE                      no extents
         LA    R7,DEBBASND                  @ deb dasd section
         USING DEBDASD,R7
*
* since we don't support ISAM, we don't have to worry about the
* ISAM device dependent section possibly appearing between the
* deb basic section and the deb dasd section.
*
CALCSPAC DS    0H
         SLR   R4,R4
         ICM   R4,7,DEBUCBA                 @ UCB for extent
         USING UCB,R4
         TM    UCBTBYT3,UCB3DACC            dasd device?
         BO    DASD
         UABEND ,                           input device not dasd
DASD     DS    0H
         L     R1,CVTPTR                    @ cvt
         L     R1,CVTZDTAB-CVT(,R1)         @ ieczdtab
         USING DVCTI,R1
         LA    R2,DVCTYPMK                  4 low order bits mask
         N     R2,UCBTYP                    index into ieczdtab
         IC    R2,DVCTIOFF(R2)              offset to dvct entry
         LA    R3,DVCTI(R2)                 @ dvct entry
         USING DVCT,R3
         UDIAG 3,'XMITESZ DVCT entry',(R3),DVCENTLG
         DROP  R1
*
         UDIAG 3,'XMITESZ DEBDASD',(R7),L$DEBDA
*
         SLR   R2,R2
         ICM   R2,3,DEBNMTRK                tracks allocated in extent
         MH    R2,DVCTRKLN                  times bytes/track
         AR    R8,R2                        accumulate bytes allocated
         LA    R7,L$DEBDA(,R7)              next debdasd section
         BCT  R5,CALCSPAC                   look at all extents
*
EXTDONE  DS    0H
         MODESET KEY=NZERO                  back to key 8
         ST    R15,XESRC
         UDIAG 1,'XMITESZ exited'
         L     R15,XESRC
         LR    R0,R8                        return estimated size
         UPEND R0=RETURN
*
         LTORG ,
*----------------------------------------------------------------------
         EJECT ,
XESWA    DSECT ,
XESSA    DS    18F
*
XESRC    DS    F             return code
         DS    0D
L$XESWA  EQU   *-XESWA
*
         EJECT ,
         PRINT NOGEN
         WAXMT FUNC=XMIT
*        EJECT ,
         IEZDEB LIST=YES
L$DEBDA  EQU   (DEBNMTRK+L'DEBNMTRK)-DEBDASD     l' debdasd section
*
*        EJECT ,
UCB      DSECT ,
         IEFUCBOB LIST=YES
*
*        EJECT ,
*----------------------------------------------------------------------
*  See Stage2 assembly of IECZDTAB for values & index
*----------------------------------------------------------------------
         IHADVCT ,
*
*        EJECT ,
         PRINT NOGEN
         CVT   DSECT=YES,LIST=NO
*
         DCBD  DSORG=PS,DEVD=DA
         PRINT GEN
XMITESZ  UFINI DXDXESZ,L$XESWA
         END   ,
./ ADD NAME=XMITPUT  0100-02182-02182-0702-00282-00282-00000-XMIT370
XMITPUT  TITLE 'WRITE segment'
*
* Copyright 2001, 2002 James M. Morrison
*
*----------------------------------------------------------------------
* Things to do:
* 1) Provide EXLST to set BLKSIZE if not coded in JCL/JFCB
*----------------------------------------------------------------------
         U#SET ,
*----------------------------------------------------------------------
* Function: Write a segment (XMITSEG), respecting LRECL boundaries
*           and buffer data as necessary.
*           Similar to fputc support in the C language.
*           This code maintains the DCB associated with it's
*           output file.
*
* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*
*
*         R0  =
*         R1  =  Address of buffer to be written
*                when = 0, buffers will be flushed & DCB closed
*                length of SEGL must be correct
*
* Exit:   R15 = 0
*
* Abends: DCB didn't open
*         residual data handling error (buffer hosed)
*
* Notes:  The caller is responsible for setting the segment's
*         length and flags.
*         We PUT the whole segment, including the length & flag;
*         RECEIVE needs the length & flag to reconstruct the file.
*         Some older code's documentation might refer to this code
*         as PUTSEG.
*----------------------------------------------------------------------
* R2     XPSWA
* R3     DCB
* R4     input buffer
* R5     length of input buffer
* R6     length of residual data in XPSSEG
* R7     length of input data to copy to residual data
* R8     scratch
* R9     constant: 80 = LRECL
* R10    internal linkage
* R11    xmtwa
* R12    base reg
* R13    savearea
*----------------------------------------------------------------------
         TITLE ' '
*----------------------------------------------------------------------
XMITPUT  UPROC L=L$SA,ID=XPUT,WA=SAVEAREA
         STM   R0,R15,XMTREGS               <debug>
         LA    R4,0(,R1)                    save input parm, clear hi
         UDIAG 1,'XMITPUT entered'
         UDIAG 6,'XMITPUT entry regs',XMTREGS,16*4
         LTR   R4,R4                        term request?
         BZ    TERM
         USING XMITSEG,R4
*
         L     R2,XMT@PS                    find our workarea
         LTR   R2,R2                        does it exist?
         BNZ   NORMAL
         EJECT ,
*----------------------------------------------------------------------
* Initialize XPSWA
*----------------------------------------------------------------------
         UDIAG 2,'XMITPUT: initializing XPSWA'
         LA    R2,XMTXPSWA
         USING XPSWA,R2
         UZERO (R2),L$XPSWA                 clear storage
         MVC   XPSDCB(L$DCB),MODLDCB        copy model DCB macro
         MVC   XPSOPN(L$OPN),MODLOPN        copy model OPEN macro
         MVC   XPSCLOS(L$CLOS),MODLCLOS     copy model CLOSE macro
         ST    R2,XMT@PS                    save ptr to out workarea
         B     NORMAL
         EJECT ,
*----------------------------------------------------------------------
* Terminate request
*----------------------------------------------------------------------
TERM     DS    0H
         L     R2,XMT@PS
*
* Fill remainder of LRECL with blanks, write if any residual data
*
         UDIAG 6,'XMITPUT: term residual',XPSSEG,80
         L     R6,XPSRL                     residual data length
         LTR   R6,R6
         BZ    TERMCLOS
         LA    R15,80                       lrecl
         LR    R9,R15                       <bogus> for PUT snap
         SR    R15,R6                       # bytes to blank
         LA    R4,XPSSEG
         LA    R14,0(R6,R4)                 @ 1st byte to set to blank
         MVI   0(R14),C' '                  blank to be propogated
         BCTR  R15,0
         EX    R15,BLANKRES                 blank rest of residual
         UDIAG 6,'XMITPUT: term residual write',XPSSEG,80
         BAL   R10,PUT                      write last record
TERMCLOS DS    0H
         UDIAG 2,'XMITPUT: closing XMITOUT ddname'
         CLOSE (XPSDCB,),MF=(E,XPSCLOS)
         XC    XMT@PS,XMT@PS                workarea gone
         B     EXITRC0
*
BLANKRES MVC   1(*-*,R14),0(R14)            executed
         EJECT ,
*----------------------------------------------------------------------
* Normal write request - open DCB if needed
*----------------------------------------------------------------------
NORMAL   DS    0H
         UDIAG 6,'XMITPUT: XPSWA dump <NORMAL>',XMTXPSWE,L$XPSWA+8
         LA    R9,80                        LRECL (constant)
         SLR   R5,R5
         IC    R5,SEGL                      segment length
         UDIAG 3,'XMITPUT: input segment',(R4),(R5)
         LA    R3,XPSDCB
         USING IHADCB,R3
         TM    DCBOFLG1,DCBOFOPN            dcb open?
         BO    DCBOPEN
         TM    XPSFLG1,XPS1OPN              not open, but did already?
         BNO   NEWOPEN                      first time, OK
*
         UDIAG 0,'XMITPUT: XMITOUT DCB error',XMTXPSWE,L$XPSWA+8
         UABEND DUMP=Y
*
NEWOPEN  DS    0H
         UDIAG 2,'XMITPUT: opening XMITOUT ddname'
         OPEN  (XPSDCB,OUTPUT),MF=(E,XPSOPN)
         OI    XPSFLG1,XPS1OPN              OPEN request issued
         TM    DCBOFLG1,DCBOFOPN            opened?
         BO    DCBOPEN
         UDIAG 0,'XMITPUT: XMITOUT DCB open error',XMTXPSWE,L$XPSWA+8
         UABEND ,                           output DCB didn't open
         EJECT ,
*----------------------------------------------------------------------
* Try to output residual data in XPSSEG before putting input buffer
*----------------------------------------------------------------------
COPYRES  MVC   0(*-*,R14),0(R4)             executed
*
DCBOPEN  DS    0H
         L     R6,XPSRL                     l' residual data
         LTR   R6,R6                        any?
         BZ    PUTINIT                      no, just put input buffer
*
         UDIAG 7,'XMITPUT: XPSSEG contains residual data',XPSSEG,(R6)
         LR    R7,R9                        lrecl
         SR    R7,R6                        minus l' residual data
*                            R7 = # bytes needed to complete LRECL
*
* Calc how much data to copy from input to behind current residual.
* A maximum of LRECL bytes will be stored in XPSSEG, the remainder
* of the input bytes (if any) will remain in the input buffer
* to be processed by PUTLOOP below.
*                                           assume just enough bytes
         LR    R15,R7                       in input seg to fill lrecl
         CR    R5,R7                        have more than needed?
         BH    *+6                          yes, leave r15 alone
         LR    R15,R5                       no use l' input buffer
*                            R15 = # bytes to copy from input buffer
*
         BCTR  R15,0                        minus 1 for EXexute
         LA    R14,XPSSEG(R6)               copy destination
*
*** <Perform sanity test here>
*
         EX    R15,COPYRES                  copy residual to XPSSEG
         LA    R15,1(,R15)                  plus 1 for EXecute
         AR    R6,R15                       new l' residual data
         AR    R4,R15                       account for copied data
         SR    R5,R15                       account for copied data
*
* If possible, write a full lrecl from residual data
*
         ST    R6,XPSRL                     update l' residual data
         UDIAG 7,'XMITPUT: input added to residual',XPSSEG,(R6)
         CR    R6,R9                        have full residual rec?
         BL    EXITRC0                      no, can't PUT data yet
         BH    BADCODE                      oops, we spaced out
*
* Write a lrecl's worth of data from the "residual" buffer
*
         UDIAG 4,'XMITPUT: write full residual buffer',XPSSEG,(R9)
         LA    R0,XPSSEG                    record address
         PUT   XPSDCB,(0)                   write record
         XC    XPSRL,XPSRL                  no more residual data
         XC    XPSSEG,XPSSEG                clear residual data
*----------------------------------------------------------------------
* Output as much data as possible from input buffer
*----------------------------------------------------------------------
PUTINIT  DS    0H
         LTR   R5,R5                        any data left?
         BZ    EXITRC0                      no, all done
         BM    BADCODE                      oops, went negative
         LA    R10,PUTLOOP                  (term uses "put" rtn)
         UDIAG 6,'XMITPUT: PUT from input buffer'
PUTLOOP  DS    0H
         CR    R5,R9                        more recs to output?
         BL    RESIDUAL                     no, save residual data
*
*----------------------------------------------------------------------
*  Internal routine to PUT data
*  R4 @ data byte to output, R5 = length, R9 = lrecl, R10 = return
*----------------------------------------------------------------------
*
PUT      DS    0H
         UDIAG 4,'XMITPUT: PUT segment',(R4),(R9)
         LR    R0,R4                        record address
         PUT   XPSDCB,(0)                   write record
         AR    R4,R9                        bump record ptr
         SR    R5,R9                        decr length
         BR    R10
*----------------------------------------------------------------------
* Save unwritten input buffer data as residual in XPSSEG
*----------------------------------------------------------------------
COPY     MVC   XPSSEG(*-*),0(R4)            executed
*
RESIDUAL DS    0H            less than 80 bytes to output from segment
         STM   R0,R15,XMTREGS               <debug>
         UDIAG 7,'XMITPUT: <RESIDUAL> regs',XMTREGS,16*4
         ST    R5,XPSRL                     save residual length
         LTR   R5,R5                        anything left?
         BZ    EXITRC0                      no, leave XPSSEG alone
         BM    BADCODE                      arggh, negative
         BCTR  R5,0                         length minus 1 for EX
         EX    R5,COPY                      copy residual data
         EJECT ,
*----------------------------------------------------------------------
*  Return to caller
*----------------------------------------------------------------------
EXITRC0  SLR   R15,R15                      set good return code
EXIT     DS    0H
         ST    R15,SARC
         L     R14,XPSRL
         LTR   R14,R14                      any residual data?
         BZ    SKIPDSP
         UDIAG 7,'XMITPUT: residual at exit',XPSSEG,(R14)
SKIPDSP  DS    0H
         UDIAG 7,'XMITPUT: XPSWA at exit',XMTXPSWE,L$XPSWA+8
         UDIAG 1,'XMITPUT exited'
         L     R15,SARC
         UPEND ,
*
BADCODE  DS    0H
         STM   R0,R15,XMTREGS
         USNAP 'XMITPUT: internal error - regs',XMTREGS,16*4
         USNAP 'XMITPUT: <badcode> xpswa',XMTXPSWE,L$XPSWA+8
         UABEND DUMP=Y                      buffer handling error
         EJECT ,
*----------------------------------------------------------------------
*  Data areas
*----------------------------------------------------------------------
MODLCLOS CLOSE (,),MF=L                model CLOSE
L$CLOS   EQU   *-MODLCLOS              l' model close
*
MODLOPN  OPEN  (,),MF=L                model OPEN
L$OPN    EQU   *-MODLOPN               l' model open
*
MODLDCB  DCB   DDNAME=XMITOUT,                                         +
               MACRF=PM,DSORG=PS,RECFM=FB,                             +
               LRECL=80,BLKSIZE=3200         NEED EXLST to fill blksize
L$DCB    EQU   *-MODLDCB
*
         LTORG ,
         EJECT ,
*----------------------------------------------------------------------
*  Savearea/workarea
*----------------------------------------------------------------------
SAVEAREA DSECT ,
SA       DS    18F
SARC     DS    F
         DS    0D
L$SA     EQU   *-SAVEAREA
         EJECT ,
         PRINT NOGEN
         DXMITSEG ,
*        EJECT ,
         WAXMT FUNC=XMIT
*        EJECT ,
         DCBD  DSORG=PS,DEVD=DA
         PRINT GEN
XMITPUT  UFINI DXDXPUT,L$SA
         END   ,
./ ADD NAME=XMITUNLD 0100-02182-02182-0702-00210-00210-00000-XMIT370
XMITUNLD TITLE 'INVOKE IEBCOPY to unload dataset, write segments'
*
* Copyright 2001, 2002 James M. Morrison
*
*----------------------------------------------------------------------
*  Things to do:
*----------------------------------------------------------------------
         U#SET ,
*----------------------------------------------------------------------
* Function: Invoke IEBCOPY to unload the input dataset, read the
*           IEBCOPY unload data, and write segments containing the
*           unloaded data.  Supports partitioned datasets for now.
*
*           Data is written as follows:
* XMIT01    INMR01 (always first)
* XMIT02A   INMR02 IEBCOPY
* XMIT02B   INMR02 INMCOPY
* XMIT03    INMR03 (precedes unloaded data)
* XMITUNLD  <unloaded data>
* XMIT06    INMR06 (trailer, always last)
*
* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*
*
*         R0  =
*         R1  =
*
* Exit:   R15 = return code
*         R15 = 00 success
*
* Abends:
*
* Notes:
*----------------------------------------------------------------------
* R2
* R3     JFCB
* R4     length of block read
* R5
* R6     length of allocated input buffer
* R7     IOB
* R8     input DCB
* R9     @ input record
* R10
* R11    XMTWA
* R12    base reg
* R13    savearea
*----------------------------------------------------------------------
         TITLE ' '
*----------------------------------------------------------------------
XMITUNLD UPROC L=L$XUNWA,ID=XUNL,WA=XUNWA
         UDIAG 1,'XMITUNLD entered'
         SLR   R6,R6                        no buffer allocated
*----------------------------------------------------------------------
* Write INMR01 segment
*----------------------------------------------------------------------
         UCALL XMIT01,ERR=EXIT
*----------------------------------------------------------------------
* Call INMR02A to unload PDS & write INMR02 for DSORG=PO
*----------------------------------------------------------------------
         L     R3,XMT@JFCB
         USING INFMJFCB,R3
         TM    JFCDSORG,JFCORGPS            physical sequential?
         BO    NOPDS
         TM    JFCDSORG,JFCORGPO            partitioned?
         BNO   BADORG
PDS      UCALL XMIT02A,ERR=EXIT
*----------------------------------------------------------------------
* Call INMR02B to write INMR02 segment for DSORG=PS on SYSUT1/SYSUT2
*----------------------------------------------------------------------
NOPDS    DS    0H
         UCALL XMIT02B,ERR=EXIT
*----------------------------------------------------------------------
* Call XMIT03 to write INMR03 segment prior to outputting data segments
*----------------------------------------------------------------------
         UCALL XMIT03,ERR=EXIT
*----------------------------------------------------------------------
* Set EOF routine and allocate input buffer
*----------------------------------------------------------------------
SETEOF   DS    0H
         L     R3,XMT@JFCB                  refresh xmtdcbi's JFCB ptr
         LA    R8,XMTDCBI                   @ input DCB
         USING IHADCB,R8
         LA    R0,EOFRTN
         STCM  R0,7,DCBEODA                 set EOF exit rtn addr
*
         MVC   XUNDECBI(L$DECB),MODLDECB   copy model DECB
*
         LH    R6,DCBBLKSI                 get blksize
         GETMAIN R,LV=(R6)                 alloc input buffer
         LR    R9,R1
*----------------------------------------------------------------------
* Read block of data from SYSUT1 or SYSUT2
*----------------------------------------------------------------------
READ     DS    0H
         READ  XUNDECBI,SF,(R8),(R9),'S',MF=E
         UDIAG 2,'XMITUNLD: read issued'
*
         CHECK XUNDECBI
         L     R7,(DECIOBPT-DECB)+XUNDECBI   @ IOB
         USING IOBSTDRD,R7
*
         UDIAG 5,'XMITUNLD: decb after CHECK',XUNDECBI,L$DECB
         UDIAG 5,'XMITUNLD: dcb after CHECK',(R8),L$DCB
         UDIAG 5,'XMITUNLD: IOB after CHECK',(R7),L$IOB
*
*  careful, recfm=u = recfm=v + recfm=f
*
         TM    DCBRECFM,DCBRECU        RECFM=U, get residual
         BO    CALCLEN
         LH    R4,0(R9)                l' RECFM=VB record = BDW
         TM    DCBRECFM,DCBRECV        guessed wrong?
         BO    HVLEN
CALCLEN  DS    0H
         LH    R4,DCBBLKSI             max l' RECFM=F or U
         LH    R0,IOBSTBYT+2           residual count
         SR    R4,R0                   r4 = l' read
HVLEN    DS    0H
         UDIAG 3,'XMITUNLD: input record',(R9),(R4)
*----------------------------------------------------------------------
* If this is the IEBCOPY COPYR1 record, see if it needs "fixing"
*----------------------------------------------------------------------
CKCOPYR1 DS    0H
         TM    XUNFLG1,XUNF1FX         already fixed?
         BO    WRITE
         CLC   =X'CA6D0F',9(R9)        COPYR1 id?
         BNE   WRITE                   nope, skip
FXCOPYR1 DS    0H
         LR    R1,R9                   @ COPYR1 block
         UCALL XMITCPR1                call COPYR1-fixer-upper
         OI    XUNFLG1,XUNF1FX         show fixed
*----------------------------------------------------------------------
* Write data segments from data read
*----------------------------------------------------------------------
WRITE    DS    0H
         LH    R0,0(,R9)               retrieve new buffer length
         LR    R1,R9                   @ buffer
*
*  XMIT doesn't transmit BDW & RDW for unloaded DSORG=PO datasets
*
         TM    JFCRECFM,JFCVAR         have to fudge recfm=v
         BNO   WBUF
         TM    XMTFLG1,XMTF1$U         for unloaded datasets,
         BNO   WBUF
*                                      skip the BDW & RDW
         S     R0,=F'8'                fudge length
         LA    R1,8(,R1)               adjust record ptr
*
WBUF     DS    0H
         UCALL XMITBUF            split buffer into segments, write
         LTR   R15,R15
         BZ    READ
         BNZ   EXIT
*----------------------------------------------------------------------
* Write INMR06 segment at End Of File
*----------------------------------------------------------------------
EOFRTN   DS    0H
         UCALL XMIT06,ERR=EXIT
         SLR   R15,R15
*----------------------------------------------------------------------
* Return to caller
*----------------------------------------------------------------------
EXIT     DS    0H
         ST    R15,XUNRC
         LTR   R6,R6
         BZ    NOFREE
         LR    R1,R9
         FREEMAIN R,LV=(0),A=(1)
NOFREE   DS    0H
         UDIAG 1,'XMITUNLD exited'
         L     R15,XUNRC
         UPEND ,
*
BADORG   DS    0H
         USNAP 'XMITUNLD: JFCB invalid DSORG',(R3),L$JFCB
         UABEND ,                      invalid input file DSORG
*
MODLDECB READ MODLECB,SF,0,0,'S',MF=L
L$DECB   EQU  *-MODLDECB
*
         LTORG ,
*----------------------------------------------------------------------
XUNWA    DSECT ,
XUNSA    DS    18F
XUNFLG1  DS    X
XUNF1FX  EQU   128                     COPYR1 fixed
*
XUNRC    DS    F                       return code
XUNDECBI READ  XUNECBI,SF,0,0,'S',MF=L
         DS    0D
L$XUNWA  EQU   *-XUNWA
         EJECT ,
         PRINT NOGEN
         WAXMT FUNC=XMIT
*        EJECT ,
         DCBD  DSORG=PS,DEVD=DA
L$DCB    EQU   *-IHADCB
*
JFCB     DSECT ,
         IEFJFCBN LIST=YES
L$JFCB   EQU   *-JFCB
*
*        PRINT ON,GEN
*        EJECT ,
         IHADECB ,
*
*        EJECT ,
         IEZIOB ,
L$IOB    EQU    *-IOB
         PRINT ON,GEN
XMITUNLD UFINI DXDXUNLD,L$XUNWA
         END   ,
./ ADD NAME=XMITVTAB 0100-02182-02182-0702-00043-00043-00000-XMIT370
XMITVTAB TITLE 'XMIT370 VCON table'
*
* Copyright 2001, 2002 James M. Morrison
*
UTILVTAB CSECT ,
         USING *,0
         USING XMTWA,11
*----------------------------------------------------------------------
*  CSECT table header - BXLE index, increment, limit
*----------------------------------------------------------------------
HEADER   DC    A(DBUGTAB,L$VTAB,DBUGEND-1)
*----------------------------------------------------------------------
*  CSECT table
*----------------------------------------------------------------------
DBUGTAB  DS    0F
         DC    CL8'XMIT370',V(XMIT370),AL2(XMTD370-XMTDLEV,0)
         DC    CL8'XMITBUF',V(XMITBUF),AL2(XMTDBUF-XMTDLEV,0)
         DC    CL8'XMITCPR1',V(XMITCPR1),AL2(XMTDCPR1-XMTDLEV,0)
         DC    CL8'XMITDIR',V(XMITDIR),AL2(XMTDDIR-XMTDLEV,0)
         DC    CL8'XMITESZ',V(XMITESZ),AL2(XMTDESZ-XMTDLEV,0)
         DC    CL8'XMITPUT',V(XMITPUT),AL2(XMTDPUT-XMTDLEV,0)
         DC    CL8'XMITUNLD',V(XMITUNLD),AL2(XMTDUNLD-XMTDLEV,0)
         DC    CL8'XMIT01',V(XMIT01),AL2(XMTD01-XMTDLEV,0)
         DC    CL8'XMIT02A',V(XMIT02A),AL2(XMTD02A-XMTDLEV,0)
         DC    CL8'XMIT02B',V(XMIT02B),AL2(XMTD02B-XMTDLEV,0)
         DC    CL8'XMIT03',V(XMIT03),AL2(XMTD03-XMTDLEV,0)
         DC    CL8'XMIT06',V(XMIT06),AL2(XMTD06-XMTDLEV,0)
*
         DC    CL8'UTILABND',V(UTILABND),AL2(XMTDABND-XMTDLEV,0)
         DC    CL8'UTILDBUG',V(UTILDBUG),AL2(XMTDDBUG-XMTDLEV,0)
         DC    CL8'UTILHEX',V(UTILHEX),AL2(XMTDHEX-XMTDLEV,0)
         DC    CL8'UTILLOG',V(UTILLOG),AL2(XMTDLOG-XMTDLEV,0)
         DC    CL8'UTILPSR',V(UTILPSR),AL2(XMTDPSR-XMTDLEV,0)
         DC    CL8'UTILSNAP',V(UTILSNAP),AL2(XMTDSNAP-XMTDLEV,0)
         DC    CL8'UTILTIOT',V(UTILTIOT),AL2(XMTDTIOT-XMTDLEV,0)
DBUGEND  EQU   *
*----------------------------------------------------------------------
*  DSECTs
*----------------------------------------------------------------------
         DVTAB ,                       VCON table
         PRINT NOGEN
         WAXMT FUNC=UTIL
         END   ,
./ ADD NAME=XMIT01   0100-02182-02182-0702-00137-00137-00000-XMIT370
XMIT01   TITLE 'WRITE INMR01 segment'
*
* Copyright 2001, 2002 James M. Morrison
*
*----------------------------------------------------------------------
*  Things to do:
*----------------------------------------------------------------------
         U#SET ,
*----------------------------------------------------------------------
* Function: Collect the information for, and write the INMR01 segment.
*
* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*
*
*         R0  =
*         R1  =
*
* Exit:   R15 = return code
*         R15 = 00 success
*
* Abends:
*
* Notes:
*----------------------------------------------------------------------
* R2
* R3
* R4     @ segment data
* R5     length remaining in segment data
* R6
* R7
* R8
* R9
* R10
* R11    XMTWA
* R12    base reg
* R13    savearea
*----------------------------------------------------------------------
         TITLE ' '
*----------------------------------------------------------------------
XMIT01   UPROC L=L$X01WA,ID=XM01,WA=X01WA
         UDIAG 1,'XMIT01 entered'
*----------------------------------------------------------------------
* Create INMR01 segment's key data
*----------------------------------------------------------------------
         MVI   X01SEGL,L$X01SGL                  segment length
         MVI   X01SEGF,SEG$1+SEG$L+SEG$C         segment flag
         MVC   X01ID,=C'INMR01'
         MVC   X01KEY(L$MR01),MR01     copy bogus key data
*
* Update some of the bogus key data with correct values
*
*
*----------------------------------------------------------------------
* Write INMR01 segment
*----------------------------------------------------------------------
WRITE    DS    0H
         LA    R1,X01MR01
         UCALL XMITPUT                      write INMR01 segment
EXIT     DS    0H
         UDIAG 1,'XMIT01 exited'
         SLR   R15,R15                      good return code
         UPEND  ,
*
         LTORG ,
*
*
*     c9d5d4d9 f0f1                               *INMR01   *
*     0042 0001 0001 50
*     1011 0001 0008 d5d6c4c5d5c1d4c5             *NODENAME *
*     1012 0001 0006 e2e2c4d1d4d4                 *SSDJMM   *
*     1001 0001 0004 d5d6c4c5                     *NODE     *
*     1002 0001 0006 e4e2c5d9c9c4                 *USERID   *
*     1024 0001 000e f2f0f0f0f0f3f2f2f0f2f1f5f3f2 *20000322021532*
*     102f 0001 0001 01
*
MR01     DS    0X
KLRECL   DC    AL2(INMLRECL,1,L'VLRECL)    0042 physical lrecl
VLRECL   DC    FL1'80'                     of control segments
*
KFNODE   DC    AL2(INMFNODE,1,L'VFNODE)    1011 origin node
VFNODE   DC    C'ORIGNODE'
*
KFUID    DC    AL2(INMFUID,1,L'VFUID)      1012 origin userid
VFUID    DC    C'ORIGUID'
*
KTNODE   DC    AL2(INMTNODE,1,L'VTNODE)    1001 dest node
VTNODE   DC    C'DESTNODE'
*
KTUID    DC    AL2(INMTUID,1,L'VTUID)      1002 dest userid
VTUID    DC    C'DESTUID'
*
KFTIME   DC    AL2(INMFTIME,1,L'VFTIME)    1024 origin time stamp
VFTIME   DC    C'20010203124500'
*                yyyymmddhhmmss
*
KNUMF    DC    AL2(INMNUMF,1,L'VNUMF)      102F # files
VNUMF    DC    X'01'
L$MR01   EQU   *-MR01                      actual segment length
*
* optional keys not provided: INMFACK, INMFVERS, INMNUMF, INMUSERP
*
*----------------------------------------------------------------------
*
X01WA    DSECT ,
X01SA    DS    18F
*
X01MR01  DS    0D            INMR01 segment
X01SEGL  DS    X             segment length
X01SEGF  DS    X             segment flag
X01SEGD  DS    XL253         beginning of segment data
         ORG   X01SEGD
X01ID    DS    C'INMR01'
X01KEY   DS    0X            beginning of key data
         DC    AL2(INMLRECL,1,L'VLRECL)    0042 physical lrecl
X01LRECL DC    FL1'80'                     of control segments
         DC    AL2(INMFNODE,1,L'VFNODE)    1011 origin node
X01FNODE DC    C'ORIGNODE'
         DC    AL2(INMFUID,1,L'VFUID)      1012 origin userid
X01FUID  DC    C'ORIGUID'
         DC    AL2(INMTNODE,1,L'VTNODE)    1001 dest node
X01TNODE DC    C'DESTNODE'
         DC    AL2(INMTUID,1,L'VTUID)      1002 dest userid
X01TUID  DC    C'DESTUID'
         DC    AL2(INMFTIME,1,L'VFTIME)    1024 origin time stamp
X01FTIME DC    C'20010203124500'
         DC    AL2(INMNUMF,1,L'VNUMF)      102F # files
X01NUMF  DC    X'01'
L$X01SGL EQU   *-X01MR01                   actual segment length
         ORG   ,
         DS    0D
L$X01WA  EQU   *-X01WA
         EJECT ,
         PRINT NOGEN
         DXMITSEG ,
*        EJECT ,
         WAXMT FUNC=XMIT
XMIT01   UFINI DXDX01,L$X01WA        pseudo-register
         END   ,
./ ADD NAME=XMIT02A  0100-02182-02182-0702-00493-00493-00000-XMIT370
XMIT02A  TITLE 'WRITE INMR02 IEBCOPY segment'
*
* Copyright 2001, 2002 James M. Morrison
*
*----------------------------------------------------------------------
*  Things to do:
*----------------------------------------------------------------------
         U#SET ,
*----------------------------------------------------------------------
* Function: Collect the information for, and write the INMR02 segment.
*           for DSORG=PO datasets (INMR02 IEBCOPY segment);
*           call IEBCOPY to unload the input dataset
*
* Entry:  S/370 ECMODE KEY=8, STATE=PROB, AUTHORIZED
*
*         R0  =
*         R1  =
*
* Exit:   R15 = return code
*         R15 = 00 success
*
* Abends:
*
* Notes: XMITUNLD only calls us for DSORG=PO datasets
*        XMIT370 has already read in the JFCB for the input dataset.
*        We probably have to close SYSUT1 before calling IEBCOPY to
*        unload the input dataset.
*
*        We also read SYSUT1's Format-1 DSCB, for XMITCPR1.
*----------------------------------------------------------------------
* R2     DCB
* R3     JFCB
* R4     @ segment data
* R5     length remaining in segment data
* R6     makdsnam ptr to count portion of new qualifier
* R7     makdsnam ptr to free slot in segment
* R8     makdsnam dsn char ptr
* R9     makdsnam # chars left in dsn to examine
* R10    makdsnam # chars in qualifier
* R11    XMTWA
* R12    base reg
* R13    savearea
*----------------------------------------------------------------------
         TITLE ' '
*----------------------------------------------------------------------
XMIT02A  UPROC L=L$X02AWA,ID=X02A,WA=X02AWA
         UDIAG 1,'XMIT02A entered'
*----------------------------------------------------------------------
* Create INMR02 segment's key data
*----------------------------------------------------------------------
         MVI   X02SEGL,L$X02SGL                        segment length
         MVI   X02SEGF,SEG$1+SEG$L+SEG$C               segment flags
         MVC   X02ID,=C'INMR02'
         MVC   X02NUM,=AL4(1)          applies to file number 1
         MVC   X02KEY(L$MR02),MR02     copy bogus key data
*
* Update bogus data with correct information
*
         LA    R3,XMTJFCB1           @ SYSUT1 JFCB
         USING JFCB,R3
         MVC   XDSORG,JFCDSORG       dsorg
         MVC   XLRECL+2(2),JFCLRECL  lrecl
*
*  Note LRECL is only a two byte field, but the version of TRANSMIT I
*  used to create some sample data created LRECL as a four byte field.
*  Similarly, RECFM and BLKSIZE are transmitted in larger fields, too.
*
         MVC   XRECFM(1),JFCRECFM    recfm
         MVC   XBLKSZ+2(2),JFCBLKSI  block size
*----------------------------------------------------------------------
* Estimate the size (in bytes) of the input dataset
*----------------------------------------------------------------------
         LA    R1,XMTDCBI            @ open SYSUT1 DCB
         UCALL XMITESZ,ERR=EXIT
         STCM  R0,15,XSIZE           approximate # bytes allocated
*----------------------------------------------------------------------
* Determine how many directory blocks the PDS has allocated
*----------------------------------------------------------------------
         LA    R1,XMTDCBI            @ open SYSUT1 DCB
         UCALL XMITDIR,ERR=EXIT
         STCM  R0,7,XDIR             directory blocks allocated
*----------------------------------------------------------------------
* Finish off the INMR02 segment
*----------------------------------------------------------------------
* by filling in the INMDSNAM key which contains the input (SYSUT1)
* dataset name split up by qualifiers.
* For example, the dataset SES.LINK is represented as:
*        0002                                     INMDSNAM key
*             0002                                # count/data pairs
*                  0003 e2c5e2          *SES*     count/data pair #1
*                  0004 d3c9d5d2        *LINK*    count/data pair #2
*
         UDIAG 4,'XMIT02A makdsnam call'
         BAL   R14,MAKDSNAM                 fill it in
         UDIAG 4,'XMIT02A makdsnam complete'
*----------------------------------------------------------------------
* Write INMR02 segment
*----------------------------------------------------------------------
WRITE    DS    0H
         LA    R1,X02MR02
         UCALL XMITPUT,ERR=EXIT             write INMR02 segment
*----------------------------------------------------------------------
*  OBTAIN SYSUT1 Format 1 DSCB
*----------------------------------------------------------------------
         UDIAG 2,'XMIT02A obtain init'
         MVC   X02CAML(L$CAMLST),CAMLST     copy CAMSLT
         LA    R0,JFCBDSNM                 SYSUT1 JFCB's dsn
         ST    R0,X02CAML+04               dsn
*
         LA    R0,JFCBVOLS
         ST    R0,X02CAML+08               volser
*
         LA    R0,XMTDSCB1                 SYSUT1 DSCB area
         ST    R0,X02CAML+12               @ dscb buffer
*
         OBTAIN X02CAML
*
         ST    R15,X02RC                   save return code
         MVC   XMTDSCB(44),JFCBDSNM        copy dsn
         UDIAG 3,'XMIT02A SYSUT1 DSCB',XMTDSCB,44+140
         L     R15,X02RC
         LTR   R15,R15                     OBTAIN good?
         BZ    OBTAINOK
         UPSR  0,'XMIT02A SYSUT1 OBTAIN rc',(R15)
         UABEND ,
OBTAINOK DS    0H
         UDIAG 2,'XMIT02A obtain fini'
         EJECT ,
*----------------------------------------------------------------------
* Close the SYSUT1 input dataset
*----------------------------------------------------------------------
CLOSE    DS    0H
         MVC   XMTCLOS(L$CLOS),MODLCLOS     copy model CLOSE macro
         CLOSE XMTDCBI,MF=(E,XMTCLOS)
         UDIAG 2,'XMIT02A: closed SYSUT1'
*----------------------------------------------------------------------
* Call IEBCOPY to unload the PDS
*----------------------------------------------------------------------
IEBCOPY  DS    0H
*
*  Load IEBCOPY
*
         LA    R0,=CL8'IEBCOPY'
         LOAD  EPLOC=(0)
         LTR   R15,R15
         BZ    GOCOPY
         ST    R15,X02RC
         UDIAG 0,'XMIT02A: IEBCOPY load failed'
         L     R0,X02RC
         UPSR  0,'XMIT02A load rc',(R0)
         B     EXIT
*
*  Call IEBCOPY
*
GOCOPY   DS    0H
         LR    R15,R0              GET ENTRY ADDRESS
         LA    R15,0(,R15)         CLEAR HI BYTE FOR DELETE ROUTINE
         LR    R9,R15              SAVE
         LA    R1,X02PRMOS         IEBCOPY parm: OS parm string
         ST    R1,X02PRM1
         OI    X02PRM1,X'80'       end of VL parmlist
         LA    R1,X02PRM1
         BALR  R14,R15             call IEBCOPY
         ST    R15,X02RC
         UPSR  2,'XMIT02A IEBCOPY rc %',(R15)
         L     R15,X02RC
         LTR   R15,R15
         BNZ   EXIT
*
*  Delete IEBCOPY
*
DELCOPY  DS    0H
         UDIAG 2,'XMIT02A: IEBCOPY unload successful'
         LA    R0,=CL8'IEBCOPY'
         DELETE EPLOC=(0)          delete IEBCOPY program
         UPSR  2,'XMIT02A delete rc %',(R15)
*----------------------------------------------------------------------
* Open the IEBCOPY output dataset as our input, retrieve JFCB
* so that XMIT02B (where we're headed next) can fill in it's data
*----------------------------------------------------------------------
OPEN     DS    0H
         MVC   XMTOPN(L$OPN),MODLOPN     copy model OPEN macro
         MVC   XMTDCBI(L$DCBI),MODLDCBI  copy model DCB
         OPEN  XMTDCBI,MF=(E,XMTOPN)
         LA    R2,XMTDCBI
         USING IHADCB,R2
         MVC   XMTJFCBL(L$JFCBL),JFCBLST    copy open exit list
         LA    R0,XMTJFCB2                  relocate JFCB addr
         STCM  R0,7,XMTJFCBL+1
         LA    R0,XMTJFCBL                  relocate DCB's EXLST
         STCM  R0,7,(DCBEXLSA-IHADCB)+XMTDCBI
         OPEN  XMTDCBI,MF=(E,XMTOPN)
         TM    DCBOFLG1,DCBOFOPN            opened?
         BO    DCBIOPEN
         UDIAG 0,'XMIT02A: SYSUT2 DCB failed to open'
         UABEND ,                           input DCB didn't open
DCBIOPEN DS    0H
         UDIAG 3,'XMIT02A: SYSUT2 DCB open',(R2),L$DCB
         RDJFCB XMTDCBI,MF=(E,XMTOPN)       SYSUT2 JFCB
         LTR   R15,R15
         BZ    SNAPJFCB
         ST    R15,X02RC
         UDIAG 0,'XMIT02A: RDJFCB failed'
         L     R0,X02RC
         UPSR  2,'XMIT02A RDJFCB rc %',(R0)
         UABEND ,
SNAPJFCB DS    0H
         UDIAG 3,'XMIT02A: SYSUT2 JFCB',XMTJFCB2,L$JFCB
         LA    R0,XMTJFCB2
         ST    R0,XMT@JFCB             SYSUT2 JFCB ptr
*----------------------------------------------------------------------
*  Return to caller
*----------------------------------------------------------------------
EXIT     DS    0H
         OI    XMTFLG1,XMTF1$U         xmtdcbi now unloaded dataset
         UDIAG 1,'XMIT02A exited'
         L     R15,X02RC
         UPEND  ,
         EJECT ,
*----------------------------------------------------------------------
*  MAKDSNAM subroutine - fill in INMDSNAM key
*----------------------------------------------------------------------
* R2
* R3
* R4     @ segment data
* R5     length remaining in segment data
* R6     makdsnam ptr to count portion of new qualifier
* R7     makdsnam ptr to free slot in segment
* R8     makdsnam dsn char ptr
* R9     makdsnam # chars left in dsn to examine
* R10    makdsnam # chars in qualifier
* R11    XMTWA
* R12    base reg
* R13    savearea
*----------------------------------------------------------------------
MAKDSNAM DS    0H
         STM   R0,R15,X02SAV2          save caller's regs
*
* maximum possible space consumed by dataset name:
* 123456789/123456789/123456789/123456789/1234
* A.B.C.D.E.F.G.H.I.J.K.L.M.N.O.P.Q.R.S.T.U.VW
* stored as:
* 0002         INDSNAM key
* 0016         22 qualifiers
* 0001 C1 0001 C2 0001 C3 0001 C4 0001 C5 0001 C6 0001 C7 0001 C8
* 0001 C9 0001 D1 0001 D2 0001 D3 0001 D4 0001 D5 0001 D6 0001 D7
* 0001 D8 0001 D9 0001 E2 0001 E3 0001 E4 0002 E5E6
* consumes 71 bytes.  We have way more than that left in the INMR02
* segment, so we don't even worry about the space, just getting
* the new INMDSNAM segment right.
*
* We only have to count the count/data pairs, drop them in the
* segment being created, and update the segment's length.
*
         SLR   R15,R15
         IC    R15,X02SEGL
         UDIAG 4,'XMIT02A makdsnam entry segment',X02SEGL,(R15)
*
         LA    R6,X02DSNAM             1st count slot
         LA    R7,2(,R6)               data space in segment
         LA    R8,JFCBDSNM+L'JFCBDSNM-1     @ dsn last char
         LA    R9,L'JFCBDSNM           max possible dsn length
         UDIAG 4,'XMIT02A JFCB dsname',JFCBDSNM,44
*
*  Determine length of input dataset name
*
GETLEN   DS    0H                      calc # chars in dsn
         CLI   0(R8),C' '              trailing space?
         BNE   HAVLEN
         BCTR  R8,0                    r8 back one character
         BCT   R9,GETLEN               minus trailing space
HAVLEN   DS    0H                      r9 = # chars in dsn
         LTR   R9,R9                   better be something left
         BP    LENOK
         UDIAG 0,'XMIT02A input dsn parse error'
         UABEND ,                      can't parse dsn
LENOK    DS    0H
         UPSR  4,'XMIT02A dsn length %',(R9)
*
*  Handle a qualifier at a time
*
         LA    R8,JFCBDSNM             @ dsn's first char
*
         STM   R0,R15,XMTREGS          debug aid
         UDIAG 5,'XMIT02A newqual init regs',XMTREGS,16*4
*
NEWQUAL  DS    0H
         SLR   R10,R10                 # chars in qualifier
         STM   R0,R15,XMTREGS          debug aid
         UDIAG 5,'XMIT02A newqual regs',XMTREGS,16*4
*
*  Scan qualifier for end
*
NXTCHAR  DS    0H                      parse the qualifier
         CLI   0(R8),C'.'              found period?
         BE    TERMQUAL                yes, end of qualifier
         MVC   0(1,R7),0(R8)           copy qualifier char
         LA    R7,1(,R7)               next segment char slot
         LA    R8,1(,R8)               next dsn char
         LA    R10,1(,R10)             account for char moved
         BCT   R9,NXTCHAR              one less dsn char
*
*  Falling through means last qualifer (no '.')
*
         STM   R0,R15,XMTREGS          debug aid
         UDIAG 4,'XMIT02A nxtchar fallthru = last',XMTREGS,16*4
*
*  Found end of qualifier
*
TERMQUAL DS    0H
         UDIAG 4,'XMIT02A termqual loop'
         STCM  R10,3,0(R6)             set # chars in qual
*
         SLR   R14,R14                 clean x02quals reg
         ICM   R14,3,X02QUALS          old # qualifiers
         LA    R14,1(,R14)             one more
         STCM  R14,3,X02QUALS          update
*
         SLR   R15,R15                 clean x02segl reg
         IC    R15,X02SEGL             old segment length
         LA    R15,2(R10,R15)          new segment length
         STC   R15,X02SEGL             update
*
         LR    R6,R7                   next count slot
         LA    R7,2(,R7)               next data slot
         LA    R8,1(,R8)               skip period
*
         STM   R0,R15,XMTREGS          debug aid
         UDIAG 5,'XMIT02A next qual regs',XMTREGS,16*4
         SLR   R15,R15
         IC    R15,X02SEGL
         UDIAG 4,'XMIT02A segment updated with count',X02SEGL,(R15)
*
         LTR   R9,R9                   all done?
         BNP   MADEDSNM
         BCT   R9,NEWQUAL              account for period,
*                                      do another qualifier
*
*  Finished updating segment with dsn, return
*
MADEDSNM DS    0H
         STM   R0,R15,XMTREGS          debug aid
         UDIAG 4,'XMIT02A makdsnam about to return'
         UDIAG 5,'XMIT02A makdsnam exit regs',XMTREGS,16*4
*
         LM    R0,R15,X02SAV2          restore caller's regs
         BR    R14                     return to caller
         EJECT ,
*
MODLOPN  OPEN  (,INPUT),MF=L           model OPEN
L$OPN    EQU   *-MODLOPN               l' model open
*
MODLCLOS CLOSE (,),MF=L                model CLOSE
L$CLOS   EQU   *-MODLCLOS              l' model close
*
JFCBLST  DS    0F
         DC    XL1'87'
         DC    AL3(0)
L$JFCBL  EQU   *-JFCBLST
*
CAMLST   CAMLST SEARCH,1,2,3
*
*
* IEBCOPY's output is now our input
* DSORG=PS - maybe yes, maybe no
* XMITUNLD uses BSAM READ/CHECK
*
MODLDCBI DCB   DDNAME=SYSUT2,DSORG=PS,EXLST=JFCBLST,MACRF=R
L$DCBI   EQU   *-MODLDCBI
*
         LTORG ,
         EJECT ,
*
*
*        c9d5d4d9f0f2                   *INMR02*
*        00000001
*        1028 0001 0007 c9c5c2c3d6d7e8  *IEBCOPY*
*        102c 0001 0004 0000bb60
*        003c 0001 0002 0200
*        8012 0001 0001 00
*        0042 0001 0004 00000050
*        0030 0001 0004 00005b90
*        0049 0001 0002 9000
*        000c 0001 0003 000006
*        0002 0002 0003 e2c5e2          *SES*
*                  0004 d3c9d5d2        *LINK*
*
MR02     DS    0D
         DC    AL2(INMUTILN,1,L'VUTILN)     1028 utility name
VUTILN   DC    C'IEBCOPY'
*
         DC    AL2(INMSIZE,1,L'VSIZE)       102c approx file size
VSIZE    DC    XL4'BB60'
*
         DC    AL2(INMDSORG,1,L'VDSORG)     003C dsorg
VDSORG   DC    XL2'0200'
*
         DC    AL2(INMTYPE,1,L'VTYPE)       8012 optional dataset type
VTYPE    DC    X'00'
*
         DC    AL2(INMLRECL,1,L'VLRECL)     0042 lrecl
VLRECL   DC    AL4(80)
*
         DC    AL2(INMBLKSZ,1,L'VBLKSZ)     0030 optional blocksize
VBLKSZ   DC    AL4(23440)
*
         DC    AL2(INMRECFM,1,L'VRECFM)     0049 recfm + pad
VRECFM   DC    X'9000'
*
         DC    AL2(INMDIR,1,L'VDIR)         000C dir blocks
VDIR     DC    XL3'000006'
*
VDSN     DC    AL2(INMDSNAM)                0002 optional dsname
         DC    AL2(0)                       # dsn qualifiers
L$MR02   EQU   *-MR02
*----------------------------------------------------------------------
*  Immediately following the # of dsn qualifiers field is the
*  Dataset count/data pairs set in makdsnam subroutine, not prototyped
*----------------------------------------------------------------------
*
* optional keys not provided: <figure out later>
*
*----------------------------------------------------------------------
         EJECT ,
X02AWA   DSECT ,
X02SA    DS    18F           savearea for anyone we call
X02CAML  CAMLST SEARCH,1,2,3
L$CAMLST EQU   *-X02CAML
X02SAV2  DS    16F           savearea for makdsnam subroutine
*
X02RC    DS    F             most recent return code
*
X02PRM1  DS    A             IEBCOPY OS-parm ptr
X02PRMOS DS    H,CL100       IEBCOPY OS-parm
*
X02MR02  DS    0D            INMR02 segment
X02SEGL  DS    X             segment length
X02SEGF  DS    X             segment flag
X02SEGD  DS    XL253         beginning of segment data
         ORG   X02SEGD
X02ID    DS    C'INMR02'
X02NUM   DS    XL4           files # (relative 1)
X02KEY   DS    0X            beginning of key data
         DC    AL2(INMUTILN,1,L'VUTILN)     1028 utility name
XUTILN   DC    C'IEBCOPY'
         DC    AL2(INMSIZE,1,L'VSIZE)       102c approx file size
XSIZE    DC    XL4'BB60'
         DC    AL2(INMDSORG,1,L'VDSORG)     003C dsorg
XDSORG   DC    XL2'0200'
         DC    AL2(INMTYPE,1,L'VTYPE)       8012 optional dataset type
XTYPE    DC    X'00'
         DC    AL2(INMLRECL,1,L'VLRECL)     0042 lrecl
XLRECL   DC    AL4(80)
         DC    AL2(INMBLKSZ,1,L'VBLKSZ)     0030 optional blocksize
XBLKSZ   DC    AL4(23440)
         DC    AL2(INMRECFM,1,L'VRECFM)     0049 recfm
XRECFM   DC    X'9000'
         DC    AL2(INMDIR,1,L'VDIR)         000C dir blocks
XDIR     DC    XL3'000006'
         DC    AL2(INMDSNAM)                0002 optional dsname
X02QUALS DC    AL2(0)                       # qualifiers
X02DSNAM EQU   *                            count/data pairs built here
L$X02SGL EQU   *-X02MR02                    actual segment length
         DS    CL67                         max count/data pair size
         ORG   ,
         DS    0D
L$X02AWA EQU   *-X02AWA
*
         EJECT ,
         PUSH  PRINT
         PRINT NOGEN
         DXMITSEG ,
*
*        EJECT ,
*
         WAXMT FUNC=XMIT
*
*        EJECT ,
*
         DCBD   DSORG=PS,DEVD=DA
L$DCB    EQU   *-IHADCB
*
JFCB     DSECT ,
         IEFJFCBN ,
L$JFCB   EQU   *-JFCB
*
DSCB1    DSECT ,
         IECSDSL1 (1)                  FORMAT-1 DSCB
L$DSCB1  EQU   *-DSCB1
*
         POP   PRINT
XMIT02A  UFINI DXDX02A,L$X02AWA           pseudo-register
         END   ,
./ ADD NAME=XMIT02B  0100-02182-02182-0702-00209-00209-00000-XMIT370
XMIT02B  TITLE 'WRITE INMR02 INMCOPY segment'
*
* Copyright 2001, 2002 James M. Morrison
*
*----------------------------------------------------------------------
*  Things to do:
*----------------------------------------------------------------------
         U#SET ,
*----------------------------------------------------------------------
* Function: Collect the information for, and write the INMR02 segment.
*           for DSORG=PO or DSORG=PS datasets (INMR02 INMCOPY segment).
*
* Entry:  S/370 ECMODE KEY=8 STATE=PROB
*
*         R0  =
*         R1  =
*
* Exit:   R15 = return code
*         R15 = 00 success
*
* Abends:
*
* Notes: XMITUNLD calls us for either DSORG=PO or DSORG=PS datasets.
*        For DSORG=PO, XMIT02A has already unloaded the PDS using
*        IEBCOPY, closed the PDS's DCB, and opened the DCB for
*        IEBCOPY's unloaded dataset (as well as gotten the JFCB).
*
*        For DSORG=PS, XMIT370 has opened the input dataset, and
*        gotten the JFCB.  XMIT370 has the wrong DCB attributes for
*        a DSORG=PS dataset, since it assumes the SYSUT1 dataset will
*        be a PDS.  For DSORG=PS, we have to reopen the DCB with the
*        correct values.
*----------------------------------------------------------------------
* R2     DCB
* R3     JFCB
* R4
* R5
* R6
* R7
* R8
* R9
* R10
* R11    XMTWA
* R12    base reg
* R13    savearea
*----------------------------------------------------------------------
         TITLE ' '
*----------------------------------------------------------------------
XMIT02B  UPROC L=L$X02BWA,ID=X02B,WA=X02BWA
         UDIAG 1,'XMIT02B entered'
*----------------------------------------------------------------------
* Create INMR02 segment's key data
*----------------------------------------------------------------------
         MVI   X02SEGL,L$X02SGL                        segment length
         MVI   X02SEGF,SEG$1+SEG$L+SEG$C               segment flags
         MVC   X02ID,=C'INMR02'
         MVC   X02NUM,=AL4(1)          applies to file number 1
         MVC   X02KEY(L$MR02),MR02     copy bogus key data
*
* Update bogus data with (some) correct information
*
         L    R3,XMT@JFCB            SYSUT1/SYSUT2 JFCB
         USING JFCB,R3
         MVC   XDSORG,JFCDSORG       dsorg
         MVC   XLRECL+2(2),JFCLRECL  lrecl
         MVC   XRECFM(1),JFCRECFM    recfm
         MVC   XBLKSZ+2(2),JFCBLKSI  block size
*----------------------------------------------------------------------
* Write INMR02 segment
*----------------------------------------------------------------------
WRITE    DS    0H
         LA    R1,X02MR02
*        L     R2,XMT@PS
         UCALL XMITPUT                 write INMR02 segment
*----------------------------------------------------------------------
* Determine whether the XMTDCBI DCB correctly reflects the SYSUT1
* dataset's attributes when DSORG=PS.  XMIT02A took care of the
* DCB for DSORG=PO.
*----------------------------------------------------------------------
         LA    R3,XMTJFCB1             SYSUT1 JFCB
         TM    JFCDSRG1,JFCORGPS       DSORG=PS?
         BNO   EXIT                    no, xmit02a already fixed DCB
*----------------------------------------------------------------------
* Close the SYSUT1 input dataset
*----------------------------------------------------------------------
CLOSE    DS    0H
         UDIAG 2,'XMIT02B: closing DSORG=PS SYSUT1'
         MVC   XMTCLOS(L$CLOS),MODLCLOS     copy model CLOSE macro
         CLOSE XMTDCBI,MF=(E,XMTCLOS)
*----------------------------------------------------------------------
* Re-open SYSUT1 with correct DCB attributes
* We don't need to re-read the JFCB, since it hasn't changed since
* XMIT370 read it.
*----------------------------------------------------------------------
         LA    R2,XMTDCBI
         USING IHADCB,R2
         MVC   XMTOPN(L$OPN),MODLOPN     copy model OPEN macro
         MVC   XMTDCBI(L$DCBI),MODLDCBI  copy model DCB
         MVC   DCBRECFM,JFCRECFM         copy recfm from JFCB
         MVC   DCBLRECL,JFCLRECL         copy lrecl from JFCB
         MVC   DCBBLKSI,JFCBLKSI         copy blksize from JFCB
         UDIAG 3,'XMIT02B: SYSUT1 DCB',(R2),L$DCB
         OPEN  ((R2)),MF=(E,XMTOPN)
         TM    DCBOFLG1,DCBOFOPN            opened?
         BO    DCBIOPEN
         UDIAG 0,'XMIT02B: SYSUT1 DCB failed to open'
         UABEND ,                           input DCB didn't open
DCBIOPEN DS    0H
         UDIAG 3,'XMIT02B: SYSUT1 DCB open',(R2),L$DCB
*----------------------------------------------------------------------
* Return to caller with return code set
*----------------------------------------------------------------------
EXIT     DS    0H
         UDIAG 1,'XMIT02B exited'
         L     R15,X02RC
         UPEND ,
*
*
*       c9d5d4d9f0f2                          *INMR02          *
*       00000001
*       1028 0001 0007 c9d5d4c3d6d7e8         *INMCOPY         *
*       102c 0001 0004 0000bb60
*       003c 0001 0002 4000
*       0042 0001 0004 00007ff4
*       0030 0001 0004 00000c30
*       0049 0001 0002 4802
*
MR02     DS    0X
         DC    AL2(INMUTILN,1,L'VUTILN)     1028 utility name
VUTILN   DC    C'INMCOPY'
*
         DC    AL2(INMSIZE,1,L'VSIZE)       102C approx file size
VSIZE    DC    XL4'BB60'
*
         DC    AL2(INMDSORG,1,L'VDSORG)     003C dsorg
VDSORG   DC    XL2'4000'
*
         DC    AL2(INMLRECL,1,L'VLRECL)     0042 lrecl
VLRECL   DC    XL4'C30'
*
         DC    AL2(INMBLKSZ,1,L'VBLKSZ)     0030 optional blocksize
VBLKSZ   DC    AL4(23440)
*
         DC    AL2(INMRECFM,1,L'VRECFM)     0049 recfm
VRECFM   DC    X'4800'
L$MR02   EQU   *-MR02
*
* optional keys not provided: <figure out later>
*
MODLDCBI DCB   DDNAME=SYSUT1,                                          +
               DSORG=PS,               DEFINITELY                      +
               LRECL=0,BLKSIZE=0,      FILLED in dynamically           +
               RECFM=F,                MAYBE, maybe not                +
               MACRF=R
L$DCBI   EQU   *-MODLDCBI
*
MODLOPN  OPEN  (,INPUT),MF=L           model OPEN
L$OPN    EQU   *-MODLOPN               l' model open
*
MODLCLOS CLOSE (,),MF=L                model CLOSE
L$CLOS   EQU   *-MODLCLOS              l' model close
*
         LTORG ,
*----------------------------------------------------------------------
         EJECT ,
X02BWA   DSECT ,
X02SA    DS    18F
*
X02RC    DS    F             return code
X02MR02  DS    0D            INMR02 segment
X02SEGL  DS    X             segment length
X02SEGF  DS    X             segment flag
X02SEGD  DS    XL253         beginning of segment data
         ORG   X02SEGD
X02ID    DS    C'INMR02'
X02NUM   DS    XL4           files # (relative 1)
X02KEY   DS    0X            beginning of key data
         DC    AL2(INMUTILN,1,L'VUTILN)     1028 utility name
XUTILN   DC    C'INMCOPY'
         DC    AL2(INMSIZE,1,L'VSIZE)       102C approx file size
XSIZE    DC    XL4'BB60'
         DC    AL2(INMDSORG,1,L'VDSORG)     003C dsorg
XDSORG   DC    XL2'4000'
         DC    AL2(INMLRECL,1,L'VLRECL)     0042 lrecl
XLRECL   DC    XL4'C30'
         DC    AL2(INMBLKSZ,1,L'VBLKSZ)     0030 optional blocksize
XBLKSZ   DC    AL4(23440)
         DC    AL2(INMRECFM,1,L'VRECFM)     0049 recfm
XRECFM   DC    X'4800'
L$X02SGL EQU   *-X02MR02                    actual segment length
         ORG   ,
         DS    0D
L$X02BWA EQU   *-X02BWA
         EJECT ,
         PRINT NOGEN
         DXMITSEG ,
*        EJECT ,
         WAXMT FUNC=XMIT
*        EJECT ,
         DCBD  DSORG=PS,DEVD=DA
L$DCB    EQU   *-IHADCB
*
JFCB     DSECT ,
         IEFJFCBN ,
L$JFCB   EQU   *-JFCB
*
         PRINT GEN
XMIT02B  UFINI DXDX02B,L$X02BWA
         END   ,
./ ADD NAME=XMIT03   0100-02182-02182-0702-00161-00161-00000-XMIT370
XMIT03   TITLE 'WRITE INMR03 segment'
*
* Copyright 2001, 2002 James M. Morrison
*
*----------------------------------------------------------------------
*  Things to do:
*----------------------------------------------------------------------
         U#SET ,
*----------------------------------------------------------------------
* Function: Collect the information for, and write the INMR03 segment.
*
* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*
*
*         R0  =
*         R1  =
*
* Exit:   R15 = return code
*         R15 = 00 success
*
* Abends:
*
* Notes:  Very little of the INMR03 is "correct", but instead
*         reflects values seen in typical XMI datasets.
*----------------------------------------------------------------------
* R2     scratch
* R3     DVCT
* R4     UCB associated with extent
* R5     # extents
* R6     DCB
* R7     DEB, DEBDASD
* R8     estimated file size in bytes
* R9     JFCB for input file
* R10
* R11    XMTWA
* R12    base reg
* R13    savearea
*----------------------------------------------------------------------
         TITLE ' '
*----------------------------------------------------------------------
XMIT03   UPROC L=L$X03WA,ID=XM03,WA=X03WA
         UDIAG 1,'XMIT03 entered'
         LA    R9,XMTJFCB1             @ SYSUT1's JFCB
         USING JFCB,R9
*----------------------------------------------------------------------
* Create INMR03 segment's key data
*----------------------------------------------------------------------
         MVI   X03SEGL,L$X03SGL                  segment length
         MVI   X03SEGF,SEG$1+SEG$L+SEG$C         segment flag
         MVC   X03ID,=C'INMR03'
         MVC   X03KEY(L$MR03),MR03     copy bogus key data
*
*  Update bogus key data with correct values
*
**       mvc   x03dsorg,jfcdsorg       dsorg - leave bogus
**       mvc   x03recfm,jfcrecfm       recfm - leave bogus
         MVC   X03LRECL,JFCLRECL       lrecl
*
*  Calculate estimated file size
*
         LA    R1,XMTDCBI              SYSUT1/SYSUT2 DCB
         UCALL XMITESZ,ERR=EXIT
         STCM  R0,15,X03ESTSZ
*----------------------------------------------------------------------
* Write INMR03 segment
*----------------------------------------------------------------------
WRITE    DS    0H
         LA    R1,X03MR03
         UCALL XMITPUT                 write INMR03 segment
EXIT     DS    0H
         ST    R15,X03RC
         UDIAG 1,'XMIT03 exited'
         L     R15,X03RC
         UPEND  ,
*
         EJECT ,
*
*        c9d5d4d9f0f3                       *INMR03*
*        102c 0001 0004 0000bb60            filesize
*        003c 0001 0002 4000                DSORG=PS
*        0042 0001 0002 0050                LRECL=80
*        0049 0001 0002 0001                RECFM=<bogus>
*
MR03     DS    0X
KSIZE    DC    AL2(INMSIZE,1,L'VSIZE)       102C approx file size bytes
VSIZE    DC    XL4'BB60'
LSIZE    EQU   *-KSIZE
*
KDSORG   DC    AL2(INMDSORG,1,L'VDSORG)     003C dsorg <bogus>
VDSORG   DC    XL2'4000'
LDSORG   EQU   *-KDSORG
*
KLRECL   DC    AL2(INMLRECL,1,L'VLRECL)     0042 lrecl
VLRECL   DC    AL2(80)
LLRECL   EQU   *-KLRECL
*
KRECFM   DC    AL2(INMRECFM,1,L'VRECFM)     004.recfm <bogus>
VRECFM   DC    XL2'0001'
LRECFM   EQU   *-KRECFM
L$MR03   EQU   *-MR03
*
* optional keys not provided: none
*
*
         LTORG ,
*----------------------------------------------------------------------
         EJECT ,
X03WA    DSECT ,
X03SA    DS    18F
*
X03RC    DS    F             return code
X03MR03  DS    0D            INMR03 segment
X03SEGL  DS    X             segment length
X03SEGF  DS    X             segment flag
X03SEGD  DS    XL253         beginning of segment data
         ORG   X03SEGD
X03ID    DS    C'INMR03'
X03KEY   DS    0X            beginning of key data
         DC    AL2(INMSIZE,1,L'VSIZE)       102C approx file size bytes
X03ESTSZ DC    XL4'BB60'
         DC    AL2(INMDSORG,1,L'VDSORG)     003C dsorg
X03DSORG DC    XL2'4000'
         DC    AL2(INMLRECL,1,L'VLRECL)     0042 lrecl
X03LRECL DC    AL2(80)
         DC    AL2(INMRECFM,1,L'VRECFM)     0049 recfm
X03RECFM DC    XL2'0001'
L$X03SGL EQU   *-X03MR03                    actual segment length
         ORG   ,
         DS    0D
L$X03WA  EQU   *-X03WA
*
         EJECT ,
         PRINT NOGEN
         DXMITSEG ,
*        EJECT ,
         WAXMT FUNC=XMIT
*        EJECT ,
         IEZDEB LIST=YES
L$DEBDA  EQU   (DEBNMTRK+L'DEBNMTRK)-DEBDASD     l' debdasd section
*
*        EJECT ,
UCB      DSECT ,
         IEFUCBOB LIST=YES
*
*        EJECT ,
*----------------------------------------------------------------------
*  See Stage2 assembly of IECZDTAB for values & index
*----------------------------------------------------------------------
         IHADVCT ,
*
*        EJECT ,
         PRINT NOGEN
         CVT   DSECT=YES,LIST=NO
*
         DCBD  DSORG=PS,DEVD=DA
*
JFCB     DSECT ,
         IEFJFCBN ,
         PRINT GEN
*
XMIT03   UFINI DXDX03,L$X03WA
         END   ,
./ ADD NAME=XMIT06   0100-02182-02182-0702-00094-00094-00000-XMIT370
XMIT06   TITLE 'WRITE INMR06 segment'
*
* Copyright 2001, 2002 James M. Morrison
*
*----------------------------------------------------------------------
*  Things to do:
*----------------------------------------------------------------------
         U#SET ,
*----------------------------------------------------------------------
* Function: Write the INMR06 segment.
*
* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*
*
*         R0  =
*         R1  =
*
* Exit:   R15 = return code
*         R15 = 00 success
*
* Abends:
*
* Notes:
*----------------------------------------------------------------------
* R2     X06WA
* R3
* R4     @ segment data
* R5     length remaining in segment data
* R6
* R7
* R8
* R9
* R10
* R11    XMTWA
* R12    base reg
* R13    savearea
*----------------------------------------------------------------------
         TITLE ' '
*----------------------------------------------------------------------
XMIT06   UPROC L=L$X06WA,ID=XM06,WA=X06WA
         UDIAG 1,'XMIT06 entered'
*----------------------------------------------------------------------
* Create INMR06
*----------------------------------------------------------------------
         LA    R0,L$SEG6               segment length
         STC   R0,X06SEGL
         MVC   X06ID,=C'INMR06'
         MVI   X06SEGF,SEG$1+SEG$L+SEG$C
*----------------------------------------------------------------------
* Write INMR06 segment
*----------------------------------------------------------------------
WRITE    DS    0H
         LA    R1,X06MR06
         UCALL XMITPUT                 write INMR06 segment
*----------------------------------------------------------------------
* Final PUTSEG call issued, terminate PUTSEG service
*----------------------------------------------------------------------
         SLR   R1,R1                   PUTSEG terminate call
         UCALL XMITPUT                 terminate PUTSEG service
         LTR   R15,R15
         BZ    EXIT
*
         MVI   X06RC+3,8
EXIT     DS    0H
         UDIAG 1,'XMIT06 exited'
         L     R15,X06RC
         UPEND ,
*
         LTORG ,
*----------------------------------------------------------------------
*
*        c9d5d4d9 f0f6                       *INMR06*
*
X06WA    DSECT ,
X06SA    DS    18F
*
X06RC    DS    F             return code
X06MR06  DS    0D            INMR01 segment
X06SEGL  DS    X             segment length
X06SEGF  DS    X             segment flag
X06SEGD  DS    XL253         beginning of segment data
         ORG   X06SEGD
X06ID    DS    C'INMR06'
L$SEG6   EQU   *-X06MR06     length of segment written
         ORG   ,
         DS    0D
L$X06WA  EQU   *-X06WA
         EJECT ,
         PRINT NOGEN
         DXMITSEG ,
         EJECT ,
         WAXMT FUNC=XMIT
         PRINT GEN
XMIT06   UFINI DXDX06,L$X06WA
         END   ,
./ ADD NAME=XMIT370  0100-02182-02182-0702-00247-00247-00000-XMIT370
XMIT370  TITLE 'TSO/E TRANSMIT clone for MVS 3.8J'
*
*  Copyright 2001, James M. Morrison
*
*----------------------------------------------------------------------
*  Things to do:
*  1)  FREEPOOL SYSUT1/SYSUT2
*----------------------------------------------------------------------
         U#SET ,
*----------------------------------------------------------------------
* Function: Create a file compatible with TSO/E TRANSMIT,
*           given an input file that is a PDS.
*           This initial version runs in batch, not as a CP.
*
* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*
*
*         R0  =
*         R1  =  Address of OS parmlist
*         R13 =  savearea ptr
*         R14 =  return addr to caller
*         R15 =  address of XMIT370
*
* Exit:   R15 = return code
*         R15 = 00 success
*
* Abends: U0001 DCB didn't open
*
* Notes:  This routine is responsible for setting up its registers
*         as required by the PROC and PEND macros.
*----------------------------------------------------------------------
* R2     XPSWA
* R3     DCB
* R4     OS parm ptr
* R5
* R6
* R7
* R8
* R9
* R10    our real program base reg
* R11    XMTWA    ... ALL CSECTS (contains our savearea)
* R12    BASE REG ... ALL CSECTS (dummy for us)
* R13    savearea
*----------------------------------------------------------------------
         TITLE ' '
*----------------------------------------------------------------------
XMIT370  CSECT ,
         USING *,R15
         B     MPASTID
         DC    AL1(MAINIDX-MAINID)
MAINID   DC    CL8'XMIT370'       MODULE IDENTIFIER
         DC    CL8'&SYSDATE'      ASSEMBLY DATE
         DC    CL7' &SYSTIME'     ASSEMBLY TIME
MAINIDX  EQU   *
MAINSAL  DC    A(L$XMTWA)         XMTWA LENGTH
MPASTID  DS    0H
         DROP  R15
         STM   R14,R12,12(R13)    STANDARD REGISTER SAVE
         LR    R10,R15
         USING XMIT370,R10        BASE REGISTER
         LR    R4,R1              save parm ptr
         L     R3,L$DSA           LENGTH OF ALL DSAs
         LA    R3,4095(,R3)       ROUND
         SRL   R3,12              TO NEXT
         SLL   R3,12              PAGE
         GETMAIN R,LV=(R3)        GET STORAGE FOR DSAs
         LR    R11,R1
         USING XMTWA,R11
         UZERO (R11),(R3)         clear storage
*
* Init XMTWA
*
         MVC   XMTEYE,=C'XMITDSA '          set eyecatcher
         LA    R1,XMTSA1
         ST    R1,8(,R13)         FORWARD POINTER
         ST    R13,4(,R1)         BACKWARD POINTER
         LR    R13,R1
         ST    R3,XMTLDSA                   record l' dsa
         MVC   XMTDCBI(L$DCBI),MODLDCBI     copy model DCB macros
         MVC   XMTOPN(L$OPN),MODLOPN        copy model OPEN macro
         MVC   XMTCLOS(L$CLOS),MODLCLOS     copy model CLOSE macro
         MVC   XMTJFCBL(L$JFCBL),JFCBLST    copy open exit list
         LA    R0,XMTJFCB1                  relocate exlst JFCB addr
         STCM  R0,7,XMTJFCBL+1
         LA    R0,XMTJFCBL                  relocate DCB's EXLST
         STCM  R0,7,(DCBEXLSA-IHADCB)+XMTDCBI
         MVC   XMTXPSWE,=C'PUTWORK '        set XPSWA eyecatcher
         MVI   XMTDLEV,C'0'                 default diagnostic level
         LTR   R4,R4
         BZ    NOPARM
         L     R4,0(,R4)                    @ OS parm string
         LH    R14,0(,R4)                   l' parm string
         LTR   R14,R14                      anything?
         BNP   NOPARM                       no, br
         ST    R4,XMT@PARM                  save parm ptr
         MVC   XMTDLEV,2(R4)                copy diag char
NOPARM   DS    0H
*----------------------------------------------------------------------
*  setup fake PROC based on R12 so PROC macro works for rest of code
*----------------------------------------------------------------------
         LR    R12,R10                       UPROC assumes R12 set
         LA    R15,MAIN                      pretend we just got here
         PUSH  USING
         DROP  ,
         CNOP  0,8
MAIN     UPROC L=L$MAIN,SECT=LABEL,ID=MAIN,WA=
         POP   USING                         don't mess up our code
*----------------------------------------------------------------------
*  Wake up UTILLOG
*----------------------------------------------------------------------
         ULOG  'XMIT370 00.04 Copyright 2001, 2002, James M. Morrison'
         ULOG  'XMIT370 Initial Developer James M. Morrison'
         ULOG  'XMIT370 may be distributed under the terms of the Q Pub+
               lic License version 1.0'
         ULOG  ' '
*----------------------------------------------------------------------
*  Handle UTILDBUG ddname
*----------------------------------------------------------------------
         UCALL UTILDBUG                     handle XMITDBUG ddname
*----------------------------------------------------------------------
*  Verify we're authorized
*----------------------------------------------------------------------
         TESTAUTH FCTN=1                    authorized?
         LTR   R15,R15
         BZ    AUTHOK
         ULOG  'XMIT370 requires authorization'
         UABEND ,                           not authorized
AUTHOK   DS    0H
*----------------------------------------------------------------------
*  Open DCBs, complain & abend if they don't open
*----------------------------------------------------------------------
         LA    R3,XMTDCBI
         USING IHADCB,R3
*        udiag 3,'xmit370: xmtdcbi dcb',(r3),l$dcbi
         OPEN  (XMTDCBI,INPUT),MF=(E,XMTOPN)
         TM    DCBOFLG1,DCBOFOPN            opened?
         BO    DCBIOPEN
         ULOG  'XMIT370: SYSUT1 open failed'
         UABEND ,                           input DCB didn't open
DCBIOPEN DS    0H
         UDIAG 3,'XMIT370: SYSUT1 DCB opened',XMTDCBI,L$DCB
*
* Verify DSORG=PS or DSORG=PO
*
         TM    DCBDSRG1,DCBDSGPS            DSORG=PS?
         BO    ORGOK
         TM    DCBDSRG1,DCBDSGPO            DSORG=PO?
         BO    ORGOK
         ULOG  'XMIT370 only support DSORG=PS or DSORG=PO datasets'
         UABEND ,
ORGOK    DS    0H
*
* We have to read the JFCB after the dataset is open,
* otherwise the JFCB doesn't have the DSORG field filled in
* which confuses xmitunld when he finally looks at the JFCB
*
         RDJFCB (XMTDCBI,INPUT),MF=(E,XMTOPN)
         LTR   R15,R15
         BZ    HAVJFCB
         ULOG  'XMIT370: RDJFCB failed'
         UABEND ,
HAVJFCB  DS    0H
         UDIAG 3,'XMIT370: xmtdcbi jfcb',XMTJFCB1,L$JFCB
         LA    R0,XMTJFCB1
         ST    R0,XMT@JFCB                  SYSUT1's JFCB
*----------------------------------------------------------------------
*  Unload and write out segments as needed
*----------------------------------------------------------------------
         UCALL XMITUNLD,ERR=EXIT
*----------------------------------------------------------------------
*  Close DCBs and exit
*----------------------------------------------------------------------
         LA    R3,XMTDCBI
         TM    DCBOFLG1,DCBOFOPN            SYSUT1/SYSUT2 open?
         BNO   CLODCBI
         UDIAG 2,'XMIT370: close dcbi'
         CLOSE XMTDCBI,MF=(E,XMTCLOS)
**       FREEPOOL XMTDCBI                   ???????
CLODCBI  DS    0H
*
         LA    R3,XMTDCBL
         TM    DCBOFLG1,DCBOFOPN            XMITPRT open?
         BNO   CLODCBL
         UDIAG 2,'XMIT370: close dcbl; last message possible'
         CLOSE XMTDCBL,MF=(E,XMTCLOS)
         FREEPOOL XMTDCBL
CLODCBL  DS    0H
*
EXIT     DS    0H
         L     R3,XMTRC
         L     R13,XMTSA1+4        LOAD CALLER'S SAVE AREA PTR
         L     R0,XMTLDSA
         FREEMAIN R,LV=(0),A=(R11)      free XMITDSA
         L     R14,12(R13)        STANDARD REGISTER RESTORE
         LR    R15,R3             SET RETURN CODE
         LM    R0,R12,20(R13)     STANDARD REGISTER RESTORE
         XC    8(4,R13),8(R13)    ERASE XMIT370'S SAVEAREA PTR
         BR    R14                RETURN TO CALLER
*
         LTORG ,
*
MODLCLOS CLOSE (,),MF=L                model CLOSE
L$CLOS   EQU   *-MODLCLOS              l' model close
*
MODLOPN  OPEN  (,),MF=L                model OPEN
L$OPN    EQU   *-MODLOPN               l' model open
*
JFCBLST  DS    0F
         DC    XL1'87'
         DC    AL3(0)
L$JFCBL  EQU   *-JFCBLST
*
* If the SYSUT1 dataset is DSORG=PS, XMIT02B needs it opened
* If the SYSUT1 dataset is DSORG=PO, XMIT02A deals with closing
* and reopening the dataset.  The DCB below reflects DCB attributes
* that may not be true, but all the rest of our code examines the
* JFCB rather than the DCB to determine DCB attributes, so we're
* safe.
*
MODLDCBI DCB   DDNAME=SYSUT1,DSORG=PS,LRECL=256,BLKSIZE=256,RECFM=F,   +
               EXLST=JFCBLST,MACRF=R
L$DCBI   EQU   *-MODLDCBI
*
         EJECT ,
*----------------------------------------------------------------------
         WAXMT FUNC=XMIT
         EJECT ,
         DXMITSEG ,
         EJECT ,
SAVEAREA DSECT ,
         DS    18F           dummy "main" proc savearea
L$MAIN   EQU   *-SAVEAREA
*
         PRINT NOGEN
         DCBD  DSORG=PS,DEVD=DA
L$DCB    EQU   *-IHADCB
*
JFCB     DSECT ,
         IEFJFCBN ,
L$JFCB   EQU   *-JFCB
         PRINT GEN
XMIT370  UFINI DXDX370,L$XMTWA
XMIT370  UFINI DXDMAIN,L$MAIN
*
L$DSA    CXD   ,   LINKAGE EDITOR CALCULATES TOTAL DSA LENGTH FOR US
*                  NOTE: THIS TECHNIQUE WILL FAIL FOR RECURSIVE CODE
*
         END   ,
./ ADD NAME=ZTEST    0100-02182-02182-0702-00038-00038-00000-XMIT370
*
* Copyright 2001, 2002 James M. Morrison
*
         MACRO
         XTEST &JUNK,&V=
         LCLC &A(2),&B
         MNOTE *,'XTEST V(1)    + &V(1) +'
         MNOTE *,'XTEST V(2)    + &V(2) +'
&A(1)    SETC  '&V(1)'(2,1)
&A(2)    SETC  '&V(1)'(4,1)
.*
&B       SETC  '&V(2)'
&B       SETC  '&B'(2,K'&B-2)
         MNOTE *,'XTEST A(1)=&A(1) A(2)=&A(2) B=&B'
         BOGUS (&A(1),&A(2)),(&B)
         MEND
*
         MACRO
         BOGUS &J,&K
         MNOTE *,'SYSLIST(1)    + &SYSLIST(1) + SHOULD BE (A,B)'
         MNOTE *,'SYSLIST(2)    + &SYSLIST(2) + SHOULD BE (X,Y)'
         MNOTE *,'SYSLIST(1,1)  + &SYSLIST(1,1) + SHOULD BE A'
         MNOTE *,'SYSLIST(1,2)  + &SYSLIST(1,2) + SHOULD BE B'
         MNOTE *,'SYSLIST(2,1)  + &SYSLIST(2,1) + SHOULD BE X'
         MNOTE *,'SYSLIST(2,2)  + &SYSLIST(2,2) + SHOULD BE Y'
         MNOTE *,'J             + &J    + SHOULD BE (A,B)'
         MNOTE *,'K             + &K    + SHOULD BE (X,Y)'
         MNOTE *,'J(1)          + &J(1) +  SHOULD BE A'
         MNOTE *,'J(2)          + &J(2) +  SHOULD BE B'
         MNOTE *,'K(1)          + &K(1) +  SHOULD BE X'
         MNOTE *,'K(2)          + &K(2) +  SHOULD BE Y'
         MEND
         EJECT
BOGUS    CSECT ,
         USING *,15
         XTEST X,V=((A,B),(X,Y))
         BOGUS (A,B),(X,Y)
         END   ,
./ ADD NAME=ZTESTOLD 0100-02182-02182-0702-00090-00090-00000-XMIT370
*
* Copyright 2001, 2002 James M. Morrison
*
*----------------------------------------------------------------------
* Macro errors - COPY macros
*----------------------------------------------------------------------
*        COPY  IM#INSTR
*
*        COPY  IM#LALR
*
*        COPY  IM#IGEN
*
         MACRO
&LABEL   XTEST &JUNK,&V=
.* BEL   IM#INSTF &V(1),&V(2),&V(3),&V(4),&V(5),&V(6),REG=R1,LST=&V
         BOGUS &V(1),&V(2),&V(3),&V(4),&V(5),&V(6)
.*       BOGUS &V
         MEND
*
         MACRO
         BOGUS &V
         LCLC  &J(3)
&J(1)    SETC  '&SYSLIST(1)'
&J(2)    SETC  '&SYSLIST(2)'
&J(3)    SETC  '&SYSLIST(3)'
         MNOTE *,'< > + &J(1) + &J(2) + &J(3)'
&J(1)    SETC  '&SYSLIST(1,1)'
&J(2)    SETC  '&SYSLIST(1,2)'
&J(3)    SETC  '&SYSLIST(1,3)'
         MNOTE *,'<1> + &J(1) + &J(2) + &J(3)'
&J(1)    SETC  '&SYSLIST(2,1)'
&J(2)    SETC  '&SYSLIST(2,2)'
&J(3)    SETC  '&SYSLIST(2,3)'
         MNOTE *,'<2> + &J(1) + &J(2) + &J(3)'
&J(1)    SETC  '&SYSLIST(3,1)'
&J(2)    SETC  '&SYSLIST(3,2)'
&J(3)    SETC  '&SYSLIST(3,3)'
         MNOTE *,'<3> + &J(1) + &J(2) + &J(3)'
         MEND
*
         PRINT OFF
         XMIT#SET ,
RECVRCPY PROC ID=TEST,L=L$SAV
         PRINT ON
         XTEST X,V=(R3)
*
         XTEST X,V=F4
*
         XTEST X,V=*F4
*
         XTEST X,V=.F4
*
         XTEST X,V=-CLEAR-
*
         XTEST X,V=(-CLEAR-)
*
         XTEST X,V=((-CLEAR-))
*
         XTEST X,V=(-ZERO-)
*                                      probably not a good idea;
         XTEST X,V=((SR,R1))           assumes internal macro knowledge
*
         XTEST X,V=(-0-)               better
*
         XTEST X,V=((ICM,12,F2))
*
         XTEST X,V=((-ZERO-),(IC,F1))
*
         XTEST X,V=((LH,F2),(STH,F4))
*
         XTEST X,V=((LH,F2),(ICM,8,F1),(MVI,F4,1))
*
         XTEST X,V=((MVI,F1,8))
*
         XTEST X,V=((MVC,F1,F2))
*
         XTEST X,V=((-0-),(IC,F1),(OI,F4,32))
*
GONZO    XTEST X,V=((MVC,F4(2),=X'4170'),(MVC,F4+2(2),=S(F1)),         +
               (-0-),(EX,F4),(LR,R7))
*
         LTORG ,
SAVEAREA DSECT ,
F4       DS    F
F2       DS    H
F1       DS    C
L$SAV    EQU   *-SAVEAREA
         XMTWA FUNC=UTIL,GEN=NO,DATA=NO,PRINT=OFF
RECVRCPY XMITFINI DXDTEST,L$SAV
         END   ,
